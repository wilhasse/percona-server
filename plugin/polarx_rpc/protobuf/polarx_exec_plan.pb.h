// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polarx_exec_plan.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_polarx_5fexec_5fplan_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_polarx_5fexec_5fplan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "polarx_expr.pb.h"
#include "polarx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_polarx_5fexec_5fplan_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_polarx_5fexec_5fplan_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_polarx_5fexec_5fplan_2eproto;
namespace PolarXRPC {
namespace ExecPlan {
class Aggr;
struct AggrDefaultTypeInternal;
extern AggrDefaultTypeInternal _Aggr_default_instance_;
class AnyPlan;
struct AnyPlanDefaultTypeInternal;
extern AnyPlanDefaultTypeInternal _AnyPlan_default_instance_;
class AutoSp;
struct AutoSpDefaultTypeInternal;
extern AutoSpDefaultTypeInternal _AutoSp_default_instance_;
class BloomFilter;
struct BloomFilterDefaultTypeInternal;
extern BloomFilterDefaultTypeInternal _BloomFilter_default_instance_;
class CloseSession;
struct CloseSessionDefaultTypeInternal;
extern CloseSessionDefaultTypeInternal _CloseSession_default_instance_;
class EnumSession;
struct EnumSessionDefaultTypeInternal;
extern EnumSessionDefaultTypeInternal _EnumSession_default_instance_;
class ExecPlan;
struct ExecPlanDefaultTypeInternal;
extern ExecPlanDefaultTypeInternal _ExecPlan_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class GetExpr;
struct GetExprDefaultTypeInternal;
extern GetExprDefaultTypeInternal _GetExpr_default_instance_;
class GetPlan;
struct GetPlanDefaultTypeInternal;
extern GetPlanDefaultTypeInternal _GetPlan_default_instance_;
class GetTSO;
struct GetTSODefaultTypeInternal;
extern GetTSODefaultTypeInternal _GetTSO_default_instance_;
class IndexInfo;
struct IndexInfoDefaultTypeInternal;
extern IndexInfoDefaultTypeInternal _IndexInfo_default_instance_;
class KeyExpr;
struct KeyExprDefaultTypeInternal;
extern KeyExprDefaultTypeInternal _KeyExpr_default_instance_;
class KeyOnlyRangeScan;
struct KeyOnlyRangeScanDefaultTypeInternal;
extern KeyOnlyRangeScanDefaultTypeInternal _KeyOnlyRangeScan_default_instance_;
class NewSession;
struct NewSessionDefaultTypeInternal;
extern NewSessionDefaultTypeInternal _NewSession_default_instance_;
class Project;
struct ProjectDefaultTypeInternal;
extern ProjectDefaultTypeInternal _Project_default_instance_;
class RangeScan;
struct RangeScanDefaultTypeInternal;
extern RangeScanDefaultTypeInternal _RangeScan_default_instance_;
class ResultTSO;
struct ResultTSODefaultTypeInternal;
extern ResultTSODefaultTypeInternal _ResultTSO_default_instance_;
class SessionInfo;
struct SessionInfoDefaultTypeInternal;
extern SessionInfoDefaultTypeInternal _SessionInfo_default_instance_;
class SessionInfos;
struct SessionInfosDefaultTypeInternal;
extern SessionInfosDefaultTypeInternal _SessionInfos_default_instance_;
class TableInfo;
struct TableInfoDefaultTypeInternal;
extern TableInfoDefaultTypeInternal _TableInfo_default_instance_;
class TableProject;
struct TableProjectDefaultTypeInternal;
extern TableProjectDefaultTypeInternal _TableProject_default_instance_;
class TableScanPlan;
struct TableScanPlanDefaultTypeInternal;
extern TableScanPlanDefaultTypeInternal _TableScanPlan_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
}  // namespace ExecPlan
}  // namespace PolarXRPC
PROTOBUF_NAMESPACE_OPEN
template<> ::PolarXRPC::ExecPlan::Aggr* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::Aggr>(Arena*);
template<> ::PolarXRPC::ExecPlan::AnyPlan* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::AnyPlan>(Arena*);
template<> ::PolarXRPC::ExecPlan::AutoSp* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::AutoSp>(Arena*);
template<> ::PolarXRPC::ExecPlan::BloomFilter* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::BloomFilter>(Arena*);
template<> ::PolarXRPC::ExecPlan::CloseSession* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::CloseSession>(Arena*);
template<> ::PolarXRPC::ExecPlan::EnumSession* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::EnumSession>(Arena*);
template<> ::PolarXRPC::ExecPlan::ExecPlan* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::ExecPlan>(Arena*);
template<> ::PolarXRPC::ExecPlan::Filter* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::Filter>(Arena*);
template<> ::PolarXRPC::ExecPlan::GetExpr* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::GetExpr>(Arena*);
template<> ::PolarXRPC::ExecPlan::GetPlan* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::GetPlan>(Arena*);
template<> ::PolarXRPC::ExecPlan::GetTSO* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::GetTSO>(Arena*);
template<> ::PolarXRPC::ExecPlan::IndexInfo* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::IndexInfo>(Arena*);
template<> ::PolarXRPC::ExecPlan::KeyExpr* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::KeyExpr>(Arena*);
template<> ::PolarXRPC::ExecPlan::KeyOnlyRangeScan* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::KeyOnlyRangeScan>(Arena*);
template<> ::PolarXRPC::ExecPlan::NewSession* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::NewSession>(Arena*);
template<> ::PolarXRPC::ExecPlan::Project* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::Project>(Arena*);
template<> ::PolarXRPC::ExecPlan::RangeScan* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::RangeScan>(Arena*);
template<> ::PolarXRPC::ExecPlan::ResultTSO* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::ResultTSO>(Arena*);
template<> ::PolarXRPC::ExecPlan::SessionInfo* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::SessionInfo>(Arena*);
template<> ::PolarXRPC::ExecPlan::SessionInfos* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::SessionInfos>(Arena*);
template<> ::PolarXRPC::ExecPlan::TableInfo* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::TableInfo>(Arena*);
template<> ::PolarXRPC::ExecPlan::TableProject* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::TableProject>(Arena*);
template<> ::PolarXRPC::ExecPlan::TableScanPlan* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::TableScanPlan>(Arena*);
template<> ::PolarXRPC::ExecPlan::Transaction* Arena::CreateMaybeMessage<::PolarXRPC::ExecPlan::Transaction>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PolarXRPC {
namespace ExecPlan {

enum AutoSp_Operation : int {
  AutoSp_Operation_SET = 0,
  AutoSp_Operation_RELEASE = 1,
  AutoSp_Operation_ROLLBACK = 2
};
bool AutoSp_Operation_IsValid(int value);
constexpr AutoSp_Operation AutoSp_Operation_Operation_MIN = AutoSp_Operation_SET;
constexpr AutoSp_Operation AutoSp_Operation_Operation_MAX = AutoSp_Operation_ROLLBACK;
constexpr int AutoSp_Operation_Operation_ARRAYSIZE = AutoSp_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AutoSp_Operation_descriptor();
template<typename T>
inline const std::string& AutoSp_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutoSp_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutoSp_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AutoSp_Operation_descriptor(), enum_t_value);
}
inline bool AutoSp_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoSp_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AutoSp_Operation>(
    AutoSp_Operation_descriptor(), name, value);
}
enum Aggr_AggrType : int {
  Aggr_AggrType_COUNT_FUNC = 1,
  Aggr_AggrType_COUNT_DISTINCT_FUNC = 2,
  Aggr_AggrType_SUM_FUNC = 3,
  Aggr_AggrType_SUM_DISTINCT_FUNC = 4,
  Aggr_AggrType_AVG_FUNC = 5,
  Aggr_AggrType_AVG_DISTINCT_FUNC = 6,
  Aggr_AggrType_MIN_FUNC = 7,
  Aggr_AggrType_MAX_FUNC = 8
};
bool Aggr_AggrType_IsValid(int value);
constexpr Aggr_AggrType Aggr_AggrType_AggrType_MIN = Aggr_AggrType_COUNT_FUNC;
constexpr Aggr_AggrType Aggr_AggrType_AggrType_MAX = Aggr_AggrType_MAX_FUNC;
constexpr int Aggr_AggrType_AggrType_ARRAYSIZE = Aggr_AggrType_AggrType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Aggr_AggrType_descriptor();
template<typename T>
inline const std::string& Aggr_AggrType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Aggr_AggrType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Aggr_AggrType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Aggr_AggrType_descriptor(), enum_t_value);
}
inline bool Aggr_AggrType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Aggr_AggrType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Aggr_AggrType>(
    Aggr_AggrType_descriptor(), name, value);
}
enum AnyPlan_PlanType : int {
  AnyPlan_PlanType_GET = 1,
  AnyPlan_PlanType_TABLE_SCAN = 2,
  AnyPlan_PlanType_TABLE_PROJECT = 3,
  AnyPlan_PlanType_PROJECT = 4,
  AnyPlan_PlanType_FILTER = 5,
  AnyPlan_PlanType_RANGE_SCAN = 8,
  AnyPlan_PlanType_AGGR = 9
};
bool AnyPlan_PlanType_IsValid(int value);
constexpr AnyPlan_PlanType AnyPlan_PlanType_PlanType_MIN = AnyPlan_PlanType_GET;
constexpr AnyPlan_PlanType AnyPlan_PlanType_PlanType_MAX = AnyPlan_PlanType_AGGR;
constexpr int AnyPlan_PlanType_PlanType_ARRAYSIZE = AnyPlan_PlanType_PlanType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnyPlan_PlanType_descriptor();
template<typename T>
inline const std::string& AnyPlan_PlanType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnyPlan_PlanType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnyPlan_PlanType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AnyPlan_PlanType_descriptor(), enum_t_value);
}
inline bool AnyPlan_PlanType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnyPlan_PlanType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AnyPlan_PlanType>(
    AnyPlan_PlanType_descriptor(), name, value);
}
// ===================================================================

class NewSession final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.NewSession) */ {
 public:
  inline NewSession() : NewSession(nullptr) {}
  explicit constexpr NewSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewSession(const NewSession& from);
  NewSession(NewSession&& from) noexcept
    : NewSession() {
    *this = ::std::move(from);
  }

  inline NewSession& operator=(const NewSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewSession& operator=(NewSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewSession* internal_default_instance() {
    return reinterpret_cast<const NewSession*>(
               &_NewSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NewSession& a, NewSession& b) {
    a.Swap(&b);
  }
  inline void Swap(NewSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewSession>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NewSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NewSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.NewSession";
  }
  protected:
  explicit NewSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.NewSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class CloseSession final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.CloseSession) */ {
 public:
  inline CloseSession() : CloseSession(nullptr) {}
  explicit constexpr CloseSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseSession(const CloseSession& from);
  CloseSession(CloseSession&& from) noexcept
    : CloseSession() {
    *this = ::std::move(from);
  }

  inline CloseSession& operator=(const CloseSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseSession& operator=(CloseSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseSession* internal_default_instance() {
    return reinterpret_cast<const CloseSession*>(
               &_CloseSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CloseSession& a, CloseSession& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseSession>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.CloseSession";
  }
  protected:
  explicit CloseSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.CloseSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class EnumSession final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.EnumSession) */ {
 public:
  inline EnumSession() : EnumSession(nullptr) {}
  explicit constexpr EnumSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnumSession(const EnumSession& from);
  EnumSession(EnumSession&& from) noexcept
    : EnumSession() {
    *this = ::std::move(from);
  }

  inline EnumSession& operator=(const EnumSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumSession& operator=(EnumSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumSession* internal_default_instance() {
    return reinterpret_cast<const EnumSession*>(
               &_EnumSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EnumSession& a, EnumSession& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnumSession>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EnumSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EnumSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.EnumSession";
  }
  protected:
  explicit EnumSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.EnumSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class SessionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.SessionInfo) */ {
 public:
  inline SessionInfo() : SessionInfo(nullptr) {}
  explicit constexpr SessionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionInfo(const SessionInfo& from);
  SessionInfo(SessionInfo&& from) noexcept
    : SessionInfo() {
    *this = ::std::move(from);
  }

  inline SessionInfo& operator=(const SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionInfo& operator=(SessionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionInfo* internal_default_instance() {
    return reinterpret_cast<const SessionInfo*>(
               &_SessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SessionInfo& a, SessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SessionInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SessionInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.SessionInfo";
  }
  protected:
  explicit SessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.SessionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class SessionInfos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.SessionInfos) */ {
 public:
  inline SessionInfos() : SessionInfos(nullptr) {}
  ~SessionInfos() override;
  explicit constexpr SessionInfos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionInfos(const SessionInfos& from);
  SessionInfos(SessionInfos&& from) noexcept
    : SessionInfos() {
    *this = ::std::move(from);
  }

  inline SessionInfos& operator=(const SessionInfos& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionInfos& operator=(SessionInfos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionInfos& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionInfos* internal_default_instance() {
    return reinterpret_cast<const SessionInfos*>(
               &_SessionInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SessionInfos& a, SessionInfos& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionInfos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionInfos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionInfos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionInfos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionInfos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionInfos& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionInfos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.SessionInfos";
  }
  protected:
  explicit SessionInfos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionsFieldNumber = 1,
  };
  // repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
  int sessions_size() const;
  private:
  int _internal_sessions_size() const;
  public:
  void clear_sessions();
  ::PolarXRPC::ExecPlan::SessionInfo* mutable_sessions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::SessionInfo >*
      mutable_sessions();
  private:
  const ::PolarXRPC::ExecPlan::SessionInfo& _internal_sessions(int index) const;
  ::PolarXRPC::ExecPlan::SessionInfo* _internal_add_sessions();
  public:
  const ::PolarXRPC::ExecPlan::SessionInfo& sessions(int index) const;
  ::PolarXRPC::ExecPlan::SessionInfo* add_sessions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::SessionInfo >&
      sessions() const;

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.SessionInfos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::SessionInfo > sessions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class TableInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.TableInfo) */ {
 public:
  inline TableInfo() : TableInfo(nullptr) {}
  ~TableInfo() override;
  explicit constexpr TableInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableInfo(const TableInfo& from);
  TableInfo(TableInfo&& from) noexcept
    : TableInfo() {
    *this = ::std::move(from);
  }

  inline TableInfo& operator=(const TableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableInfo& operator=(TableInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableInfo* internal_default_instance() {
    return reinterpret_cast<const TableInfo*>(
               &_TableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TableInfo& a, TableInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TableInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.TableInfo";
  }
  protected:
  explicit TableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSchemaNameFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // required .PolarXRPC.Datatypes.Scalar name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::PolarXRPC::Datatypes::Scalar& name() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Datatypes::Scalar* release_name();
  ::PolarXRPC::Datatypes::Scalar* mutable_name();
  void set_allocated_name(::PolarXRPC::Datatypes::Scalar* name);
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_name() const;
  ::PolarXRPC::Datatypes::Scalar* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::PolarXRPC::Datatypes::Scalar* name);
  ::PolarXRPC::Datatypes::Scalar* unsafe_arena_release_name();

  // optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
  bool has_schema_name() const;
  private:
  bool _internal_has_schema_name() const;
  public:
  void clear_schema_name();
  const ::PolarXRPC::Datatypes::Scalar& schema_name() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Datatypes::Scalar* release_schema_name();
  ::PolarXRPC::Datatypes::Scalar* mutable_schema_name();
  void set_allocated_schema_name(::PolarXRPC::Datatypes::Scalar* schema_name);
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_schema_name() const;
  ::PolarXRPC::Datatypes::Scalar* _internal_mutable_schema_name();
  public:
  void unsafe_arena_set_allocated_schema_name(
      ::PolarXRPC::Datatypes::Scalar* schema_name);
  ::PolarXRPC::Datatypes::Scalar* unsafe_arena_release_schema_name();

  // optional int64 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.TableInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::Datatypes::Scalar* name_;
  ::PolarXRPC::Datatypes::Scalar* schema_name_;
  int64_t version_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class IndexInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.IndexInfo) */ {
 public:
  inline IndexInfo() : IndexInfo(nullptr) {}
  ~IndexInfo() override;
  explicit constexpr IndexInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexInfo(const IndexInfo& from);
  IndexInfo(IndexInfo&& from) noexcept
    : IndexInfo() {
    *this = ::std::move(from);
  }

  inline IndexInfo& operator=(const IndexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexInfo& operator=(IndexInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexInfo* internal_default_instance() {
    return reinterpret_cast<const IndexInfo*>(
               &_IndexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IndexInfo& a, IndexInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IndexInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.IndexInfo";
  }
  protected:
  explicit IndexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUsePartsFieldNumber = 2,
  };
  // required .PolarXRPC.Datatypes.Scalar name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::PolarXRPC::Datatypes::Scalar& name() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Datatypes::Scalar* release_name();
  ::PolarXRPC::Datatypes::Scalar* mutable_name();
  void set_allocated_name(::PolarXRPC::Datatypes::Scalar* name);
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_name() const;
  ::PolarXRPC::Datatypes::Scalar* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::PolarXRPC::Datatypes::Scalar* name);
  ::PolarXRPC::Datatypes::Scalar* unsafe_arena_release_name();

  // optional int32 use_parts = 2;
  bool has_use_parts() const;
  private:
  bool _internal_has_use_parts() const;
  public:
  void clear_use_parts();
  int32_t use_parts() const;
  void set_use_parts(int32_t value);
  private:
  int32_t _internal_use_parts() const;
  void _internal_set_use_parts(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.IndexInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::Datatypes::Scalar* name_;
  int32_t use_parts_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  explicit constexpr Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Transaction& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Transaction& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.Transaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class BloomFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.BloomFilter) */ {
 public:
  inline BloomFilter() : BloomFilter(nullptr) {}
  ~BloomFilter() override;
  explicit constexpr BloomFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BloomFilter(const BloomFilter& from);
  BloomFilter(BloomFilter&& from) noexcept
    : BloomFilter() {
    *this = ::std::move(from);
  }

  inline BloomFilter& operator=(const BloomFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline BloomFilter& operator=(BloomFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BloomFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const BloomFilter* internal_default_instance() {
    return reinterpret_cast<const BloomFilter*>(
               &_BloomFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BloomFilter& a, BloomFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(BloomFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BloomFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BloomFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BloomFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BloomFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BloomFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BloomFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.BloomFilter";
  }
  protected:
  explicit BloomFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyFieldNumber = 3,
    kDataFieldNumber = 4,
    kTotalBitsFieldNumber = 1,
    kNumberHashFieldNumber = 2,
  };
  // required bytes strategy = 3;
  bool has_strategy() const;
  private:
  bool _internal_has_strategy() const;
  public:
  void clear_strategy();
  const std::string& strategy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy();
  PROTOBUF_NODISCARD std::string* release_strategy();
  void set_allocated_strategy(std::string* strategy);
  private:
  const std::string& _internal_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy(const std::string& value);
  std::string* _internal_mutable_strategy();
  public:

  // required bytes data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required uint32 total_bits = 1;
  bool has_total_bits() const;
  private:
  bool _internal_has_total_bits() const;
  public:
  void clear_total_bits();
  uint32_t total_bits() const;
  void set_total_bits(uint32_t value);
  private:
  uint32_t _internal_total_bits() const;
  void _internal_set_total_bits(uint32_t value);
  public:

  // required uint32 number_hash = 2;
  bool has_number_hash() const;
  private:
  bool _internal_has_number_hash() const;
  public:
  void clear_number_hash();
  uint32_t number_hash() const;
  void set_number_hash(uint32_t value);
  private:
  uint32_t _internal_number_hash() const;
  void _internal_set_number_hash(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.BloomFilter)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t total_bits_;
  uint32_t number_hash_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class GetTSO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.GetTSO) */ {
 public:
  inline GetTSO() : GetTSO(nullptr) {}
  ~GetTSO() override;
  explicit constexpr GetTSO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTSO(const GetTSO& from);
  GetTSO(GetTSO&& from) noexcept
    : GetTSO() {
    *this = ::std::move(from);
  }

  inline GetTSO& operator=(const GetTSO& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTSO& operator=(GetTSO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTSO& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTSO* internal_default_instance() {
    return reinterpret_cast<const GetTSO*>(
               &_GetTSO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetTSO& a, GetTSO& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTSO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTSO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTSO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTSO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTSO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTSO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTSO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.GetTSO";
  }
  protected:
  explicit GetTSO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderNameFieldNumber = 1,
    kBatchCountFieldNumber = 2,
  };
  // required bytes leader_name = 1;
  bool has_leader_name() const;
  private:
  bool _internal_has_leader_name() const;
  public:
  void clear_leader_name();
  const std::string& leader_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader_name();
  PROTOBUF_NODISCARD std::string* release_leader_name();
  void set_allocated_leader_name(std::string* leader_name);
  private:
  const std::string& _internal_leader_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader_name(const std::string& value);
  std::string* _internal_mutable_leader_name();
  public:

  // required int32 batch_count = 2;
  bool has_batch_count() const;
  private:
  bool _internal_has_batch_count() const;
  public:
  void clear_batch_count();
  int32_t batch_count() const;
  void set_batch_count(int32_t value);
  private:
  int32_t _internal_batch_count() const;
  void _internal_set_batch_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.GetTSO)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_name_;
  int32_t batch_count_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class ResultTSO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.ResultTSO) */ {
 public:
  inline ResultTSO() : ResultTSO(nullptr) {}
  ~ResultTSO() override;
  explicit constexpr ResultTSO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultTSO(const ResultTSO& from);
  ResultTSO(ResultTSO&& from) noexcept
    : ResultTSO() {
    *this = ::std::move(from);
  }

  inline ResultTSO& operator=(const ResultTSO& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultTSO& operator=(ResultTSO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultTSO& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultTSO* internal_default_instance() {
    return reinterpret_cast<const ResultTSO*>(
               &_ResultTSO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResultTSO& a, ResultTSO& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultTSO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultTSO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultTSO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultTSO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultTSO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResultTSO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultTSO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.ResultTSO";
  }
  protected:
  explicit ResultTSO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsFieldNumber = 2,
    kErrorNoFieldNumber = 1,
  };
  // required uint64 ts = 2;
  bool has_ts() const;
  private:
  bool _internal_has_ts() const;
  public:
  void clear_ts();
  uint64_t ts() const;
  void set_ts(uint64_t value);
  private:
  uint64_t _internal_ts() const;
  void _internal_set_ts(uint64_t value);
  public:

  // required int32 error_no = 1;
  bool has_error_no() const;
  private:
  bool _internal_has_error_no() const;
  public:
  void clear_error_no();
  int32_t error_no() const;
  void set_error_no(int32_t value);
  private:
  int32_t _internal_error_no() const;
  void _internal_set_error_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.ResultTSO)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t ts_;
  int32_t error_no_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class AutoSp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.AutoSp) */ {
 public:
  inline AutoSp() : AutoSp(nullptr) {}
  ~AutoSp() override;
  explicit constexpr AutoSp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoSp(const AutoSp& from);
  AutoSp(AutoSp&& from) noexcept
    : AutoSp() {
    *this = ::std::move(from);
  }

  inline AutoSp& operator=(const AutoSp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoSp& operator=(AutoSp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoSp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoSp* internal_default_instance() {
    return reinterpret_cast<const AutoSp*>(
               &_AutoSp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AutoSp& a, AutoSp& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoSp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoSp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoSp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoSp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoSp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AutoSp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoSp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.AutoSp";
  }
  protected:
  explicit AutoSp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AutoSp_Operation Operation;
  static constexpr Operation SET =
    AutoSp_Operation_SET;
  static constexpr Operation RELEASE =
    AutoSp_Operation_RELEASE;
  static constexpr Operation ROLLBACK =
    AutoSp_Operation_ROLLBACK;
  static inline bool Operation_IsValid(int value) {
    return AutoSp_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    AutoSp_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    AutoSp_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    AutoSp_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return AutoSp_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return AutoSp_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return AutoSp_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSpNameFieldNumber = 2,
    kOpFieldNumber = 1,
    kResetErrorFieldNumber = 3,
  };
  // required bytes sp_name = 2;
  bool has_sp_name() const;
  private:
  bool _internal_has_sp_name() const;
  public:
  void clear_sp_name();
  const std::string& sp_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sp_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sp_name();
  PROTOBUF_NODISCARD std::string* release_sp_name();
  void set_allocated_sp_name(std::string* sp_name);
  private:
  const std::string& _internal_sp_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sp_name(const std::string& value);
  std::string* _internal_mutable_sp_name();
  public:

  // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  ::PolarXRPC::ExecPlan::AutoSp_Operation op() const;
  void set_op(::PolarXRPC::ExecPlan::AutoSp_Operation value);
  private:
  ::PolarXRPC::ExecPlan::AutoSp_Operation _internal_op() const;
  void _internal_set_op(::PolarXRPC::ExecPlan::AutoSp_Operation value);
  public:

  // optional bool reset_error = 3;
  bool has_reset_error() const;
  private:
  bool _internal_has_reset_error() const;
  public:
  void clear_reset_error();
  bool reset_error() const;
  void set_reset_error(bool value);
  private:
  bool _internal_reset_error() const;
  void _internal_set_reset_error(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.AutoSp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sp_name_;
  int op_;
  bool reset_error_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class KeyExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.KeyExpr) */ {
 public:
  inline KeyExpr() : KeyExpr(nullptr) {}
  ~KeyExpr() override;
  explicit constexpr KeyExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyExpr(const KeyExpr& from);
  KeyExpr(KeyExpr&& from) noexcept
    : KeyExpr() {
    *this = ::std::move(from);
  }

  inline KeyExpr& operator=(const KeyExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyExpr& operator=(KeyExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyExpr* internal_default_instance() {
    return reinterpret_cast<const KeyExpr*>(
               &_KeyExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(KeyExpr& a, KeyExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyExpr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.KeyExpr";
  }
  protected:
  explicit KeyExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required .PolarXRPC.Datatypes.Scalar field = 1;
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  const ::PolarXRPC::Datatypes::Scalar& field() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Datatypes::Scalar* release_field();
  ::PolarXRPC::Datatypes::Scalar* mutable_field();
  void set_allocated_field(::PolarXRPC::Datatypes::Scalar* field);
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_field() const;
  ::PolarXRPC::Datatypes::Scalar* _internal_mutable_field();
  public:
  void unsafe_arena_set_allocated_field(
      ::PolarXRPC::Datatypes::Scalar* field);
  ::PolarXRPC::Datatypes::Scalar* unsafe_arena_release_field();

  // required .PolarXRPC.Datatypes.Scalar value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PolarXRPC::Datatypes::Scalar& value() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Datatypes::Scalar* release_value();
  ::PolarXRPC::Datatypes::Scalar* mutable_value();
  void set_allocated_value(::PolarXRPC::Datatypes::Scalar* value);
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_value() const;
  ::PolarXRPC::Datatypes::Scalar* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PolarXRPC::Datatypes::Scalar* value);
  ::PolarXRPC::Datatypes::Scalar* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.KeyExpr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::Datatypes::Scalar* field_;
  ::PolarXRPC::Datatypes::Scalar* value_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class GetExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.GetExpr) */ {
 public:
  inline GetExpr() : GetExpr(nullptr) {}
  ~GetExpr() override;
  explicit constexpr GetExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetExpr(const GetExpr& from);
  GetExpr(GetExpr&& from) noexcept
    : GetExpr() {
    *this = ::std::move(from);
  }

  inline GetExpr& operator=(const GetExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetExpr& operator=(GetExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetExpr* internal_default_instance() {
    return reinterpret_cast<const GetExpr*>(
               &_GetExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetExpr& a, GetExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(GetExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetExpr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.GetExpr";
  }
  protected:
  explicit GetExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::PolarXRPC::ExecPlan::KeyExpr* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::KeyExpr >*
      mutable_keys();
  private:
  const ::PolarXRPC::ExecPlan::KeyExpr& _internal_keys(int index) const;
  ::PolarXRPC::ExecPlan::KeyExpr* _internal_add_keys();
  public:
  const ::PolarXRPC::ExecPlan::KeyExpr& keys(int index) const;
  ::PolarXRPC::ExecPlan::KeyExpr* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::KeyExpr >&
      keys() const;

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.GetExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::KeyExpr > keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class GetPlan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.GetPlan) */ {
 public:
  inline GetPlan() : GetPlan(nullptr) {}
  ~GetPlan() override;
  explicit constexpr GetPlan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPlan(const GetPlan& from);
  GetPlan(GetPlan&& from) noexcept
    : GetPlan() {
    *this = ::std::move(from);
  }

  inline GetPlan& operator=(const GetPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlan& operator=(GetPlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlan* internal_default_instance() {
    return reinterpret_cast<const GetPlan*>(
               &_GetPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetPlan& a, GetPlan& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPlan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPlan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPlan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.GetPlan";
  }
  protected:
  explicit GetPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 3,
    kTableInfoFieldNumber = 1,
    kIndexInfoFieldNumber = 2,
  };
  // repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::PolarXRPC::ExecPlan::GetExpr* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::GetExpr >*
      mutable_keys();
  private:
  const ::PolarXRPC::ExecPlan::GetExpr& _internal_keys(int index) const;
  ::PolarXRPC::ExecPlan::GetExpr* _internal_add_keys();
  public:
  const ::PolarXRPC::ExecPlan::GetExpr& keys(int index) const;
  ::PolarXRPC::ExecPlan::GetExpr* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::GetExpr >&
      keys() const;

  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const ::PolarXRPC::ExecPlan::TableInfo& table_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::TableInfo* release_table_info();
  ::PolarXRPC::ExecPlan::TableInfo* mutable_table_info();
  void set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info);
  private:
  const ::PolarXRPC::ExecPlan::TableInfo& _internal_table_info() const;
  ::PolarXRPC::ExecPlan::TableInfo* _internal_mutable_table_info();
  public:
  void unsafe_arena_set_allocated_table_info(
      ::PolarXRPC::ExecPlan::TableInfo* table_info);
  ::PolarXRPC::ExecPlan::TableInfo* unsafe_arena_release_table_info();

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  bool has_index_info() const;
  private:
  bool _internal_has_index_info() const;
  public:
  void clear_index_info();
  const ::PolarXRPC::ExecPlan::IndexInfo& index_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::IndexInfo* release_index_info();
  ::PolarXRPC::ExecPlan::IndexInfo* mutable_index_info();
  void set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info);
  private:
  const ::PolarXRPC::ExecPlan::IndexInfo& _internal_index_info() const;
  ::PolarXRPC::ExecPlan::IndexInfo* _internal_mutable_index_info();
  public:
  void unsafe_arena_set_allocated_index_info(
      ::PolarXRPC::ExecPlan::IndexInfo* index_info);
  ::PolarXRPC::ExecPlan::IndexInfo* unsafe_arena_release_index_info();

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.GetPlan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::GetExpr > keys_;
  ::PolarXRPC::ExecPlan::TableInfo* table_info_;
  ::PolarXRPC::ExecPlan::IndexInfo* index_info_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class TableScanPlan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.TableScanPlan) */ {
 public:
  inline TableScanPlan() : TableScanPlan(nullptr) {}
  ~TableScanPlan() override;
  explicit constexpr TableScanPlan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableScanPlan(const TableScanPlan& from);
  TableScanPlan(TableScanPlan&& from) noexcept
    : TableScanPlan() {
    *this = ::std::move(from);
  }

  inline TableScanPlan& operator=(const TableScanPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableScanPlan& operator=(TableScanPlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableScanPlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableScanPlan* internal_default_instance() {
    return reinterpret_cast<const TableScanPlan*>(
               &_TableScanPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TableScanPlan& a, TableScanPlan& b) {
    a.Swap(&b);
  }
  inline void Swap(TableScanPlan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableScanPlan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableScanPlan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableScanPlan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableScanPlan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableScanPlan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableScanPlan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.TableScanPlan";
  }
  protected:
  explicit TableScanPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableInfoFieldNumber = 1,
    kIndexInfoFieldNumber = 2,
    kReverseFieldNumber = 3,
  };
  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const ::PolarXRPC::ExecPlan::TableInfo& table_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::TableInfo* release_table_info();
  ::PolarXRPC::ExecPlan::TableInfo* mutable_table_info();
  void set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info);
  private:
  const ::PolarXRPC::ExecPlan::TableInfo& _internal_table_info() const;
  ::PolarXRPC::ExecPlan::TableInfo* _internal_mutable_table_info();
  public:
  void unsafe_arena_set_allocated_table_info(
      ::PolarXRPC::ExecPlan::TableInfo* table_info);
  ::PolarXRPC::ExecPlan::TableInfo* unsafe_arena_release_table_info();

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  bool has_index_info() const;
  private:
  bool _internal_has_index_info() const;
  public:
  void clear_index_info();
  const ::PolarXRPC::ExecPlan::IndexInfo& index_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::IndexInfo* release_index_info();
  ::PolarXRPC::ExecPlan::IndexInfo* mutable_index_info();
  void set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info);
  private:
  const ::PolarXRPC::ExecPlan::IndexInfo& _internal_index_info() const;
  ::PolarXRPC::ExecPlan::IndexInfo* _internal_mutable_index_info();
  public:
  void unsafe_arena_set_allocated_index_info(
      ::PolarXRPC::ExecPlan::IndexInfo* index_info);
  ::PolarXRPC::ExecPlan::IndexInfo* unsafe_arena_release_index_info();

  // optional bool reverse = 3;
  bool has_reverse() const;
  private:
  bool _internal_has_reverse() const;
  public:
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.TableScanPlan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::ExecPlan::TableInfo* table_info_;
  ::PolarXRPC::ExecPlan::IndexInfo* index_info_;
  bool reverse_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class KeyOnlyRangeScan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.KeyOnlyRangeScan) */ {
 public:
  inline KeyOnlyRangeScan() : KeyOnlyRangeScan(nullptr) {}
  ~KeyOnlyRangeScan() override;
  explicit constexpr KeyOnlyRangeScan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyOnlyRangeScan(const KeyOnlyRangeScan& from);
  KeyOnlyRangeScan(KeyOnlyRangeScan&& from) noexcept
    : KeyOnlyRangeScan() {
    *this = ::std::move(from);
  }

  inline KeyOnlyRangeScan& operator=(const KeyOnlyRangeScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyOnlyRangeScan& operator=(KeyOnlyRangeScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyOnlyRangeScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyOnlyRangeScan* internal_default_instance() {
    return reinterpret_cast<const KeyOnlyRangeScan*>(
               &_KeyOnlyRangeScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(KeyOnlyRangeScan& a, KeyOnlyRangeScan& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyOnlyRangeScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyOnlyRangeScan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyOnlyRangeScan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyOnlyRangeScan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyOnlyRangeScan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyOnlyRangeScan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyOnlyRangeScan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.KeyOnlyRangeScan";
  }
  protected:
  explicit KeyOnlyRangeScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
    kTableInfoFieldNumber = 3,
    kIndexInfoFieldNumber = 4,
    kKeyFieldNumber = 5,
    kEndKeyFieldNumber = 6,
    kReverseFieldNumber = 8,
    kFlagFieldNumber = 9,
  };
  // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::PolarXRPC::ExecPlan::Transaction& snapshot() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::Transaction* release_snapshot();
  ::PolarXRPC::ExecPlan::Transaction* mutable_snapshot();
  void set_allocated_snapshot(::PolarXRPC::ExecPlan::Transaction* snapshot);
  private:
  const ::PolarXRPC::ExecPlan::Transaction& _internal_snapshot() const;
  ::PolarXRPC::ExecPlan::Transaction* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::PolarXRPC::ExecPlan::Transaction* snapshot);
  ::PolarXRPC::ExecPlan::Transaction* unsafe_arena_release_snapshot();

  // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const ::PolarXRPC::ExecPlan::TableInfo& table_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::TableInfo* release_table_info();
  ::PolarXRPC::ExecPlan::TableInfo* mutable_table_info();
  void set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info);
  private:
  const ::PolarXRPC::ExecPlan::TableInfo& _internal_table_info() const;
  ::PolarXRPC::ExecPlan::TableInfo* _internal_mutable_table_info();
  public:
  void unsafe_arena_set_allocated_table_info(
      ::PolarXRPC::ExecPlan::TableInfo* table_info);
  ::PolarXRPC::ExecPlan::TableInfo* unsafe_arena_release_table_info();

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
  bool has_index_info() const;
  private:
  bool _internal_has_index_info() const;
  public:
  void clear_index_info();
  const ::PolarXRPC::ExecPlan::IndexInfo& index_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::IndexInfo* release_index_info();
  ::PolarXRPC::ExecPlan::IndexInfo* mutable_index_info();
  void set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info);
  private:
  const ::PolarXRPC::ExecPlan::IndexInfo& _internal_index_info() const;
  ::PolarXRPC::ExecPlan::IndexInfo* _internal_mutable_index_info();
  public:
  void unsafe_arena_set_allocated_index_info(
      ::PolarXRPC::ExecPlan::IndexInfo* index_info);
  ::PolarXRPC::ExecPlan::IndexInfo* unsafe_arena_release_index_info();

  // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::PolarXRPC::ExecPlan::GetExpr& key() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::GetExpr* release_key();
  ::PolarXRPC::ExecPlan::GetExpr* mutable_key();
  void set_allocated_key(::PolarXRPC::ExecPlan::GetExpr* key);
  private:
  const ::PolarXRPC::ExecPlan::GetExpr& _internal_key() const;
  ::PolarXRPC::ExecPlan::GetExpr* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::PolarXRPC::ExecPlan::GetExpr* key);
  ::PolarXRPC::ExecPlan::GetExpr* unsafe_arena_release_key();

  // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const ::PolarXRPC::ExecPlan::GetExpr& end_key() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::GetExpr* release_end_key();
  ::PolarXRPC::ExecPlan::GetExpr* mutable_end_key();
  void set_allocated_end_key(::PolarXRPC::ExecPlan::GetExpr* end_key);
  private:
  const ::PolarXRPC::ExecPlan::GetExpr& _internal_end_key() const;
  ::PolarXRPC::ExecPlan::GetExpr* _internal_mutable_end_key();
  public:
  void unsafe_arena_set_allocated_end_key(
      ::PolarXRPC::ExecPlan::GetExpr* end_key);
  ::PolarXRPC::ExecPlan::GetExpr* unsafe_arena_release_end_key();

  // optional bool reverse = 8;
  bool has_reverse() const;
  private:
  bool _internal_has_reverse() const;
  public:
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // optional int64 flag = 9;
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  int64_t flag() const;
  void set_flag(int64_t value);
  private:
  int64_t _internal_flag() const;
  void _internal_set_flag(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::ExecPlan::Transaction* snapshot_;
  ::PolarXRPC::ExecPlan::TableInfo* table_info_;
  ::PolarXRPC::ExecPlan::IndexInfo* index_info_;
  ::PolarXRPC::ExecPlan::GetExpr* key_;
  ::PolarXRPC::ExecPlan::GetExpr* end_key_;
  bool reverse_;
  int64_t flag_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class RangeScan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.RangeScan) */ {
 public:
  inline RangeScan() : RangeScan(nullptr) {}
  ~RangeScan() override;
  explicit constexpr RangeScan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeScan(const RangeScan& from);
  RangeScan(RangeScan&& from) noexcept
    : RangeScan() {
    *this = ::std::move(from);
  }

  inline RangeScan& operator=(const RangeScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeScan& operator=(RangeScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeScan* internal_default_instance() {
    return reinterpret_cast<const RangeScan*>(
               &_RangeScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RangeScan& a, RangeScan& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeScan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeScan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeScan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeScan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RangeScan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeScan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.RangeScan";
  }
  protected:
  explicit RangeScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
    kTableInfoFieldNumber = 3,
    kIndexInfoFieldNumber = 4,
    kKeyFieldNumber = 5,
    kEndKeyFieldNumber = 6,
    kReverseFieldNumber = 8,
    kFlagFieldNumber = 9,
  };
  // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::PolarXRPC::ExecPlan::Transaction& snapshot() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::Transaction* release_snapshot();
  ::PolarXRPC::ExecPlan::Transaction* mutable_snapshot();
  void set_allocated_snapshot(::PolarXRPC::ExecPlan::Transaction* snapshot);
  private:
  const ::PolarXRPC::ExecPlan::Transaction& _internal_snapshot() const;
  ::PolarXRPC::ExecPlan::Transaction* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::PolarXRPC::ExecPlan::Transaction* snapshot);
  ::PolarXRPC::ExecPlan::Transaction* unsafe_arena_release_snapshot();

  // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const ::PolarXRPC::ExecPlan::TableInfo& table_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::TableInfo* release_table_info();
  ::PolarXRPC::ExecPlan::TableInfo* mutable_table_info();
  void set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info);
  private:
  const ::PolarXRPC::ExecPlan::TableInfo& _internal_table_info() const;
  ::PolarXRPC::ExecPlan::TableInfo* _internal_mutable_table_info();
  public:
  void unsafe_arena_set_allocated_table_info(
      ::PolarXRPC::ExecPlan::TableInfo* table_info);
  ::PolarXRPC::ExecPlan::TableInfo* unsafe_arena_release_table_info();

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
  bool has_index_info() const;
  private:
  bool _internal_has_index_info() const;
  public:
  void clear_index_info();
  const ::PolarXRPC::ExecPlan::IndexInfo& index_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::IndexInfo* release_index_info();
  ::PolarXRPC::ExecPlan::IndexInfo* mutable_index_info();
  void set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info);
  private:
  const ::PolarXRPC::ExecPlan::IndexInfo& _internal_index_info() const;
  ::PolarXRPC::ExecPlan::IndexInfo* _internal_mutable_index_info();
  public:
  void unsafe_arena_set_allocated_index_info(
      ::PolarXRPC::ExecPlan::IndexInfo* index_info);
  ::PolarXRPC::ExecPlan::IndexInfo* unsafe_arena_release_index_info();

  // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::PolarXRPC::ExecPlan::GetExpr& key() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::GetExpr* release_key();
  ::PolarXRPC::ExecPlan::GetExpr* mutable_key();
  void set_allocated_key(::PolarXRPC::ExecPlan::GetExpr* key);
  private:
  const ::PolarXRPC::ExecPlan::GetExpr& _internal_key() const;
  ::PolarXRPC::ExecPlan::GetExpr* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::PolarXRPC::ExecPlan::GetExpr* key);
  ::PolarXRPC::ExecPlan::GetExpr* unsafe_arena_release_key();

  // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const ::PolarXRPC::ExecPlan::GetExpr& end_key() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::GetExpr* release_end_key();
  ::PolarXRPC::ExecPlan::GetExpr* mutable_end_key();
  void set_allocated_end_key(::PolarXRPC::ExecPlan::GetExpr* end_key);
  private:
  const ::PolarXRPC::ExecPlan::GetExpr& _internal_end_key() const;
  ::PolarXRPC::ExecPlan::GetExpr* _internal_mutable_end_key();
  public:
  void unsafe_arena_set_allocated_end_key(
      ::PolarXRPC::ExecPlan::GetExpr* end_key);
  ::PolarXRPC::ExecPlan::GetExpr* unsafe_arena_release_end_key();

  // optional bool reverse = 8;
  bool has_reverse() const;
  private:
  bool _internal_has_reverse() const;
  public:
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // optional int64 flag = 9;
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  int64_t flag() const;
  void set_flag(int64_t value);
  private:
  int64_t _internal_flag() const;
  void _internal_set_flag(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.RangeScan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::ExecPlan::Transaction* snapshot_;
  ::PolarXRPC::ExecPlan::TableInfo* table_info_;
  ::PolarXRPC::ExecPlan::IndexInfo* index_info_;
  ::PolarXRPC::ExecPlan::GetExpr* key_;
  ::PolarXRPC::ExecPlan::GetExpr* end_key_;
  bool reverse_;
  int64_t flag_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class TableProject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.TableProject) */ {
 public:
  inline TableProject() : TableProject(nullptr) {}
  ~TableProject() override;
  explicit constexpr TableProject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableProject(const TableProject& from);
  TableProject(TableProject&& from) noexcept
    : TableProject() {
    *this = ::std::move(from);
  }

  inline TableProject& operator=(const TableProject& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableProject& operator=(TableProject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableProject& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableProject* internal_default_instance() {
    return reinterpret_cast<const TableProject*>(
               &_TableProject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TableProject& a, TableProject& b) {
    a.Swap(&b);
  }
  inline void Swap(TableProject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableProject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableProject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableProject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableProject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableProject& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableProject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.TableProject";
  }
  protected:
  explicit TableProject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kSubReadPlanFieldNumber = 1,
  };
  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::PolarXRPC::Datatypes::Scalar* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >*
      mutable_fields();
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_fields(int index) const;
  ::PolarXRPC::Datatypes::Scalar* _internal_add_fields();
  public:
  const ::PolarXRPC::Datatypes::Scalar& fields(int index) const;
  ::PolarXRPC::Datatypes::Scalar* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >&
      fields() const;

  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  bool has_sub_read_plan() const;
  private:
  bool _internal_has_sub_read_plan() const;
  public:
  void clear_sub_read_plan();
  const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::AnyPlan* release_sub_read_plan();
  ::PolarXRPC::ExecPlan::AnyPlan* mutable_sub_read_plan();
  void set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  private:
  const ::PolarXRPC::ExecPlan::AnyPlan& _internal_sub_read_plan() const;
  ::PolarXRPC::ExecPlan::AnyPlan* _internal_mutable_sub_read_plan();
  public:
  void unsafe_arena_set_allocated_sub_read_plan(
      ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  ::PolarXRPC::ExecPlan::AnyPlan* unsafe_arena_release_sub_read_plan();

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.TableProject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar > fields_;
  ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class Project final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.Project) */ {
 public:
  inline Project() : Project(nullptr) {}
  ~Project() override;
  explicit constexpr Project(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Project(const Project& from);
  Project(Project&& from) noexcept
    : Project() {
    *this = ::std::move(from);
  }

  inline Project& operator=(const Project& from) {
    CopyFrom(from);
    return *this;
  }
  inline Project& operator=(Project&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Project& default_instance() {
    return *internal_default_instance();
  }
  static inline const Project* internal_default_instance() {
    return reinterpret_cast<const Project*>(
               &_Project_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Project& a, Project& b) {
    a.Swap(&b);
  }
  inline void Swap(Project* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Project* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Project* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Project>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Project& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Project& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Project* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.Project";
  }
  protected:
  explicit Project(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kExprsFieldNumber = 3,
    kSubReadPlanFieldNumber = 1,
  };
  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::PolarXRPC::Datatypes::Scalar* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >*
      mutable_fields();
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_fields(int index) const;
  ::PolarXRPC::Datatypes::Scalar* _internal_add_fields();
  public:
  const ::PolarXRPC::Datatypes::Scalar& fields(int index) const;
  ::PolarXRPC::Datatypes::Scalar* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >&
      fields() const;

  // repeated .PolarXRPC.Expr.Expr exprs = 3;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;
  public:
  void clear_exprs();
  ::PolarXRPC::Expr::Expr* mutable_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
      mutable_exprs();
  private:
  const ::PolarXRPC::Expr::Expr& _internal_exprs(int index) const;
  ::PolarXRPC::Expr::Expr* _internal_add_exprs();
  public:
  const ::PolarXRPC::Expr::Expr& exprs(int index) const;
  ::PolarXRPC::Expr::Expr* add_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
      exprs() const;

  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  bool has_sub_read_plan() const;
  private:
  bool _internal_has_sub_read_plan() const;
  public:
  void clear_sub_read_plan();
  const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::AnyPlan* release_sub_read_plan();
  ::PolarXRPC::ExecPlan::AnyPlan* mutable_sub_read_plan();
  void set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  private:
  const ::PolarXRPC::ExecPlan::AnyPlan& _internal_sub_read_plan() const;
  ::PolarXRPC::ExecPlan::AnyPlan* _internal_mutable_sub_read_plan();
  public:
  void unsafe_arena_set_allocated_sub_read_plan(
      ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  ::PolarXRPC::ExecPlan::AnyPlan* unsafe_arena_release_sub_read_plan();

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.Project)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar > fields_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr > exprs_;
  ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class Filter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  explicit constexpr Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Filter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.Filter";
  }
  protected:
  explicit Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubReadPlanFieldNumber = 1,
    kExprFieldNumber = 2,
  };
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  bool has_sub_read_plan() const;
  private:
  bool _internal_has_sub_read_plan() const;
  public:
  void clear_sub_read_plan();
  const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::AnyPlan* release_sub_read_plan();
  ::PolarXRPC::ExecPlan::AnyPlan* mutable_sub_read_plan();
  void set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  private:
  const ::PolarXRPC::ExecPlan::AnyPlan& _internal_sub_read_plan() const;
  ::PolarXRPC::ExecPlan::AnyPlan* _internal_mutable_sub_read_plan();
  public:
  void unsafe_arena_set_allocated_sub_read_plan(
      ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  ::PolarXRPC::ExecPlan::AnyPlan* unsafe_arena_release_sub_read_plan();

  // required .PolarXRPC.Expr.Expr expr = 2;
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;
  public:
  void clear_expr();
  const ::PolarXRPC::Expr::Expr& expr() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::Expr* release_expr();
  ::PolarXRPC::Expr::Expr* mutable_expr();
  void set_allocated_expr(::PolarXRPC::Expr::Expr* expr);
  private:
  const ::PolarXRPC::Expr::Expr& _internal_expr() const;
  ::PolarXRPC::Expr::Expr* _internal_mutable_expr();
  public:
  void unsafe_arena_set_allocated_expr(
      ::PolarXRPC::Expr::Expr* expr);
  ::PolarXRPC::Expr::Expr* unsafe_arena_release_expr();

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.Filter)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan_;
  ::PolarXRPC::Expr::Expr* expr_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class Aggr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.Aggr) */ {
 public:
  inline Aggr() : Aggr(nullptr) {}
  ~Aggr() override;
  explicit constexpr Aggr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aggr(const Aggr& from);
  Aggr(Aggr&& from) noexcept
    : Aggr() {
    *this = ::std::move(from);
  }

  inline Aggr& operator=(const Aggr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggr& operator=(Aggr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggr& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggr* internal_default_instance() {
    return reinterpret_cast<const Aggr*>(
               &_Aggr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Aggr& a, Aggr& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aggr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Aggr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aggr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.Aggr";
  }
  protected:
  explicit Aggr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Aggr_AggrType AggrType;
  static constexpr AggrType COUNT_FUNC =
    Aggr_AggrType_COUNT_FUNC;
  static constexpr AggrType COUNT_DISTINCT_FUNC =
    Aggr_AggrType_COUNT_DISTINCT_FUNC;
  static constexpr AggrType SUM_FUNC =
    Aggr_AggrType_SUM_FUNC;
  static constexpr AggrType SUM_DISTINCT_FUNC =
    Aggr_AggrType_SUM_DISTINCT_FUNC;
  static constexpr AggrType AVG_FUNC =
    Aggr_AggrType_AVG_FUNC;
  static constexpr AggrType AVG_DISTINCT_FUNC =
    Aggr_AggrType_AVG_DISTINCT_FUNC;
  static constexpr AggrType MIN_FUNC =
    Aggr_AggrType_MIN_FUNC;
  static constexpr AggrType MAX_FUNC =
    Aggr_AggrType_MAX_FUNC;
  static inline bool AggrType_IsValid(int value) {
    return Aggr_AggrType_IsValid(value);
  }
  static constexpr AggrType AggrType_MIN =
    Aggr_AggrType_AggrType_MIN;
  static constexpr AggrType AggrType_MAX =
    Aggr_AggrType_AggrType_MAX;
  static constexpr int AggrType_ARRAYSIZE =
    Aggr_AggrType_AggrType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AggrType_descriptor() {
    return Aggr_AggrType_descriptor();
  }
  template<typename T>
  static inline const std::string& AggrType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AggrType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AggrType_Name.");
    return Aggr_AggrType_Name(enum_t_value);
  }
  static inline bool AggrType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AggrType* value) {
    return Aggr_AggrType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubReadPlanFieldNumber = 1,
    kFieldFieldNumber = 3,
    kExprFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  bool has_sub_read_plan() const;
  private:
  bool _internal_has_sub_read_plan() const;
  public:
  void clear_sub_read_plan();
  const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::AnyPlan* release_sub_read_plan();
  ::PolarXRPC::ExecPlan::AnyPlan* mutable_sub_read_plan();
  void set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  private:
  const ::PolarXRPC::ExecPlan::AnyPlan& _internal_sub_read_plan() const;
  ::PolarXRPC::ExecPlan::AnyPlan* _internal_mutable_sub_read_plan();
  public:
  void unsafe_arena_set_allocated_sub_read_plan(
      ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan);
  ::PolarXRPC::ExecPlan::AnyPlan* unsafe_arena_release_sub_read_plan();

  // required .PolarXRPC.Datatypes.Scalar field = 3;
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  const ::PolarXRPC::Datatypes::Scalar& field() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Datatypes::Scalar* release_field();
  ::PolarXRPC::Datatypes::Scalar* mutable_field();
  void set_allocated_field(::PolarXRPC::Datatypes::Scalar* field);
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_field() const;
  ::PolarXRPC::Datatypes::Scalar* _internal_mutable_field();
  public:
  void unsafe_arena_set_allocated_field(
      ::PolarXRPC::Datatypes::Scalar* field);
  ::PolarXRPC::Datatypes::Scalar* unsafe_arena_release_field();

  // required .PolarXRPC.Expr.Expr expr = 4;
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;
  public:
  void clear_expr();
  const ::PolarXRPC::Expr::Expr& expr() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::Expr* release_expr();
  ::PolarXRPC::Expr::Expr* mutable_expr();
  void set_allocated_expr(::PolarXRPC::Expr::Expr* expr);
  private:
  const ::PolarXRPC::Expr::Expr& _internal_expr() const;
  ::PolarXRPC::Expr::Expr* _internal_mutable_expr();
  public:
  void unsafe_arena_set_allocated_expr(
      ::PolarXRPC::Expr::Expr* expr);
  ::PolarXRPC::Expr::Expr* unsafe_arena_release_expr();

  // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PolarXRPC::ExecPlan::Aggr_AggrType type() const;
  void set_type(::PolarXRPC::ExecPlan::Aggr_AggrType value);
  private:
  ::PolarXRPC::ExecPlan::Aggr_AggrType _internal_type() const;
  void _internal_set_type(::PolarXRPC::ExecPlan::Aggr_AggrType value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.Aggr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan_;
  ::PolarXRPC::Datatypes::Scalar* field_;
  ::PolarXRPC::Expr::Expr* expr_;
  int type_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class AnyPlan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.AnyPlan) */ {
 public:
  inline AnyPlan() : AnyPlan(nullptr) {}
  ~AnyPlan() override;
  explicit constexpr AnyPlan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnyPlan(const AnyPlan& from);
  AnyPlan(AnyPlan&& from) noexcept
    : AnyPlan() {
    *this = ::std::move(from);
  }

  inline AnyPlan& operator=(const AnyPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyPlan& operator=(AnyPlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyPlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnyPlan* internal_default_instance() {
    return reinterpret_cast<const AnyPlan*>(
               &_AnyPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AnyPlan& a, AnyPlan& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyPlan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyPlan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnyPlan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnyPlan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnyPlan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnyPlan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyPlan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.AnyPlan";
  }
  protected:
  explicit AnyPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AnyPlan_PlanType PlanType;
  static constexpr PlanType GET =
    AnyPlan_PlanType_GET;
  static constexpr PlanType TABLE_SCAN =
    AnyPlan_PlanType_TABLE_SCAN;
  static constexpr PlanType TABLE_PROJECT =
    AnyPlan_PlanType_TABLE_PROJECT;
  static constexpr PlanType PROJECT =
    AnyPlan_PlanType_PROJECT;
  static constexpr PlanType FILTER =
    AnyPlan_PlanType_FILTER;
  static constexpr PlanType RANGE_SCAN =
    AnyPlan_PlanType_RANGE_SCAN;
  static constexpr PlanType AGGR =
    AnyPlan_PlanType_AGGR;
  static inline bool PlanType_IsValid(int value) {
    return AnyPlan_PlanType_IsValid(value);
  }
  static constexpr PlanType PlanType_MIN =
    AnyPlan_PlanType_PlanType_MIN;
  static constexpr PlanType PlanType_MAX =
    AnyPlan_PlanType_PlanType_MAX;
  static constexpr int PlanType_ARRAYSIZE =
    AnyPlan_PlanType_PlanType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PlanType_descriptor() {
    return AnyPlan_PlanType_descriptor();
  }
  template<typename T>
  static inline const std::string& PlanType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlanType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlanType_Name.");
    return AnyPlan_PlanType_Name(enum_t_value);
  }
  static inline bool PlanType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlanType* value) {
    return AnyPlan_PlanType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGetPlanFieldNumber = 2,
    kTableScanPlanFieldNumber = 3,
    kTableProjectFieldNumber = 4,
    kProjectFieldNumber = 5,
    kFilterFieldNumber = 6,
    kRangeScanFieldNumber = 8,
    kAggrFieldNumber = 9,
    kPlanTypeFieldNumber = 1,
  };
  // optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
  bool has_get_plan() const;
  private:
  bool _internal_has_get_plan() const;
  public:
  void clear_get_plan();
  const ::PolarXRPC::ExecPlan::GetPlan& get_plan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::GetPlan* release_get_plan();
  ::PolarXRPC::ExecPlan::GetPlan* mutable_get_plan();
  void set_allocated_get_plan(::PolarXRPC::ExecPlan::GetPlan* get_plan);
  private:
  const ::PolarXRPC::ExecPlan::GetPlan& _internal_get_plan() const;
  ::PolarXRPC::ExecPlan::GetPlan* _internal_mutable_get_plan();
  public:
  void unsafe_arena_set_allocated_get_plan(
      ::PolarXRPC::ExecPlan::GetPlan* get_plan);
  ::PolarXRPC::ExecPlan::GetPlan* unsafe_arena_release_get_plan();

  // optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
  bool has_table_scan_plan() const;
  private:
  bool _internal_has_table_scan_plan() const;
  public:
  void clear_table_scan_plan();
  const ::PolarXRPC::ExecPlan::TableScanPlan& table_scan_plan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::TableScanPlan* release_table_scan_plan();
  ::PolarXRPC::ExecPlan::TableScanPlan* mutable_table_scan_plan();
  void set_allocated_table_scan_plan(::PolarXRPC::ExecPlan::TableScanPlan* table_scan_plan);
  private:
  const ::PolarXRPC::ExecPlan::TableScanPlan& _internal_table_scan_plan() const;
  ::PolarXRPC::ExecPlan::TableScanPlan* _internal_mutable_table_scan_plan();
  public:
  void unsafe_arena_set_allocated_table_scan_plan(
      ::PolarXRPC::ExecPlan::TableScanPlan* table_scan_plan);
  ::PolarXRPC::ExecPlan::TableScanPlan* unsafe_arena_release_table_scan_plan();

  // optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
  bool has_table_project() const;
  private:
  bool _internal_has_table_project() const;
  public:
  void clear_table_project();
  const ::PolarXRPC::ExecPlan::TableProject& table_project() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::TableProject* release_table_project();
  ::PolarXRPC::ExecPlan::TableProject* mutable_table_project();
  void set_allocated_table_project(::PolarXRPC::ExecPlan::TableProject* table_project);
  private:
  const ::PolarXRPC::ExecPlan::TableProject& _internal_table_project() const;
  ::PolarXRPC::ExecPlan::TableProject* _internal_mutable_table_project();
  public:
  void unsafe_arena_set_allocated_table_project(
      ::PolarXRPC::ExecPlan::TableProject* table_project);
  ::PolarXRPC::ExecPlan::TableProject* unsafe_arena_release_table_project();

  // optional .PolarXRPC.ExecPlan.Project project = 5;
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const ::PolarXRPC::ExecPlan::Project& project() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::Project* release_project();
  ::PolarXRPC::ExecPlan::Project* mutable_project();
  void set_allocated_project(::PolarXRPC::ExecPlan::Project* project);
  private:
  const ::PolarXRPC::ExecPlan::Project& _internal_project() const;
  ::PolarXRPC::ExecPlan::Project* _internal_mutable_project();
  public:
  void unsafe_arena_set_allocated_project(
      ::PolarXRPC::ExecPlan::Project* project);
  ::PolarXRPC::ExecPlan::Project* unsafe_arena_release_project();

  // optional .PolarXRPC.ExecPlan.Filter filter = 6;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::PolarXRPC::ExecPlan::Filter& filter() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::Filter* release_filter();
  ::PolarXRPC::ExecPlan::Filter* mutable_filter();
  void set_allocated_filter(::PolarXRPC::ExecPlan::Filter* filter);
  private:
  const ::PolarXRPC::ExecPlan::Filter& _internal_filter() const;
  ::PolarXRPC::ExecPlan::Filter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::PolarXRPC::ExecPlan::Filter* filter);
  ::PolarXRPC::ExecPlan::Filter* unsafe_arena_release_filter();

  // optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
  bool has_range_scan() const;
  private:
  bool _internal_has_range_scan() const;
  public:
  void clear_range_scan();
  const ::PolarXRPC::ExecPlan::RangeScan& range_scan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::RangeScan* release_range_scan();
  ::PolarXRPC::ExecPlan::RangeScan* mutable_range_scan();
  void set_allocated_range_scan(::PolarXRPC::ExecPlan::RangeScan* range_scan);
  private:
  const ::PolarXRPC::ExecPlan::RangeScan& _internal_range_scan() const;
  ::PolarXRPC::ExecPlan::RangeScan* _internal_mutable_range_scan();
  public:
  void unsafe_arena_set_allocated_range_scan(
      ::PolarXRPC::ExecPlan::RangeScan* range_scan);
  ::PolarXRPC::ExecPlan::RangeScan* unsafe_arena_release_range_scan();

  // optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
  bool has_aggr() const;
  private:
  bool _internal_has_aggr() const;
  public:
  void clear_aggr();
  const ::PolarXRPC::ExecPlan::Aggr& aggr() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::Aggr* release_aggr();
  ::PolarXRPC::ExecPlan::Aggr* mutable_aggr();
  void set_allocated_aggr(::PolarXRPC::ExecPlan::Aggr* aggr);
  private:
  const ::PolarXRPC::ExecPlan::Aggr& _internal_aggr() const;
  ::PolarXRPC::ExecPlan::Aggr* _internal_mutable_aggr();
  public:
  void unsafe_arena_set_allocated_aggr(
      ::PolarXRPC::ExecPlan::Aggr* aggr);
  ::PolarXRPC::ExecPlan::Aggr* unsafe_arena_release_aggr();

  // required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
  bool has_plan_type() const;
  private:
  bool _internal_has_plan_type() const;
  public:
  void clear_plan_type();
  ::PolarXRPC::ExecPlan::AnyPlan_PlanType plan_type() const;
  void set_plan_type(::PolarXRPC::ExecPlan::AnyPlan_PlanType value);
  private:
  ::PolarXRPC::ExecPlan::AnyPlan_PlanType _internal_plan_type() const;
  void _internal_set_plan_type(::PolarXRPC::ExecPlan::AnyPlan_PlanType value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.AnyPlan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::ExecPlan::GetPlan* get_plan_;
  ::PolarXRPC::ExecPlan::TableScanPlan* table_scan_plan_;
  ::PolarXRPC::ExecPlan::TableProject* table_project_;
  ::PolarXRPC::ExecPlan::Project* project_;
  ::PolarXRPC::ExecPlan::Filter* filter_;
  ::PolarXRPC::ExecPlan::RangeScan* range_scan_;
  ::PolarXRPC::ExecPlan::Aggr* aggr_;
  int plan_type_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// -------------------------------------------------------------------

class ExecPlan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.ExecPlan.ExecPlan) */ {
 public:
  inline ExecPlan() : ExecPlan(nullptr) {}
  ~ExecPlan() override;
  explicit constexpr ExecPlan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecPlan(const ExecPlan& from);
  ExecPlan(ExecPlan&& from) noexcept
    : ExecPlan() {
    *this = ::std::move(from);
  }

  inline ExecPlan& operator=(const ExecPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecPlan& operator=(ExecPlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecPlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecPlan* internal_default_instance() {
    return reinterpret_cast<const ExecPlan*>(
               &_ExecPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ExecPlan& a, ExecPlan& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecPlan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecPlan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecPlan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecPlan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecPlan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecPlan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecPlan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.ExecPlan.ExecPlan";
  }
  protected:
  explicit ExecPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kSessionVariablesFieldNumber = 5,
    kPlanDigestFieldNumber = 3,
    kTraceIdFieldNumber = 14,
    kAuditStrFieldNumber = 15,
    kTransactionFieldNumber = 1,
    kPlanFieldNumber = 2,
    kTokenFieldNumber = 6,
    kResetErrorFieldNumber = 7,
    kCompactMetadataFieldNumber = 8,
    kUseCtsTransactionFieldNumber = 12,
    kChunkResultFieldNumber = 11,
    kSnapshotSeqFieldNumber = 9,
    kCommitSeqFieldNumber = 10,
    kCapabilitiesFieldNumber = 16,
    kFeedBackFieldNumber = 13,
    kMarkDistributedFieldNumber = 17,
    kQueryViaFlashbackAreaFieldNumber = 18,
  };
  // repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::PolarXRPC::Datatypes::Scalar* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >*
      mutable_parameters();
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_parameters(int index) const;
  ::PolarXRPC::Datatypes::Scalar* _internal_add_parameters();
  public:
  const ::PolarXRPC::Datatypes::Scalar& parameters(int index) const;
  ::PolarXRPC::Datatypes::Scalar* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >&
      parameters() const;

  // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
  int session_variables_size() const;
  private:
  int _internal_session_variables_size() const;
  public:
  void clear_session_variables();
  ::PolarXRPC::Datatypes::SessionVariable* mutable_session_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >*
      mutable_session_variables();
  private:
  const ::PolarXRPC::Datatypes::SessionVariable& _internal_session_variables(int index) const;
  ::PolarXRPC::Datatypes::SessionVariable* _internal_add_session_variables();
  public:
  const ::PolarXRPC::Datatypes::SessionVariable& session_variables(int index) const;
  ::PolarXRPC::Datatypes::SessionVariable* add_session_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >&
      session_variables() const;

  // optional bytes plan_digest = 3;
  bool has_plan_digest() const;
  private:
  bool _internal_has_plan_digest() const;
  public:
  void clear_plan_digest();
  const std::string& plan_digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plan_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plan_digest();
  PROTOBUF_NODISCARD std::string* release_plan_digest();
  void set_allocated_plan_digest(std::string* plan_digest);
  private:
  const std::string& _internal_plan_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan_digest(const std::string& value);
  std::string* _internal_mutable_plan_digest();
  public:

  // optional bytes trace_id = 14;
  bool has_trace_id() const;
  private:
  bool _internal_has_trace_id() const;
  public:
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // optional bytes audit_str = 15;
  bool has_audit_str() const;
  private:
  bool _internal_has_audit_str() const;
  public:
  void clear_audit_str();
  const std::string& audit_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audit_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audit_str();
  PROTOBUF_NODISCARD std::string* release_audit_str();
  void set_allocated_audit_str(std::string* audit_str);
  private:
  const std::string& _internal_audit_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audit_str(const std::string& value);
  std::string* _internal_mutable_audit_str();
  public:

  // optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::PolarXRPC::ExecPlan::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::Transaction* release_transaction();
  ::PolarXRPC::ExecPlan::Transaction* mutable_transaction();
  void set_allocated_transaction(::PolarXRPC::ExecPlan::Transaction* transaction);
  private:
  const ::PolarXRPC::ExecPlan::Transaction& _internal_transaction() const;
  ::PolarXRPC::ExecPlan::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::PolarXRPC::ExecPlan::Transaction* transaction);
  ::PolarXRPC::ExecPlan::Transaction* unsafe_arena_release_transaction();

  // optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
  bool has_plan() const;
  private:
  bool _internal_has_plan() const;
  public:
  void clear_plan();
  const ::PolarXRPC::ExecPlan::AnyPlan& plan() const;
  PROTOBUF_NODISCARD ::PolarXRPC::ExecPlan::AnyPlan* release_plan();
  ::PolarXRPC::ExecPlan::AnyPlan* mutable_plan();
  void set_allocated_plan(::PolarXRPC::ExecPlan::AnyPlan* plan);
  private:
  const ::PolarXRPC::ExecPlan::AnyPlan& _internal_plan() const;
  ::PolarXRPC::ExecPlan::AnyPlan* _internal_mutable_plan();
  public:
  void unsafe_arena_set_allocated_plan(
      ::PolarXRPC::ExecPlan::AnyPlan* plan);
  ::PolarXRPC::ExecPlan::AnyPlan* unsafe_arena_release_plan();

  // optional int32 token = 6;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  int32_t token() const;
  void set_token(int32_t value);
  private:
  int32_t _internal_token() const;
  void _internal_set_token(int32_t value);
  public:

  // optional bool reset_error = 7;
  bool has_reset_error() const;
  private:
  bool _internal_has_reset_error() const;
  public:
  void clear_reset_error();
  bool reset_error() const;
  void set_reset_error(bool value);
  private:
  bool _internal_reset_error() const;
  void _internal_set_reset_error(bool value);
  public:

  // optional bool compact_metadata = 8 [default = false];
  bool has_compact_metadata() const;
  private:
  bool _internal_has_compact_metadata() const;
  public:
  void clear_compact_metadata();
  bool compact_metadata() const;
  void set_compact_metadata(bool value);
  private:
  bool _internal_compact_metadata() const;
  void _internal_set_compact_metadata(bool value);
  public:

  // optional bool use_cts_transaction = 12;
  bool has_use_cts_transaction() const;
  private:
  bool _internal_has_use_cts_transaction() const;
  public:
  void clear_use_cts_transaction();
  bool use_cts_transaction() const;
  void set_use_cts_transaction(bool value);
  private:
  bool _internal_use_cts_transaction() const;
  void _internal_set_use_cts_transaction(bool value);
  public:

  // optional bool chunk_result = 11 [default = false];
  bool has_chunk_result() const;
  private:
  bool _internal_has_chunk_result() const;
  public:
  void clear_chunk_result();
  bool chunk_result() const;
  void set_chunk_result(bool value);
  private:
  bool _internal_chunk_result() const;
  void _internal_set_chunk_result(bool value);
  public:

  // optional uint64 snapshot_seq = 9;
  bool has_snapshot_seq() const;
  private:
  bool _internal_has_snapshot_seq() const;
  public:
  void clear_snapshot_seq();
  uint64_t snapshot_seq() const;
  void set_snapshot_seq(uint64_t value);
  private:
  uint64_t _internal_snapshot_seq() const;
  void _internal_set_snapshot_seq(uint64_t value);
  public:

  // optional uint64 commit_seq = 10;
  bool has_commit_seq() const;
  private:
  bool _internal_has_commit_seq() const;
  public:
  void clear_commit_seq();
  uint64_t commit_seq() const;
  void set_commit_seq(uint64_t value);
  private:
  uint64_t _internal_commit_seq() const;
  void _internal_set_commit_seq(uint64_t value);
  public:

  // optional uint64 capabilities = 16;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  uint64_t capabilities() const;
  void set_capabilities(uint64_t value);
  private:
  uint64_t _internal_capabilities() const;
  void _internal_set_capabilities(uint64_t value);
  public:

  // optional bool feed_back = 13 [default = false];
  bool has_feed_back() const;
  private:
  bool _internal_has_feed_back() const;
  public:
  void clear_feed_back();
  bool feed_back() const;
  void set_feed_back(bool value);
  private:
  bool _internal_feed_back() const;
  void _internal_set_feed_back(bool value);
  public:

  // optional bool mark_distributed = 17;
  bool has_mark_distributed() const;
  private:
  bool _internal_has_mark_distributed() const;
  public:
  void clear_mark_distributed();
  bool mark_distributed() const;
  void set_mark_distributed(bool value);
  private:
  bool _internal_mark_distributed() const;
  void _internal_set_mark_distributed(bool value);
  public:

  // optional bool query_via_flashback_area = 18;
  bool has_query_via_flashback_area() const;
  private:
  bool _internal_has_query_via_flashback_area() const;
  public:
  void clear_query_via_flashback_area();
  bool query_via_flashback_area() const;
  void set_query_via_flashback_area(bool value);
  private:
  bool _internal_query_via_flashback_area() const;
  void _internal_set_query_via_flashback_area(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.ExecPlan.ExecPlan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar > parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable > session_variables_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plan_digest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audit_str_;
  ::PolarXRPC::ExecPlan::Transaction* transaction_;
  ::PolarXRPC::ExecPlan::AnyPlan* plan_;
  int32_t token_;
  bool reset_error_;
  bool compact_metadata_;
  bool use_cts_transaction_;
  bool chunk_result_;
  uint64_t snapshot_seq_;
  uint64_t commit_seq_;
  uint64_t capabilities_;
  bool feed_back_;
  bool mark_distributed_;
  bool query_via_flashback_area_;
  friend struct ::TableStruct_polarx_5fexec_5fplan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NewSession

// -------------------------------------------------------------------

// CloseSession

// -------------------------------------------------------------------

// EnumSession

// -------------------------------------------------------------------

// SessionInfo

// -------------------------------------------------------------------

// SessionInfos

// repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
inline int SessionInfos::_internal_sessions_size() const {
  return sessions_.size();
}
inline int SessionInfos::sessions_size() const {
  return _internal_sessions_size();
}
inline void SessionInfos::clear_sessions() {
  sessions_.Clear();
}
inline ::PolarXRPC::ExecPlan::SessionInfo* SessionInfos::mutable_sessions(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.SessionInfos.sessions)
  return sessions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::SessionInfo >*
SessionInfos::mutable_sessions() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.SessionInfos.sessions)
  return &sessions_;
}
inline const ::PolarXRPC::ExecPlan::SessionInfo& SessionInfos::_internal_sessions(int index) const {
  return sessions_.Get(index);
}
inline const ::PolarXRPC::ExecPlan::SessionInfo& SessionInfos::sessions(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.SessionInfos.sessions)
  return _internal_sessions(index);
}
inline ::PolarXRPC::ExecPlan::SessionInfo* SessionInfos::_internal_add_sessions() {
  return sessions_.Add();
}
inline ::PolarXRPC::ExecPlan::SessionInfo* SessionInfos::add_sessions() {
  ::PolarXRPC::ExecPlan::SessionInfo* _add = _internal_add_sessions();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.SessionInfos.sessions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::SessionInfo >&
SessionInfos::sessions() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.SessionInfos.sessions)
  return sessions_;
}

// -------------------------------------------------------------------

// TableInfo

// optional int64 version = 1;
inline bool TableInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableInfo::has_version() const {
  return _internal_has_version();
}
inline void TableInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t TableInfo::_internal_version() const {
  return version_;
}
inline int64_t TableInfo::version() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableInfo.version)
  return _internal_version();
}
inline void TableInfo::_internal_set_version(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void TableInfo::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.TableInfo.version)
}

// required .PolarXRPC.Datatypes.Scalar name = 2;
inline bool TableInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || name_ != nullptr);
  return value;
}
inline bool TableInfo::has_name() const {
  return _internal_has_name();
}
inline const ::PolarXRPC::Datatypes::Scalar& TableInfo::_internal_name() const {
  const ::PolarXRPC::Datatypes::Scalar* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Datatypes::Scalar&>(
      ::PolarXRPC::Datatypes::_Scalar_default_instance_);
}
inline const ::PolarXRPC::Datatypes::Scalar& TableInfo::name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableInfo.name)
  return _internal_name();
}
inline void TableInfo::unsafe_arena_set_allocated_name(
    ::PolarXRPC::Datatypes::Scalar* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.TableInfo.name)
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::release_name() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Datatypes::Scalar* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.TableInfo.name)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Datatypes::Scalar* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Datatypes::Scalar>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::mutable_name() {
  ::PolarXRPC::Datatypes::Scalar* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.TableInfo.name)
  return _msg;
}
inline void TableInfo::set_allocated_name(::PolarXRPC::Datatypes::Scalar* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.TableInfo.name)
}

// optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
inline bool TableInfo::_internal_has_schema_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || schema_name_ != nullptr);
  return value;
}
inline bool TableInfo::has_schema_name() const {
  return _internal_has_schema_name();
}
inline const ::PolarXRPC::Datatypes::Scalar& TableInfo::_internal_schema_name() const {
  const ::PolarXRPC::Datatypes::Scalar* p = schema_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Datatypes::Scalar&>(
      ::PolarXRPC::Datatypes::_Scalar_default_instance_);
}
inline const ::PolarXRPC::Datatypes::Scalar& TableInfo::schema_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableInfo.schema_name)
  return _internal_schema_name();
}
inline void TableInfo::unsafe_arena_set_allocated_schema_name(
    ::PolarXRPC::Datatypes::Scalar* schema_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_name_);
  }
  schema_name_ = schema_name;
  if (schema_name) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.TableInfo.schema_name)
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::release_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Datatypes::Scalar* temp = schema_name_;
  schema_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::unsafe_arena_release_schema_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.TableInfo.schema_name)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Datatypes::Scalar* temp = schema_name_;
  schema_name_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::_internal_mutable_schema_name() {
  _has_bits_[0] |= 0x00000002u;
  if (schema_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Datatypes::Scalar>(GetArenaForAllocation());
    schema_name_ = p;
  }
  return schema_name_;
}
inline ::PolarXRPC::Datatypes::Scalar* TableInfo::mutable_schema_name() {
  ::PolarXRPC::Datatypes::Scalar* _msg = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.TableInfo.schema_name)
  return _msg;
}
inline void TableInfo::set_allocated_schema_name(::PolarXRPC::Datatypes::Scalar* schema_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_name_);
  }
  if (schema_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_name));
    if (message_arena != submessage_arena) {
      schema_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_name_ = schema_name;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.TableInfo.schema_name)
}

// -------------------------------------------------------------------

// IndexInfo

// required .PolarXRPC.Datatypes.Scalar name = 1;
inline bool IndexInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || name_ != nullptr);
  return value;
}
inline bool IndexInfo::has_name() const {
  return _internal_has_name();
}
inline const ::PolarXRPC::Datatypes::Scalar& IndexInfo::_internal_name() const {
  const ::PolarXRPC::Datatypes::Scalar* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Datatypes::Scalar&>(
      ::PolarXRPC::Datatypes::_Scalar_default_instance_);
}
inline const ::PolarXRPC::Datatypes::Scalar& IndexInfo::name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.IndexInfo.name)
  return _internal_name();
}
inline void IndexInfo::unsafe_arena_set_allocated_name(
    ::PolarXRPC::Datatypes::Scalar* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.IndexInfo.name)
}
inline ::PolarXRPC::Datatypes::Scalar* IndexInfo::release_name() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Datatypes::Scalar* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* IndexInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.IndexInfo.name)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Datatypes::Scalar* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* IndexInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Datatypes::Scalar>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::PolarXRPC::Datatypes::Scalar* IndexInfo::mutable_name() {
  ::PolarXRPC::Datatypes::Scalar* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.IndexInfo.name)
  return _msg;
}
inline void IndexInfo::set_allocated_name(::PolarXRPC::Datatypes::Scalar* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.IndexInfo.name)
}

// optional int32 use_parts = 2;
inline bool IndexInfo::_internal_has_use_parts() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndexInfo::has_use_parts() const {
  return _internal_has_use_parts();
}
inline void IndexInfo::clear_use_parts() {
  use_parts_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t IndexInfo::_internal_use_parts() const {
  return use_parts_;
}
inline int32_t IndexInfo::use_parts() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.IndexInfo.use_parts)
  return _internal_use_parts();
}
inline void IndexInfo::_internal_set_use_parts(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  use_parts_ = value;
}
inline void IndexInfo::set_use_parts(int32_t value) {
  _internal_set_use_parts(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.IndexInfo.use_parts)
}

// -------------------------------------------------------------------

// Transaction

// -------------------------------------------------------------------

// BloomFilter

// required uint32 total_bits = 1;
inline bool BloomFilter::_internal_has_total_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BloomFilter::has_total_bits() const {
  return _internal_has_total_bits();
}
inline void BloomFilter::clear_total_bits() {
  total_bits_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t BloomFilter::_internal_total_bits() const {
  return total_bits_;
}
inline uint32_t BloomFilter::total_bits() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.BloomFilter.total_bits)
  return _internal_total_bits();
}
inline void BloomFilter::_internal_set_total_bits(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  total_bits_ = value;
}
inline void BloomFilter::set_total_bits(uint32_t value) {
  _internal_set_total_bits(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.BloomFilter.total_bits)
}

// required uint32 number_hash = 2;
inline bool BloomFilter::_internal_has_number_hash() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BloomFilter::has_number_hash() const {
  return _internal_has_number_hash();
}
inline void BloomFilter::clear_number_hash() {
  number_hash_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t BloomFilter::_internal_number_hash() const {
  return number_hash_;
}
inline uint32_t BloomFilter::number_hash() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.BloomFilter.number_hash)
  return _internal_number_hash();
}
inline void BloomFilter::_internal_set_number_hash(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  number_hash_ = value;
}
inline void BloomFilter::set_number_hash(uint32_t value) {
  _internal_set_number_hash(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.BloomFilter.number_hash)
}

// required bytes strategy = 3;
inline bool BloomFilter::_internal_has_strategy() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BloomFilter::has_strategy() const {
  return _internal_has_strategy();
}
inline void BloomFilter::clear_strategy() {
  strategy_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BloomFilter::strategy() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.BloomFilter.strategy)
  return _internal_strategy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BloomFilter::set_strategy(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 strategy_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.BloomFilter.strategy)
}
inline std::string* BloomFilter::mutable_strategy() {
  std::string* _s = _internal_mutable_strategy();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.BloomFilter.strategy)
  return _s;
}
inline const std::string& BloomFilter::_internal_strategy() const {
  return strategy_.Get();
}
inline void BloomFilter::_internal_set_strategy(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  strategy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BloomFilter::_internal_mutable_strategy() {
  _has_bits_[0] |= 0x00000001u;
  return strategy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BloomFilter::release_strategy() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.BloomFilter.strategy)
  if (!_internal_has_strategy()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = strategy_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (strategy_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    strategy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BloomFilter::set_allocated_strategy(std::string* strategy) {
  if (strategy != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  strategy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), strategy,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (strategy_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    strategy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.BloomFilter.strategy)
}

// required bytes data = 4;
inline bool BloomFilter::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BloomFilter::has_data() const {
  return _internal_has_data();
}
inline void BloomFilter::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BloomFilter::data() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.BloomFilter.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BloomFilter::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.BloomFilter.data)
}
inline std::string* BloomFilter::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.BloomFilter.data)
  return _s;
}
inline const std::string& BloomFilter::_internal_data() const {
  return data_.Get();
}
inline void BloomFilter::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BloomFilter::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BloomFilter::release_data() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.BloomFilter.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BloomFilter::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.BloomFilter.data)
}

// -------------------------------------------------------------------

// GetTSO

// required bytes leader_name = 1;
inline bool GetTSO::_internal_has_leader_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetTSO::has_leader_name() const {
  return _internal_has_leader_name();
}
inline void GetTSO::clear_leader_name() {
  leader_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetTSO::leader_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.GetTSO.leader_name)
  return _internal_leader_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTSO::set_leader_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 leader_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.GetTSO.leader_name)
}
inline std::string* GetTSO::mutable_leader_name() {
  std::string* _s = _internal_mutable_leader_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.GetTSO.leader_name)
  return _s;
}
inline const std::string& GetTSO::_internal_leader_name() const {
  return leader_name_.Get();
}
inline void GetTSO::_internal_set_leader_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  leader_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTSO::_internal_mutable_leader_name() {
  _has_bits_[0] |= 0x00000001u;
  return leader_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTSO::release_leader_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.GetTSO.leader_name)
  if (!_internal_has_leader_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = leader_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (leader_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    leader_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetTSO::set_allocated_leader_name(std::string* leader_name) {
  if (leader_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  leader_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (leader_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    leader_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.GetTSO.leader_name)
}

// required int32 batch_count = 2;
inline bool GetTSO::_internal_has_batch_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetTSO::has_batch_count() const {
  return _internal_has_batch_count();
}
inline void GetTSO::clear_batch_count() {
  batch_count_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t GetTSO::_internal_batch_count() const {
  return batch_count_;
}
inline int32_t GetTSO::batch_count() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.GetTSO.batch_count)
  return _internal_batch_count();
}
inline void GetTSO::_internal_set_batch_count(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  batch_count_ = value;
}
inline void GetTSO::set_batch_count(int32_t value) {
  _internal_set_batch_count(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.GetTSO.batch_count)
}

// -------------------------------------------------------------------

// ResultTSO

// required int32 error_no = 1;
inline bool ResultTSO::_internal_has_error_no() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResultTSO::has_error_no() const {
  return _internal_has_error_no();
}
inline void ResultTSO::clear_error_no() {
  error_no_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ResultTSO::_internal_error_no() const {
  return error_no_;
}
inline int32_t ResultTSO::error_no() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ResultTSO.error_no)
  return _internal_error_no();
}
inline void ResultTSO::_internal_set_error_no(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  error_no_ = value;
}
inline void ResultTSO::set_error_no(int32_t value) {
  _internal_set_error_no(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ResultTSO.error_no)
}

// required uint64 ts = 2;
inline bool ResultTSO::_internal_has_ts() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResultTSO::has_ts() const {
  return _internal_has_ts();
}
inline void ResultTSO::clear_ts() {
  ts_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ResultTSO::_internal_ts() const {
  return ts_;
}
inline uint64_t ResultTSO::ts() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ResultTSO.ts)
  return _internal_ts();
}
inline void ResultTSO::_internal_set_ts(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  ts_ = value;
}
inline void ResultTSO::set_ts(uint64_t value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ResultTSO.ts)
}

// -------------------------------------------------------------------

// AutoSp

// required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
inline bool AutoSp::_internal_has_op() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutoSp::has_op() const {
  return _internal_has_op();
}
inline void AutoSp::clear_op() {
  op_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PolarXRPC::ExecPlan::AutoSp_Operation AutoSp::_internal_op() const {
  return static_cast< ::PolarXRPC::ExecPlan::AutoSp_Operation >(op_);
}
inline ::PolarXRPC::ExecPlan::AutoSp_Operation AutoSp::op() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AutoSp.op)
  return _internal_op();
}
inline void AutoSp::_internal_set_op(::PolarXRPC::ExecPlan::AutoSp_Operation value) {
  assert(::PolarXRPC::ExecPlan::AutoSp_Operation_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  op_ = value;
}
inline void AutoSp::set_op(::PolarXRPC::ExecPlan::AutoSp_Operation value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.AutoSp.op)
}

// required bytes sp_name = 2;
inline bool AutoSp::_internal_has_sp_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutoSp::has_sp_name() const {
  return _internal_has_sp_name();
}
inline void AutoSp::clear_sp_name() {
  sp_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutoSp::sp_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AutoSp.sp_name)
  return _internal_sp_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoSp::set_sp_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sp_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.AutoSp.sp_name)
}
inline std::string* AutoSp::mutable_sp_name() {
  std::string* _s = _internal_mutable_sp_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AutoSp.sp_name)
  return _s;
}
inline const std::string& AutoSp::_internal_sp_name() const {
  return sp_name_.Get();
}
inline void AutoSp::_internal_set_sp_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sp_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AutoSp::_internal_mutable_sp_name() {
  _has_bits_[0] |= 0x00000001u;
  return sp_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AutoSp::release_sp_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AutoSp.sp_name)
  if (!_internal_has_sp_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sp_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sp_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoSp::set_allocated_sp_name(std::string* sp_name) {
  if (sp_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sp_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sp_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sp_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AutoSp.sp_name)
}

// optional bool reset_error = 3;
inline bool AutoSp::_internal_has_reset_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutoSp::has_reset_error() const {
  return _internal_has_reset_error();
}
inline void AutoSp::clear_reset_error() {
  reset_error_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool AutoSp::_internal_reset_error() const {
  return reset_error_;
}
inline bool AutoSp::reset_error() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AutoSp.reset_error)
  return _internal_reset_error();
}
inline void AutoSp::_internal_set_reset_error(bool value) {
  _has_bits_[0] |= 0x00000004u;
  reset_error_ = value;
}
inline void AutoSp::set_reset_error(bool value) {
  _internal_set_reset_error(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.AutoSp.reset_error)
}

// -------------------------------------------------------------------

// KeyExpr

// required .PolarXRPC.Datatypes.Scalar field = 1;
inline bool KeyExpr::_internal_has_field() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || field_ != nullptr);
  return value;
}
inline bool KeyExpr::has_field() const {
  return _internal_has_field();
}
inline const ::PolarXRPC::Datatypes::Scalar& KeyExpr::_internal_field() const {
  const ::PolarXRPC::Datatypes::Scalar* p = field_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Datatypes::Scalar&>(
      ::PolarXRPC::Datatypes::_Scalar_default_instance_);
}
inline const ::PolarXRPC::Datatypes::Scalar& KeyExpr::field() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyExpr.field)
  return _internal_field();
}
inline void KeyExpr::unsafe_arena_set_allocated_field(
    ::PolarXRPC::Datatypes::Scalar* field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_);
  }
  field_ = field;
  if (field) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.KeyExpr.field)
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::release_field() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Datatypes::Scalar* temp = field_;
  field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::unsafe_arena_release_field() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.KeyExpr.field)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Datatypes::Scalar* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::_internal_mutable_field() {
  _has_bits_[0] |= 0x00000001u;
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Datatypes::Scalar>(GetArenaForAllocation());
    field_ = p;
  }
  return field_;
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::mutable_field() {
  ::PolarXRPC::Datatypes::Scalar* _msg = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.KeyExpr.field)
  return _msg;
}
inline void KeyExpr::set_allocated_field(::PolarXRPC::Datatypes::Scalar* field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_);
  }
  if (field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field));
    if (message_arena != submessage_arena) {
      field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.KeyExpr.field)
}

// required .PolarXRPC.Datatypes.Scalar value = 2;
inline bool KeyExpr::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool KeyExpr::has_value() const {
  return _internal_has_value();
}
inline const ::PolarXRPC::Datatypes::Scalar& KeyExpr::_internal_value() const {
  const ::PolarXRPC::Datatypes::Scalar* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Datatypes::Scalar&>(
      ::PolarXRPC::Datatypes::_Scalar_default_instance_);
}
inline const ::PolarXRPC::Datatypes::Scalar& KeyExpr::value() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyExpr.value)
  return _internal_value();
}
inline void KeyExpr::unsafe_arena_set_allocated_value(
    ::PolarXRPC::Datatypes::Scalar* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.KeyExpr.value)
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Datatypes::Scalar* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.KeyExpr.value)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Datatypes::Scalar* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Datatypes::Scalar>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::PolarXRPC::Datatypes::Scalar* KeyExpr::mutable_value() {
  ::PolarXRPC::Datatypes::Scalar* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.KeyExpr.value)
  return _msg;
}
inline void KeyExpr::set_allocated_value(::PolarXRPC::Datatypes::Scalar* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.KeyExpr.value)
}

// -------------------------------------------------------------------

// GetExpr

// repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
inline int GetExpr::_internal_keys_size() const {
  return keys_.size();
}
inline int GetExpr::keys_size() const {
  return _internal_keys_size();
}
inline void GetExpr::clear_keys() {
  keys_.Clear();
}
inline ::PolarXRPC::ExecPlan::KeyExpr* GetExpr::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.GetExpr.keys)
  return keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::KeyExpr >*
GetExpr::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.GetExpr.keys)
  return &keys_;
}
inline const ::PolarXRPC::ExecPlan::KeyExpr& GetExpr::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const ::PolarXRPC::ExecPlan::KeyExpr& GetExpr::keys(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.GetExpr.keys)
  return _internal_keys(index);
}
inline ::PolarXRPC::ExecPlan::KeyExpr* GetExpr::_internal_add_keys() {
  return keys_.Add();
}
inline ::PolarXRPC::ExecPlan::KeyExpr* GetExpr::add_keys() {
  ::PolarXRPC::ExecPlan::KeyExpr* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.GetExpr.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::KeyExpr >&
GetExpr::keys() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.GetExpr.keys)
  return keys_;
}

// -------------------------------------------------------------------

// GetPlan

// required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
inline bool GetPlan::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || table_info_ != nullptr);
  return value;
}
inline bool GetPlan::has_table_info() const {
  return _internal_has_table_info();
}
inline void GetPlan::clear_table_info() {
  if (table_info_ != nullptr) table_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::TableInfo& GetPlan::_internal_table_info() const {
  const ::PolarXRPC::ExecPlan::TableInfo* p = table_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::TableInfo&>(
      ::PolarXRPC::ExecPlan::_TableInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::TableInfo& GetPlan::table_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.GetPlan.table_info)
  return _internal_table_info();
}
inline void GetPlan::unsafe_arena_set_allocated_table_info(
    ::PolarXRPC::ExecPlan::TableInfo* table_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_info_);
  }
  table_info_ = table_info;
  if (table_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.GetPlan.table_info)
}
inline ::PolarXRPC::ExecPlan::TableInfo* GetPlan::release_table_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* GetPlan::unsafe_arena_release_table_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.GetPlan.table_info)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* GetPlan::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000001u;
  if (table_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::TableInfo>(GetArenaForAllocation());
    table_info_ = p;
  }
  return table_info_;
}
inline ::PolarXRPC::ExecPlan::TableInfo* GetPlan::mutable_table_info() {
  ::PolarXRPC::ExecPlan::TableInfo* _msg = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.GetPlan.table_info)
  return _msg;
}
inline void GetPlan::set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_info_;
  }
  if (table_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::TableInfo>::GetOwningArena(table_info);
    if (message_arena != submessage_arena) {
      table_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_info_ = table_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.GetPlan.table_info)
}

// optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
inline bool GetPlan::_internal_has_index_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || index_info_ != nullptr);
  return value;
}
inline bool GetPlan::has_index_info() const {
  return _internal_has_index_info();
}
inline void GetPlan::clear_index_info() {
  if (index_info_ != nullptr) index_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& GetPlan::_internal_index_info() const {
  const ::PolarXRPC::ExecPlan::IndexInfo* p = index_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::IndexInfo&>(
      ::PolarXRPC::ExecPlan::_IndexInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& GetPlan::index_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.GetPlan.index_info)
  return _internal_index_info();
}
inline void GetPlan::unsafe_arena_set_allocated_index_info(
    ::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_info_);
  }
  index_info_ = index_info;
  if (index_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.GetPlan.index_info)
}
inline ::PolarXRPC::ExecPlan::IndexInfo* GetPlan::release_index_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* GetPlan::unsafe_arena_release_index_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.GetPlan.index_info)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* GetPlan::_internal_mutable_index_info() {
  _has_bits_[0] |= 0x00000002u;
  if (index_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::IndexInfo>(GetArenaForAllocation());
    index_info_ = p;
  }
  return index_info_;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* GetPlan::mutable_index_info() {
  ::PolarXRPC::ExecPlan::IndexInfo* _msg = _internal_mutable_index_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.GetPlan.index_info)
  return _msg;
}
inline void GetPlan::set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_info_;
  }
  if (index_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::IndexInfo>::GetOwningArena(index_info);
    if (message_arena != submessage_arena) {
      index_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  index_info_ = index_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.GetPlan.index_info)
}

// repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
inline int GetPlan::_internal_keys_size() const {
  return keys_.size();
}
inline int GetPlan::keys_size() const {
  return _internal_keys_size();
}
inline void GetPlan::clear_keys() {
  keys_.Clear();
}
inline ::PolarXRPC::ExecPlan::GetExpr* GetPlan::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.GetPlan.keys)
  return keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::GetExpr >*
GetPlan::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.GetPlan.keys)
  return &keys_;
}
inline const ::PolarXRPC::ExecPlan::GetExpr& GetPlan::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const ::PolarXRPC::ExecPlan::GetExpr& GetPlan::keys(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.GetPlan.keys)
  return _internal_keys(index);
}
inline ::PolarXRPC::ExecPlan::GetExpr* GetPlan::_internal_add_keys() {
  return keys_.Add();
}
inline ::PolarXRPC::ExecPlan::GetExpr* GetPlan::add_keys() {
  ::PolarXRPC::ExecPlan::GetExpr* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.GetPlan.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::ExecPlan::GetExpr >&
GetPlan::keys() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.GetPlan.keys)
  return keys_;
}

// -------------------------------------------------------------------

// TableScanPlan

// required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
inline bool TableScanPlan::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || table_info_ != nullptr);
  return value;
}
inline bool TableScanPlan::has_table_info() const {
  return _internal_has_table_info();
}
inline void TableScanPlan::clear_table_info() {
  if (table_info_ != nullptr) table_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::TableInfo& TableScanPlan::_internal_table_info() const {
  const ::PolarXRPC::ExecPlan::TableInfo* p = table_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::TableInfo&>(
      ::PolarXRPC::ExecPlan::_TableInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::TableInfo& TableScanPlan::table_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableScanPlan.table_info)
  return _internal_table_info();
}
inline void TableScanPlan::unsafe_arena_set_allocated_table_info(
    ::PolarXRPC::ExecPlan::TableInfo* table_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_info_);
  }
  table_info_ = table_info;
  if (table_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.TableScanPlan.table_info)
}
inline ::PolarXRPC::ExecPlan::TableInfo* TableScanPlan::release_table_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* TableScanPlan::unsafe_arena_release_table_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.TableScanPlan.table_info)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* TableScanPlan::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000001u;
  if (table_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::TableInfo>(GetArenaForAllocation());
    table_info_ = p;
  }
  return table_info_;
}
inline ::PolarXRPC::ExecPlan::TableInfo* TableScanPlan::mutable_table_info() {
  ::PolarXRPC::ExecPlan::TableInfo* _msg = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.TableScanPlan.table_info)
  return _msg;
}
inline void TableScanPlan::set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_info_;
  }
  if (table_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::TableInfo>::GetOwningArena(table_info);
    if (message_arena != submessage_arena) {
      table_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_info_ = table_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.TableScanPlan.table_info)
}

// optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
inline bool TableScanPlan::_internal_has_index_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || index_info_ != nullptr);
  return value;
}
inline bool TableScanPlan::has_index_info() const {
  return _internal_has_index_info();
}
inline void TableScanPlan::clear_index_info() {
  if (index_info_ != nullptr) index_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& TableScanPlan::_internal_index_info() const {
  const ::PolarXRPC::ExecPlan::IndexInfo* p = index_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::IndexInfo&>(
      ::PolarXRPC::ExecPlan::_IndexInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& TableScanPlan::index_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableScanPlan.index_info)
  return _internal_index_info();
}
inline void TableScanPlan::unsafe_arena_set_allocated_index_info(
    ::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_info_);
  }
  index_info_ = index_info;
  if (index_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.TableScanPlan.index_info)
}
inline ::PolarXRPC::ExecPlan::IndexInfo* TableScanPlan::release_index_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* TableScanPlan::unsafe_arena_release_index_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.TableScanPlan.index_info)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* TableScanPlan::_internal_mutable_index_info() {
  _has_bits_[0] |= 0x00000002u;
  if (index_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::IndexInfo>(GetArenaForAllocation());
    index_info_ = p;
  }
  return index_info_;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* TableScanPlan::mutable_index_info() {
  ::PolarXRPC::ExecPlan::IndexInfo* _msg = _internal_mutable_index_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.TableScanPlan.index_info)
  return _msg;
}
inline void TableScanPlan::set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_info_;
  }
  if (index_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::IndexInfo>::GetOwningArena(index_info);
    if (message_arena != submessage_arena) {
      index_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  index_info_ = index_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.TableScanPlan.index_info)
}

// optional bool reverse = 3;
inline bool TableScanPlan::_internal_has_reverse() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableScanPlan::has_reverse() const {
  return _internal_has_reverse();
}
inline void TableScanPlan::clear_reverse() {
  reverse_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TableScanPlan::_internal_reverse() const {
  return reverse_;
}
inline bool TableScanPlan::reverse() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableScanPlan.reverse)
  return _internal_reverse();
}
inline void TableScanPlan::_internal_set_reverse(bool value) {
  _has_bits_[0] |= 0x00000004u;
  reverse_ = value;
}
inline void TableScanPlan::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.TableScanPlan.reverse)
}

// -------------------------------------------------------------------

// KeyOnlyRangeScan

// optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
inline bool KeyOnlyRangeScan::_internal_has_snapshot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || snapshot_ != nullptr);
  return value;
}
inline bool KeyOnlyRangeScan::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void KeyOnlyRangeScan::clear_snapshot() {
  if (snapshot_ != nullptr) snapshot_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::Transaction& KeyOnlyRangeScan::_internal_snapshot() const {
  const ::PolarXRPC::ExecPlan::Transaction* p = snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::Transaction&>(
      ::PolarXRPC::ExecPlan::_Transaction_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::Transaction& KeyOnlyRangeScan::snapshot() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyOnlyRangeScan.snapshot)
  return _internal_snapshot();
}
inline void KeyOnlyRangeScan::unsafe_arena_set_allocated_snapshot(
    ::PolarXRPC::ExecPlan::Transaction* snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(snapshot_);
  }
  snapshot_ = snapshot;
  if (snapshot) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.snapshot)
}
inline ::PolarXRPC::ExecPlan::Transaction* KeyOnlyRangeScan::release_snapshot() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::Transaction* temp = snapshot_;
  snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::Transaction* KeyOnlyRangeScan::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.KeyOnlyRangeScan.snapshot)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::Transaction* temp = snapshot_;
  snapshot_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::Transaction* KeyOnlyRangeScan::_internal_mutable_snapshot() {
  _has_bits_[0] |= 0x00000001u;
  if (snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::Transaction>(GetArenaForAllocation());
    snapshot_ = p;
  }
  return snapshot_;
}
inline ::PolarXRPC::ExecPlan::Transaction* KeyOnlyRangeScan::mutable_snapshot() {
  ::PolarXRPC::ExecPlan::Transaction* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.KeyOnlyRangeScan.snapshot)
  return _msg;
}
inline void KeyOnlyRangeScan::set_allocated_snapshot(::PolarXRPC::ExecPlan::Transaction* snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete snapshot_;
  }
  if (snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::Transaction>::GetOwningArena(snapshot);
    if (message_arena != submessage_arena) {
      snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  snapshot_ = snapshot;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.snapshot)
}

// optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
inline bool KeyOnlyRangeScan::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || table_info_ != nullptr);
  return value;
}
inline bool KeyOnlyRangeScan::has_table_info() const {
  return _internal_has_table_info();
}
inline void KeyOnlyRangeScan::clear_table_info() {
  if (table_info_ != nullptr) table_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::ExecPlan::TableInfo& KeyOnlyRangeScan::_internal_table_info() const {
  const ::PolarXRPC::ExecPlan::TableInfo* p = table_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::TableInfo&>(
      ::PolarXRPC::ExecPlan::_TableInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::TableInfo& KeyOnlyRangeScan::table_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyOnlyRangeScan.table_info)
  return _internal_table_info();
}
inline void KeyOnlyRangeScan::unsafe_arena_set_allocated_table_info(
    ::PolarXRPC::ExecPlan::TableInfo* table_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_info_);
  }
  table_info_ = table_info;
  if (table_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.table_info)
}
inline ::PolarXRPC::ExecPlan::TableInfo* KeyOnlyRangeScan::release_table_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* KeyOnlyRangeScan::unsafe_arena_release_table_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.KeyOnlyRangeScan.table_info)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* KeyOnlyRangeScan::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000002u;
  if (table_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::TableInfo>(GetArenaForAllocation());
    table_info_ = p;
  }
  return table_info_;
}
inline ::PolarXRPC::ExecPlan::TableInfo* KeyOnlyRangeScan::mutable_table_info() {
  ::PolarXRPC::ExecPlan::TableInfo* _msg = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.KeyOnlyRangeScan.table_info)
  return _msg;
}
inline void KeyOnlyRangeScan::set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_info_;
  }
  if (table_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::TableInfo>::GetOwningArena(table_info);
    if (message_arena != submessage_arena) {
      table_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_info_ = table_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.table_info)
}

// optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
inline bool KeyOnlyRangeScan::_internal_has_index_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || index_info_ != nullptr);
  return value;
}
inline bool KeyOnlyRangeScan::has_index_info() const {
  return _internal_has_index_info();
}
inline void KeyOnlyRangeScan::clear_index_info() {
  if (index_info_ != nullptr) index_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& KeyOnlyRangeScan::_internal_index_info() const {
  const ::PolarXRPC::ExecPlan::IndexInfo* p = index_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::IndexInfo&>(
      ::PolarXRPC::ExecPlan::_IndexInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& KeyOnlyRangeScan::index_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyOnlyRangeScan.index_info)
  return _internal_index_info();
}
inline void KeyOnlyRangeScan::unsafe_arena_set_allocated_index_info(
    ::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_info_);
  }
  index_info_ = index_info;
  if (index_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.index_info)
}
inline ::PolarXRPC::ExecPlan::IndexInfo* KeyOnlyRangeScan::release_index_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* KeyOnlyRangeScan::unsafe_arena_release_index_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.KeyOnlyRangeScan.index_info)
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* KeyOnlyRangeScan::_internal_mutable_index_info() {
  _has_bits_[0] |= 0x00000004u;
  if (index_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::IndexInfo>(GetArenaForAllocation());
    index_info_ = p;
  }
  return index_info_;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* KeyOnlyRangeScan::mutable_index_info() {
  ::PolarXRPC::ExecPlan::IndexInfo* _msg = _internal_mutable_index_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.KeyOnlyRangeScan.index_info)
  return _msg;
}
inline void KeyOnlyRangeScan::set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_info_;
  }
  if (index_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::IndexInfo>::GetOwningArena(index_info);
    if (message_arena != submessage_arena) {
      index_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  index_info_ = index_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.index_info)
}

// optional .PolarXRPC.ExecPlan.GetExpr key = 5;
inline bool KeyOnlyRangeScan::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || key_ != nullptr);
  return value;
}
inline bool KeyOnlyRangeScan::has_key() const {
  return _internal_has_key();
}
inline void KeyOnlyRangeScan::clear_key() {
  if (key_ != nullptr) key_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::PolarXRPC::ExecPlan::GetExpr& KeyOnlyRangeScan::_internal_key() const {
  const ::PolarXRPC::ExecPlan::GetExpr* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::GetExpr&>(
      ::PolarXRPC::ExecPlan::_GetExpr_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::GetExpr& KeyOnlyRangeScan::key() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyOnlyRangeScan.key)
  return _internal_key();
}
inline void KeyOnlyRangeScan::unsafe_arena_set_allocated_key(
    ::PolarXRPC::ExecPlan::GetExpr* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.key)
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::release_key() {
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.KeyOnlyRangeScan.key)
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000008u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::GetExpr>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::mutable_key() {
  ::PolarXRPC::ExecPlan::GetExpr* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.KeyOnlyRangeScan.key)
  return _msg;
}
inline void KeyOnlyRangeScan::set_allocated_key(::PolarXRPC::ExecPlan::GetExpr* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::GetExpr>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.key)
}

// optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
inline bool KeyOnlyRangeScan::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || end_key_ != nullptr);
  return value;
}
inline bool KeyOnlyRangeScan::has_end_key() const {
  return _internal_has_end_key();
}
inline void KeyOnlyRangeScan::clear_end_key() {
  if (end_key_ != nullptr) end_key_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::PolarXRPC::ExecPlan::GetExpr& KeyOnlyRangeScan::_internal_end_key() const {
  const ::PolarXRPC::ExecPlan::GetExpr* p = end_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::GetExpr&>(
      ::PolarXRPC::ExecPlan::_GetExpr_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::GetExpr& KeyOnlyRangeScan::end_key() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyOnlyRangeScan.end_key)
  return _internal_end_key();
}
inline void KeyOnlyRangeScan::unsafe_arena_set_allocated_end_key(
    ::PolarXRPC::ExecPlan::GetExpr* end_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_key_);
  }
  end_key_ = end_key;
  if (end_key) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.end_key)
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::release_end_key() {
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = end_key_;
  end_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::unsafe_arena_release_end_key() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.KeyOnlyRangeScan.end_key)
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = end_key_;
  end_key_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000010u;
  if (end_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::GetExpr>(GetArenaForAllocation());
    end_key_ = p;
  }
  return end_key_;
}
inline ::PolarXRPC::ExecPlan::GetExpr* KeyOnlyRangeScan::mutable_end_key() {
  ::PolarXRPC::ExecPlan::GetExpr* _msg = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.KeyOnlyRangeScan.end_key)
  return _msg;
}
inline void KeyOnlyRangeScan::set_allocated_end_key(::PolarXRPC::ExecPlan::GetExpr* end_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_key_;
  }
  if (end_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::GetExpr>::GetOwningArena(end_key);
    if (message_arena != submessage_arena) {
      end_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  end_key_ = end_key;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.KeyOnlyRangeScan.end_key)
}

// optional bool reverse = 8;
inline bool KeyOnlyRangeScan::_internal_has_reverse() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool KeyOnlyRangeScan::has_reverse() const {
  return _internal_has_reverse();
}
inline void KeyOnlyRangeScan::clear_reverse() {
  reverse_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool KeyOnlyRangeScan::_internal_reverse() const {
  return reverse_;
}
inline bool KeyOnlyRangeScan::reverse() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyOnlyRangeScan.reverse)
  return _internal_reverse();
}
inline void KeyOnlyRangeScan::_internal_set_reverse(bool value) {
  _has_bits_[0] |= 0x00000020u;
  reverse_ = value;
}
inline void KeyOnlyRangeScan::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.KeyOnlyRangeScan.reverse)
}

// optional int64 flag = 9;
inline bool KeyOnlyRangeScan::_internal_has_flag() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool KeyOnlyRangeScan::has_flag() const {
  return _internal_has_flag();
}
inline void KeyOnlyRangeScan::clear_flag() {
  flag_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t KeyOnlyRangeScan::_internal_flag() const {
  return flag_;
}
inline int64_t KeyOnlyRangeScan::flag() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.KeyOnlyRangeScan.flag)
  return _internal_flag();
}
inline void KeyOnlyRangeScan::_internal_set_flag(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  flag_ = value;
}
inline void KeyOnlyRangeScan::set_flag(int64_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.KeyOnlyRangeScan.flag)
}

// -------------------------------------------------------------------

// RangeScan

// optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
inline bool RangeScan::_internal_has_snapshot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || snapshot_ != nullptr);
  return value;
}
inline bool RangeScan::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void RangeScan::clear_snapshot() {
  if (snapshot_ != nullptr) snapshot_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::Transaction& RangeScan::_internal_snapshot() const {
  const ::PolarXRPC::ExecPlan::Transaction* p = snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::Transaction&>(
      ::PolarXRPC::ExecPlan::_Transaction_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::Transaction& RangeScan::snapshot() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.RangeScan.snapshot)
  return _internal_snapshot();
}
inline void RangeScan::unsafe_arena_set_allocated_snapshot(
    ::PolarXRPC::ExecPlan::Transaction* snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(snapshot_);
  }
  snapshot_ = snapshot;
  if (snapshot) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.RangeScan.snapshot)
}
inline ::PolarXRPC::ExecPlan::Transaction* RangeScan::release_snapshot() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::Transaction* temp = snapshot_;
  snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::Transaction* RangeScan::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.RangeScan.snapshot)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::Transaction* temp = snapshot_;
  snapshot_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::Transaction* RangeScan::_internal_mutable_snapshot() {
  _has_bits_[0] |= 0x00000001u;
  if (snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::Transaction>(GetArenaForAllocation());
    snapshot_ = p;
  }
  return snapshot_;
}
inline ::PolarXRPC::ExecPlan::Transaction* RangeScan::mutable_snapshot() {
  ::PolarXRPC::ExecPlan::Transaction* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.RangeScan.snapshot)
  return _msg;
}
inline void RangeScan::set_allocated_snapshot(::PolarXRPC::ExecPlan::Transaction* snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete snapshot_;
  }
  if (snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::Transaction>::GetOwningArena(snapshot);
    if (message_arena != submessage_arena) {
      snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  snapshot_ = snapshot;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.RangeScan.snapshot)
}

// optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
inline bool RangeScan::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || table_info_ != nullptr);
  return value;
}
inline bool RangeScan::has_table_info() const {
  return _internal_has_table_info();
}
inline void RangeScan::clear_table_info() {
  if (table_info_ != nullptr) table_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::ExecPlan::TableInfo& RangeScan::_internal_table_info() const {
  const ::PolarXRPC::ExecPlan::TableInfo* p = table_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::TableInfo&>(
      ::PolarXRPC::ExecPlan::_TableInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::TableInfo& RangeScan::table_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.RangeScan.table_info)
  return _internal_table_info();
}
inline void RangeScan::unsafe_arena_set_allocated_table_info(
    ::PolarXRPC::ExecPlan::TableInfo* table_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_info_);
  }
  table_info_ = table_info;
  if (table_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.RangeScan.table_info)
}
inline ::PolarXRPC::ExecPlan::TableInfo* RangeScan::release_table_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* RangeScan::unsafe_arena_release_table_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.RangeScan.table_info)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::TableInfo* temp = table_info_;
  table_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableInfo* RangeScan::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000002u;
  if (table_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::TableInfo>(GetArenaForAllocation());
    table_info_ = p;
  }
  return table_info_;
}
inline ::PolarXRPC::ExecPlan::TableInfo* RangeScan::mutable_table_info() {
  ::PolarXRPC::ExecPlan::TableInfo* _msg = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.RangeScan.table_info)
  return _msg;
}
inline void RangeScan::set_allocated_table_info(::PolarXRPC::ExecPlan::TableInfo* table_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_info_;
  }
  if (table_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::TableInfo>::GetOwningArena(table_info);
    if (message_arena != submessage_arena) {
      table_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_info_ = table_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.RangeScan.table_info)
}

// optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
inline bool RangeScan::_internal_has_index_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || index_info_ != nullptr);
  return value;
}
inline bool RangeScan::has_index_info() const {
  return _internal_has_index_info();
}
inline void RangeScan::clear_index_info() {
  if (index_info_ != nullptr) index_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& RangeScan::_internal_index_info() const {
  const ::PolarXRPC::ExecPlan::IndexInfo* p = index_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::IndexInfo&>(
      ::PolarXRPC::ExecPlan::_IndexInfo_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::IndexInfo& RangeScan::index_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.RangeScan.index_info)
  return _internal_index_info();
}
inline void RangeScan::unsafe_arena_set_allocated_index_info(
    ::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_info_);
  }
  index_info_ = index_info;
  if (index_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.RangeScan.index_info)
}
inline ::PolarXRPC::ExecPlan::IndexInfo* RangeScan::release_index_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* RangeScan::unsafe_arena_release_index_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.RangeScan.index_info)
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::ExecPlan::IndexInfo* temp = index_info_;
  index_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* RangeScan::_internal_mutable_index_info() {
  _has_bits_[0] |= 0x00000004u;
  if (index_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::IndexInfo>(GetArenaForAllocation());
    index_info_ = p;
  }
  return index_info_;
}
inline ::PolarXRPC::ExecPlan::IndexInfo* RangeScan::mutable_index_info() {
  ::PolarXRPC::ExecPlan::IndexInfo* _msg = _internal_mutable_index_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.RangeScan.index_info)
  return _msg;
}
inline void RangeScan::set_allocated_index_info(::PolarXRPC::ExecPlan::IndexInfo* index_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_info_;
  }
  if (index_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::IndexInfo>::GetOwningArena(index_info);
    if (message_arena != submessage_arena) {
      index_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  index_info_ = index_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.RangeScan.index_info)
}

// optional .PolarXRPC.ExecPlan.GetExpr key = 5;
inline bool RangeScan::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || key_ != nullptr);
  return value;
}
inline bool RangeScan::has_key() const {
  return _internal_has_key();
}
inline void RangeScan::clear_key() {
  if (key_ != nullptr) key_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::PolarXRPC::ExecPlan::GetExpr& RangeScan::_internal_key() const {
  const ::PolarXRPC::ExecPlan::GetExpr* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::GetExpr&>(
      ::PolarXRPC::ExecPlan::_GetExpr_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::GetExpr& RangeScan::key() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.RangeScan.key)
  return _internal_key();
}
inline void RangeScan::unsafe_arena_set_allocated_key(
    ::PolarXRPC::ExecPlan::GetExpr* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.RangeScan.key)
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::release_key() {
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = key_;
  key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.RangeScan.key)
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000008u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::GetExpr>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::mutable_key() {
  ::PolarXRPC::ExecPlan::GetExpr* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.RangeScan.key)
  return _msg;
}
inline void RangeScan::set_allocated_key(::PolarXRPC::ExecPlan::GetExpr* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::GetExpr>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.RangeScan.key)
}

// optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
inline bool RangeScan::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || end_key_ != nullptr);
  return value;
}
inline bool RangeScan::has_end_key() const {
  return _internal_has_end_key();
}
inline void RangeScan::clear_end_key() {
  if (end_key_ != nullptr) end_key_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::PolarXRPC::ExecPlan::GetExpr& RangeScan::_internal_end_key() const {
  const ::PolarXRPC::ExecPlan::GetExpr* p = end_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::GetExpr&>(
      ::PolarXRPC::ExecPlan::_GetExpr_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::GetExpr& RangeScan::end_key() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.RangeScan.end_key)
  return _internal_end_key();
}
inline void RangeScan::unsafe_arena_set_allocated_end_key(
    ::PolarXRPC::ExecPlan::GetExpr* end_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_key_);
  }
  end_key_ = end_key;
  if (end_key) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.RangeScan.end_key)
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::release_end_key() {
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = end_key_;
  end_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::unsafe_arena_release_end_key() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.RangeScan.end_key)
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::GetExpr* temp = end_key_;
  end_key_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000010u;
  if (end_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::GetExpr>(GetArenaForAllocation());
    end_key_ = p;
  }
  return end_key_;
}
inline ::PolarXRPC::ExecPlan::GetExpr* RangeScan::mutable_end_key() {
  ::PolarXRPC::ExecPlan::GetExpr* _msg = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.RangeScan.end_key)
  return _msg;
}
inline void RangeScan::set_allocated_end_key(::PolarXRPC::ExecPlan::GetExpr* end_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_key_;
  }
  if (end_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::GetExpr>::GetOwningArena(end_key);
    if (message_arena != submessage_arena) {
      end_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  end_key_ = end_key;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.RangeScan.end_key)
}

// optional bool reverse = 8;
inline bool RangeScan::_internal_has_reverse() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RangeScan::has_reverse() const {
  return _internal_has_reverse();
}
inline void RangeScan::clear_reverse() {
  reverse_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool RangeScan::_internal_reverse() const {
  return reverse_;
}
inline bool RangeScan::reverse() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.RangeScan.reverse)
  return _internal_reverse();
}
inline void RangeScan::_internal_set_reverse(bool value) {
  _has_bits_[0] |= 0x00000020u;
  reverse_ = value;
}
inline void RangeScan::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.RangeScan.reverse)
}

// optional int64 flag = 9;
inline bool RangeScan::_internal_has_flag() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RangeScan::has_flag() const {
  return _internal_has_flag();
}
inline void RangeScan::clear_flag() {
  flag_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t RangeScan::_internal_flag() const {
  return flag_;
}
inline int64_t RangeScan::flag() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.RangeScan.flag)
  return _internal_flag();
}
inline void RangeScan::_internal_set_flag(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  flag_ = value;
}
inline void RangeScan::set_flag(int64_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.RangeScan.flag)
}

// -------------------------------------------------------------------

// TableProject

// required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
inline bool TableProject::_internal_has_sub_read_plan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sub_read_plan_ != nullptr);
  return value;
}
inline bool TableProject::has_sub_read_plan() const {
  return _internal_has_sub_read_plan();
}
inline void TableProject::clear_sub_read_plan() {
  if (sub_read_plan_ != nullptr) sub_read_plan_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& TableProject::_internal_sub_read_plan() const {
  const ::PolarXRPC::ExecPlan::AnyPlan* p = sub_read_plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::AnyPlan&>(
      ::PolarXRPC::ExecPlan::_AnyPlan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& TableProject::sub_read_plan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableProject.sub_read_plan)
  return _internal_sub_read_plan();
}
inline void TableProject::unsafe_arena_set_allocated_sub_read_plan(
    ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sub_read_plan_);
  }
  sub_read_plan_ = sub_read_plan;
  if (sub_read_plan) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.TableProject.sub_read_plan)
}
inline ::PolarXRPC::ExecPlan::AnyPlan* TableProject::release_sub_read_plan() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* TableProject::unsafe_arena_release_sub_read_plan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.TableProject.sub_read_plan)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* TableProject::_internal_mutable_sub_read_plan() {
  _has_bits_[0] |= 0x00000001u;
  if (sub_read_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::AnyPlan>(GetArenaForAllocation());
    sub_read_plan_ = p;
  }
  return sub_read_plan_;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* TableProject::mutable_sub_read_plan() {
  ::PolarXRPC::ExecPlan::AnyPlan* _msg = _internal_mutable_sub_read_plan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.TableProject.sub_read_plan)
  return _msg;
}
inline void TableProject::set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sub_read_plan_;
  }
  if (sub_read_plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::AnyPlan>::GetOwningArena(sub_read_plan);
    if (message_arena != submessage_arena) {
      sub_read_plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub_read_plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sub_read_plan_ = sub_read_plan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.TableProject.sub_read_plan)
}

// repeated .PolarXRPC.Datatypes.Scalar fields = 2;
inline int TableProject::_internal_fields_size() const {
  return fields_.size();
}
inline int TableProject::fields_size() const {
  return _internal_fields_size();
}
inline ::PolarXRPC::Datatypes::Scalar* TableProject::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.TableProject.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >*
TableProject::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.TableProject.fields)
  return &fields_;
}
inline const ::PolarXRPC::Datatypes::Scalar& TableProject::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::PolarXRPC::Datatypes::Scalar& TableProject::fields(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.TableProject.fields)
  return _internal_fields(index);
}
inline ::PolarXRPC::Datatypes::Scalar* TableProject::_internal_add_fields() {
  return fields_.Add();
}
inline ::PolarXRPC::Datatypes::Scalar* TableProject::add_fields() {
  ::PolarXRPC::Datatypes::Scalar* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.TableProject.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >&
TableProject::fields() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.TableProject.fields)
  return fields_;
}

// -------------------------------------------------------------------

// Project

// required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
inline bool Project::_internal_has_sub_read_plan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sub_read_plan_ != nullptr);
  return value;
}
inline bool Project::has_sub_read_plan() const {
  return _internal_has_sub_read_plan();
}
inline void Project::clear_sub_read_plan() {
  if (sub_read_plan_ != nullptr) sub_read_plan_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& Project::_internal_sub_read_plan() const {
  const ::PolarXRPC::ExecPlan::AnyPlan* p = sub_read_plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::AnyPlan&>(
      ::PolarXRPC::ExecPlan::_AnyPlan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& Project::sub_read_plan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Project.sub_read_plan)
  return _internal_sub_read_plan();
}
inline void Project::unsafe_arena_set_allocated_sub_read_plan(
    ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sub_read_plan_);
  }
  sub_read_plan_ = sub_read_plan;
  if (sub_read_plan) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.Project.sub_read_plan)
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Project::release_sub_read_plan() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Project::unsafe_arena_release_sub_read_plan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.Project.sub_read_plan)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Project::_internal_mutable_sub_read_plan() {
  _has_bits_[0] |= 0x00000001u;
  if (sub_read_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::AnyPlan>(GetArenaForAllocation());
    sub_read_plan_ = p;
  }
  return sub_read_plan_;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Project::mutable_sub_read_plan() {
  ::PolarXRPC::ExecPlan::AnyPlan* _msg = _internal_mutable_sub_read_plan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Project.sub_read_plan)
  return _msg;
}
inline void Project::set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sub_read_plan_;
  }
  if (sub_read_plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::AnyPlan>::GetOwningArena(sub_read_plan);
    if (message_arena != submessage_arena) {
      sub_read_plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub_read_plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sub_read_plan_ = sub_read_plan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.Project.sub_read_plan)
}

// repeated .PolarXRPC.Datatypes.Scalar fields = 2;
inline int Project::_internal_fields_size() const {
  return fields_.size();
}
inline int Project::fields_size() const {
  return _internal_fields_size();
}
inline ::PolarXRPC::Datatypes::Scalar* Project::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Project.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >*
Project::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.Project.fields)
  return &fields_;
}
inline const ::PolarXRPC::Datatypes::Scalar& Project::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::PolarXRPC::Datatypes::Scalar& Project::fields(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Project.fields)
  return _internal_fields(index);
}
inline ::PolarXRPC::Datatypes::Scalar* Project::_internal_add_fields() {
  return fields_.Add();
}
inline ::PolarXRPC::Datatypes::Scalar* Project::add_fields() {
  ::PolarXRPC::Datatypes::Scalar* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.Project.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >&
Project::fields() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.Project.fields)
  return fields_;
}

// repeated .PolarXRPC.Expr.Expr exprs = 3;
inline int Project::_internal_exprs_size() const {
  return exprs_.size();
}
inline int Project::exprs_size() const {
  return _internal_exprs_size();
}
inline ::PolarXRPC::Expr::Expr* Project::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Project.exprs)
  return exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
Project::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.Project.exprs)
  return &exprs_;
}
inline const ::PolarXRPC::Expr::Expr& Project::_internal_exprs(int index) const {
  return exprs_.Get(index);
}
inline const ::PolarXRPC::Expr::Expr& Project::exprs(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Project.exprs)
  return _internal_exprs(index);
}
inline ::PolarXRPC::Expr::Expr* Project::_internal_add_exprs() {
  return exprs_.Add();
}
inline ::PolarXRPC::Expr::Expr* Project::add_exprs() {
  ::PolarXRPC::Expr::Expr* _add = _internal_add_exprs();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.Project.exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
Project::exprs() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.Project.exprs)
  return exprs_;
}

// -------------------------------------------------------------------

// Filter

// required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
inline bool Filter::_internal_has_sub_read_plan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sub_read_plan_ != nullptr);
  return value;
}
inline bool Filter::has_sub_read_plan() const {
  return _internal_has_sub_read_plan();
}
inline void Filter::clear_sub_read_plan() {
  if (sub_read_plan_ != nullptr) sub_read_plan_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& Filter::_internal_sub_read_plan() const {
  const ::PolarXRPC::ExecPlan::AnyPlan* p = sub_read_plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::AnyPlan&>(
      ::PolarXRPC::ExecPlan::_AnyPlan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& Filter::sub_read_plan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Filter.sub_read_plan)
  return _internal_sub_read_plan();
}
inline void Filter::unsafe_arena_set_allocated_sub_read_plan(
    ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sub_read_plan_);
  }
  sub_read_plan_ = sub_read_plan;
  if (sub_read_plan) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.Filter.sub_read_plan)
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Filter::release_sub_read_plan() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Filter::unsafe_arena_release_sub_read_plan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.Filter.sub_read_plan)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Filter::_internal_mutable_sub_read_plan() {
  _has_bits_[0] |= 0x00000001u;
  if (sub_read_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::AnyPlan>(GetArenaForAllocation());
    sub_read_plan_ = p;
  }
  return sub_read_plan_;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Filter::mutable_sub_read_plan() {
  ::PolarXRPC::ExecPlan::AnyPlan* _msg = _internal_mutable_sub_read_plan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Filter.sub_read_plan)
  return _msg;
}
inline void Filter::set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sub_read_plan_;
  }
  if (sub_read_plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::AnyPlan>::GetOwningArena(sub_read_plan);
    if (message_arena != submessage_arena) {
      sub_read_plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub_read_plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sub_read_plan_ = sub_read_plan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.Filter.sub_read_plan)
}

// required .PolarXRPC.Expr.Expr expr = 2;
inline bool Filter::_internal_has_expr() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || expr_ != nullptr);
  return value;
}
inline bool Filter::has_expr() const {
  return _internal_has_expr();
}
inline const ::PolarXRPC::Expr::Expr& Filter::_internal_expr() const {
  const ::PolarXRPC::Expr::Expr* p = expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::Expr&>(
      ::PolarXRPC::Expr::_Expr_default_instance_);
}
inline const ::PolarXRPC::Expr::Expr& Filter::expr() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Filter.expr)
  return _internal_expr();
}
inline void Filter::unsafe_arena_set_allocated_expr(
    ::PolarXRPC::Expr::Expr* expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  expr_ = expr;
  if (expr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.Filter.expr)
}
inline ::PolarXRPC::Expr::Expr* Filter::release_expr() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Expr::Expr* temp = expr_;
  expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::Expr* Filter::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.Filter.expr)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Expr::Expr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::Expr* Filter::_internal_mutable_expr() {
  _has_bits_[0] |= 0x00000002u;
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::Expr>(GetArenaForAllocation());
    expr_ = p;
  }
  return expr_;
}
inline ::PolarXRPC::Expr::Expr* Filter::mutable_expr() {
  ::PolarXRPC::Expr::Expr* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Filter.expr)
  return _msg;
}
inline void Filter::set_allocated_expr(::PolarXRPC::Expr::Expr* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr));
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.Filter.expr)
}

// -------------------------------------------------------------------

// Aggr

// required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
inline bool Aggr::_internal_has_sub_read_plan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sub_read_plan_ != nullptr);
  return value;
}
inline bool Aggr::has_sub_read_plan() const {
  return _internal_has_sub_read_plan();
}
inline void Aggr::clear_sub_read_plan() {
  if (sub_read_plan_ != nullptr) sub_read_plan_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& Aggr::_internal_sub_read_plan() const {
  const ::PolarXRPC::ExecPlan::AnyPlan* p = sub_read_plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::AnyPlan&>(
      ::PolarXRPC::ExecPlan::_AnyPlan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& Aggr::sub_read_plan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Aggr.sub_read_plan)
  return _internal_sub_read_plan();
}
inline void Aggr::unsafe_arena_set_allocated_sub_read_plan(
    ::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sub_read_plan_);
  }
  sub_read_plan_ = sub_read_plan;
  if (sub_read_plan) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.Aggr.sub_read_plan)
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Aggr::release_sub_read_plan() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Aggr::unsafe_arena_release_sub_read_plan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.Aggr.sub_read_plan)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = sub_read_plan_;
  sub_read_plan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Aggr::_internal_mutable_sub_read_plan() {
  _has_bits_[0] |= 0x00000001u;
  if (sub_read_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::AnyPlan>(GetArenaForAllocation());
    sub_read_plan_ = p;
  }
  return sub_read_plan_;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* Aggr::mutable_sub_read_plan() {
  ::PolarXRPC::ExecPlan::AnyPlan* _msg = _internal_mutable_sub_read_plan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Aggr.sub_read_plan)
  return _msg;
}
inline void Aggr::set_allocated_sub_read_plan(::PolarXRPC::ExecPlan::AnyPlan* sub_read_plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sub_read_plan_;
  }
  if (sub_read_plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::AnyPlan>::GetOwningArena(sub_read_plan);
    if (message_arena != submessage_arena) {
      sub_read_plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub_read_plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sub_read_plan_ = sub_read_plan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.Aggr.sub_read_plan)
}

// required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
inline bool Aggr::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Aggr::has_type() const {
  return _internal_has_type();
}
inline void Aggr::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PolarXRPC::ExecPlan::Aggr_AggrType Aggr::_internal_type() const {
  return static_cast< ::PolarXRPC::ExecPlan::Aggr_AggrType >(type_);
}
inline ::PolarXRPC::ExecPlan::Aggr_AggrType Aggr::type() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Aggr.type)
  return _internal_type();
}
inline void Aggr::_internal_set_type(::PolarXRPC::ExecPlan::Aggr_AggrType value) {
  assert(::PolarXRPC::ExecPlan::Aggr_AggrType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void Aggr::set_type(::PolarXRPC::ExecPlan::Aggr_AggrType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.Aggr.type)
}

// required .PolarXRPC.Datatypes.Scalar field = 3;
inline bool Aggr::_internal_has_field() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || field_ != nullptr);
  return value;
}
inline bool Aggr::has_field() const {
  return _internal_has_field();
}
inline const ::PolarXRPC::Datatypes::Scalar& Aggr::_internal_field() const {
  const ::PolarXRPC::Datatypes::Scalar* p = field_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Datatypes::Scalar&>(
      ::PolarXRPC::Datatypes::_Scalar_default_instance_);
}
inline const ::PolarXRPC::Datatypes::Scalar& Aggr::field() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Aggr.field)
  return _internal_field();
}
inline void Aggr::unsafe_arena_set_allocated_field(
    ::PolarXRPC::Datatypes::Scalar* field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_);
  }
  field_ = field;
  if (field) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.Aggr.field)
}
inline ::PolarXRPC::Datatypes::Scalar* Aggr::release_field() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Datatypes::Scalar* temp = field_;
  field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* Aggr::unsafe_arena_release_field() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.Aggr.field)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Datatypes::Scalar* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* Aggr::_internal_mutable_field() {
  _has_bits_[0] |= 0x00000002u;
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Datatypes::Scalar>(GetArenaForAllocation());
    field_ = p;
  }
  return field_;
}
inline ::PolarXRPC::Datatypes::Scalar* Aggr::mutable_field() {
  ::PolarXRPC::Datatypes::Scalar* _msg = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Aggr.field)
  return _msg;
}
inline void Aggr::set_allocated_field(::PolarXRPC::Datatypes::Scalar* field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_);
  }
  if (field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field));
    if (message_arena != submessage_arena) {
      field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.Aggr.field)
}

// required .PolarXRPC.Expr.Expr expr = 4;
inline bool Aggr::_internal_has_expr() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || expr_ != nullptr);
  return value;
}
inline bool Aggr::has_expr() const {
  return _internal_has_expr();
}
inline const ::PolarXRPC::Expr::Expr& Aggr::_internal_expr() const {
  const ::PolarXRPC::Expr::Expr* p = expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::Expr&>(
      ::PolarXRPC::Expr::_Expr_default_instance_);
}
inline const ::PolarXRPC::Expr::Expr& Aggr::expr() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.Aggr.expr)
  return _internal_expr();
}
inline void Aggr::unsafe_arena_set_allocated_expr(
    ::PolarXRPC::Expr::Expr* expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  expr_ = expr;
  if (expr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.Aggr.expr)
}
inline ::PolarXRPC::Expr::Expr* Aggr::release_expr() {
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::Expr::Expr* temp = expr_;
  expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::Expr* Aggr::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.Aggr.expr)
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::Expr::Expr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::Expr* Aggr::_internal_mutable_expr() {
  _has_bits_[0] |= 0x00000004u;
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::Expr>(GetArenaForAllocation());
    expr_ = p;
  }
  return expr_;
}
inline ::PolarXRPC::Expr::Expr* Aggr::mutable_expr() {
  ::PolarXRPC::Expr::Expr* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.Aggr.expr)
  return _msg;
}
inline void Aggr::set_allocated_expr(::PolarXRPC::Expr::Expr* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr));
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.Aggr.expr)
}

// -------------------------------------------------------------------

// AnyPlan

// required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
inline bool AnyPlan::_internal_has_plan_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AnyPlan::has_plan_type() const {
  return _internal_has_plan_type();
}
inline void AnyPlan::clear_plan_type() {
  plan_type_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PolarXRPC::ExecPlan::AnyPlan_PlanType AnyPlan::_internal_plan_type() const {
  return static_cast< ::PolarXRPC::ExecPlan::AnyPlan_PlanType >(plan_type_);
}
inline ::PolarXRPC::ExecPlan::AnyPlan_PlanType AnyPlan::plan_type() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.plan_type)
  return _internal_plan_type();
}
inline void AnyPlan::_internal_set_plan_type(::PolarXRPC::ExecPlan::AnyPlan_PlanType value) {
  assert(::PolarXRPC::ExecPlan::AnyPlan_PlanType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  plan_type_ = value;
}
inline void AnyPlan::set_plan_type(::PolarXRPC::ExecPlan::AnyPlan_PlanType value) {
  _internal_set_plan_type(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.AnyPlan.plan_type)
}

// optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
inline bool AnyPlan::_internal_has_get_plan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || get_plan_ != nullptr);
  return value;
}
inline bool AnyPlan::has_get_plan() const {
  return _internal_has_get_plan();
}
inline void AnyPlan::clear_get_plan() {
  if (get_plan_ != nullptr) get_plan_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::ExecPlan::GetPlan& AnyPlan::_internal_get_plan() const {
  const ::PolarXRPC::ExecPlan::GetPlan* p = get_plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::GetPlan&>(
      ::PolarXRPC::ExecPlan::_GetPlan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::GetPlan& AnyPlan::get_plan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.get_plan)
  return _internal_get_plan();
}
inline void AnyPlan::unsafe_arena_set_allocated_get_plan(
    ::PolarXRPC::ExecPlan::GetPlan* get_plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(get_plan_);
  }
  get_plan_ = get_plan;
  if (get_plan) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.AnyPlan.get_plan)
}
inline ::PolarXRPC::ExecPlan::GetPlan* AnyPlan::release_get_plan() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::GetPlan* temp = get_plan_;
  get_plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetPlan* AnyPlan::unsafe_arena_release_get_plan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AnyPlan.get_plan)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::ExecPlan::GetPlan* temp = get_plan_;
  get_plan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::GetPlan* AnyPlan::_internal_mutable_get_plan() {
  _has_bits_[0] |= 0x00000001u;
  if (get_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::GetPlan>(GetArenaForAllocation());
    get_plan_ = p;
  }
  return get_plan_;
}
inline ::PolarXRPC::ExecPlan::GetPlan* AnyPlan::mutable_get_plan() {
  ::PolarXRPC::ExecPlan::GetPlan* _msg = _internal_mutable_get_plan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AnyPlan.get_plan)
  return _msg;
}
inline void AnyPlan::set_allocated_get_plan(::PolarXRPC::ExecPlan::GetPlan* get_plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete get_plan_;
  }
  if (get_plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::GetPlan>::GetOwningArena(get_plan);
    if (message_arena != submessage_arena) {
      get_plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  get_plan_ = get_plan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AnyPlan.get_plan)
}

// optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
inline bool AnyPlan::_internal_has_table_scan_plan() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || table_scan_plan_ != nullptr);
  return value;
}
inline bool AnyPlan::has_table_scan_plan() const {
  return _internal_has_table_scan_plan();
}
inline void AnyPlan::clear_table_scan_plan() {
  if (table_scan_plan_ != nullptr) table_scan_plan_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::ExecPlan::TableScanPlan& AnyPlan::_internal_table_scan_plan() const {
  const ::PolarXRPC::ExecPlan::TableScanPlan* p = table_scan_plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::TableScanPlan&>(
      ::PolarXRPC::ExecPlan::_TableScanPlan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::TableScanPlan& AnyPlan::table_scan_plan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.table_scan_plan)
  return _internal_table_scan_plan();
}
inline void AnyPlan::unsafe_arena_set_allocated_table_scan_plan(
    ::PolarXRPC::ExecPlan::TableScanPlan* table_scan_plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_scan_plan_);
  }
  table_scan_plan_ = table_scan_plan;
  if (table_scan_plan) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.AnyPlan.table_scan_plan)
}
inline ::PolarXRPC::ExecPlan::TableScanPlan* AnyPlan::release_table_scan_plan() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::TableScanPlan* temp = table_scan_plan_;
  table_scan_plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableScanPlan* AnyPlan::unsafe_arena_release_table_scan_plan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AnyPlan.table_scan_plan)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::ExecPlan::TableScanPlan* temp = table_scan_plan_;
  table_scan_plan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableScanPlan* AnyPlan::_internal_mutable_table_scan_plan() {
  _has_bits_[0] |= 0x00000002u;
  if (table_scan_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::TableScanPlan>(GetArenaForAllocation());
    table_scan_plan_ = p;
  }
  return table_scan_plan_;
}
inline ::PolarXRPC::ExecPlan::TableScanPlan* AnyPlan::mutable_table_scan_plan() {
  ::PolarXRPC::ExecPlan::TableScanPlan* _msg = _internal_mutable_table_scan_plan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AnyPlan.table_scan_plan)
  return _msg;
}
inline void AnyPlan::set_allocated_table_scan_plan(::PolarXRPC::ExecPlan::TableScanPlan* table_scan_plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_scan_plan_;
  }
  if (table_scan_plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::TableScanPlan>::GetOwningArena(table_scan_plan);
    if (message_arena != submessage_arena) {
      table_scan_plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_scan_plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_scan_plan_ = table_scan_plan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AnyPlan.table_scan_plan)
}

// optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
inline bool AnyPlan::_internal_has_table_project() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || table_project_ != nullptr);
  return value;
}
inline bool AnyPlan::has_table_project() const {
  return _internal_has_table_project();
}
inline void AnyPlan::clear_table_project() {
  if (table_project_ != nullptr) table_project_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::PolarXRPC::ExecPlan::TableProject& AnyPlan::_internal_table_project() const {
  const ::PolarXRPC::ExecPlan::TableProject* p = table_project_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::TableProject&>(
      ::PolarXRPC::ExecPlan::_TableProject_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::TableProject& AnyPlan::table_project() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.table_project)
  return _internal_table_project();
}
inline void AnyPlan::unsafe_arena_set_allocated_table_project(
    ::PolarXRPC::ExecPlan::TableProject* table_project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_project_);
  }
  table_project_ = table_project;
  if (table_project) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.AnyPlan.table_project)
}
inline ::PolarXRPC::ExecPlan::TableProject* AnyPlan::release_table_project() {
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::ExecPlan::TableProject* temp = table_project_;
  table_project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableProject* AnyPlan::unsafe_arena_release_table_project() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AnyPlan.table_project)
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::ExecPlan::TableProject* temp = table_project_;
  table_project_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::TableProject* AnyPlan::_internal_mutable_table_project() {
  _has_bits_[0] |= 0x00000004u;
  if (table_project_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::TableProject>(GetArenaForAllocation());
    table_project_ = p;
  }
  return table_project_;
}
inline ::PolarXRPC::ExecPlan::TableProject* AnyPlan::mutable_table_project() {
  ::PolarXRPC::ExecPlan::TableProject* _msg = _internal_mutable_table_project();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AnyPlan.table_project)
  return _msg;
}
inline void AnyPlan::set_allocated_table_project(::PolarXRPC::ExecPlan::TableProject* table_project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_project_;
  }
  if (table_project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::TableProject>::GetOwningArena(table_project);
    if (message_arena != submessage_arena) {
      table_project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_project, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_project_ = table_project;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AnyPlan.table_project)
}

// optional .PolarXRPC.ExecPlan.Project project = 5;
inline bool AnyPlan::_internal_has_project() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || project_ != nullptr);
  return value;
}
inline bool AnyPlan::has_project() const {
  return _internal_has_project();
}
inline void AnyPlan::clear_project() {
  if (project_ != nullptr) project_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::PolarXRPC::ExecPlan::Project& AnyPlan::_internal_project() const {
  const ::PolarXRPC::ExecPlan::Project* p = project_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::Project&>(
      ::PolarXRPC::ExecPlan::_Project_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::Project& AnyPlan::project() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.project)
  return _internal_project();
}
inline void AnyPlan::unsafe_arena_set_allocated_project(
    ::PolarXRPC::ExecPlan::Project* project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  project_ = project;
  if (project) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.AnyPlan.project)
}
inline ::PolarXRPC::ExecPlan::Project* AnyPlan::release_project() {
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::Project* temp = project_;
  project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::Project* AnyPlan::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AnyPlan.project)
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::Project* temp = project_;
  project_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::Project* AnyPlan::_internal_mutable_project() {
  _has_bits_[0] |= 0x00000008u;
  if (project_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::Project>(GetArenaForAllocation());
    project_ = p;
  }
  return project_;
}
inline ::PolarXRPC::ExecPlan::Project* AnyPlan::mutable_project() {
  ::PolarXRPC::ExecPlan::Project* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AnyPlan.project)
  return _msg;
}
inline void AnyPlan::set_allocated_project(::PolarXRPC::ExecPlan::Project* project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete project_;
  }
  if (project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::Project>::GetOwningArena(project);
    if (message_arena != submessage_arena) {
      project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  project_ = project;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AnyPlan.project)
}

// optional .PolarXRPC.ExecPlan.Filter filter = 6;
inline bool AnyPlan::_internal_has_filter() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || filter_ != nullptr);
  return value;
}
inline bool AnyPlan::has_filter() const {
  return _internal_has_filter();
}
inline void AnyPlan::clear_filter() {
  if (filter_ != nullptr) filter_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::PolarXRPC::ExecPlan::Filter& AnyPlan::_internal_filter() const {
  const ::PolarXRPC::ExecPlan::Filter* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::Filter&>(
      ::PolarXRPC::ExecPlan::_Filter_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::Filter& AnyPlan::filter() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.filter)
  return _internal_filter();
}
inline void AnyPlan::unsafe_arena_set_allocated_filter(
    ::PolarXRPC::ExecPlan::Filter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.AnyPlan.filter)
}
inline ::PolarXRPC::ExecPlan::Filter* AnyPlan::release_filter() {
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::Filter* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::Filter* AnyPlan::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AnyPlan.filter)
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::Filter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::Filter* AnyPlan::_internal_mutable_filter() {
  _has_bits_[0] |= 0x00000010u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::Filter>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::PolarXRPC::ExecPlan::Filter* AnyPlan::mutable_filter() {
  ::PolarXRPC::ExecPlan::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AnyPlan.filter)
  return _msg;
}
inline void AnyPlan::set_allocated_filter(::PolarXRPC::ExecPlan::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::Filter>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AnyPlan.filter)
}

// optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
inline bool AnyPlan::_internal_has_range_scan() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || range_scan_ != nullptr);
  return value;
}
inline bool AnyPlan::has_range_scan() const {
  return _internal_has_range_scan();
}
inline void AnyPlan::clear_range_scan() {
  if (range_scan_ != nullptr) range_scan_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::PolarXRPC::ExecPlan::RangeScan& AnyPlan::_internal_range_scan() const {
  const ::PolarXRPC::ExecPlan::RangeScan* p = range_scan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::RangeScan&>(
      ::PolarXRPC::ExecPlan::_RangeScan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::RangeScan& AnyPlan::range_scan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.range_scan)
  return _internal_range_scan();
}
inline void AnyPlan::unsafe_arena_set_allocated_range_scan(
    ::PolarXRPC::ExecPlan::RangeScan* range_scan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_scan_);
  }
  range_scan_ = range_scan;
  if (range_scan) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.AnyPlan.range_scan)
}
inline ::PolarXRPC::ExecPlan::RangeScan* AnyPlan::release_range_scan() {
  _has_bits_[0] &= ~0x00000020u;
  ::PolarXRPC::ExecPlan::RangeScan* temp = range_scan_;
  range_scan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::RangeScan* AnyPlan::unsafe_arena_release_range_scan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AnyPlan.range_scan)
  _has_bits_[0] &= ~0x00000020u;
  ::PolarXRPC::ExecPlan::RangeScan* temp = range_scan_;
  range_scan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::RangeScan* AnyPlan::_internal_mutable_range_scan() {
  _has_bits_[0] |= 0x00000020u;
  if (range_scan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::RangeScan>(GetArenaForAllocation());
    range_scan_ = p;
  }
  return range_scan_;
}
inline ::PolarXRPC::ExecPlan::RangeScan* AnyPlan::mutable_range_scan() {
  ::PolarXRPC::ExecPlan::RangeScan* _msg = _internal_mutable_range_scan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AnyPlan.range_scan)
  return _msg;
}
inline void AnyPlan::set_allocated_range_scan(::PolarXRPC::ExecPlan::RangeScan* range_scan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete range_scan_;
  }
  if (range_scan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::RangeScan>::GetOwningArena(range_scan);
    if (message_arena != submessage_arena) {
      range_scan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range_scan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  range_scan_ = range_scan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AnyPlan.range_scan)
}

// optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
inline bool AnyPlan::_internal_has_aggr() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || aggr_ != nullptr);
  return value;
}
inline bool AnyPlan::has_aggr() const {
  return _internal_has_aggr();
}
inline void AnyPlan::clear_aggr() {
  if (aggr_ != nullptr) aggr_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::PolarXRPC::ExecPlan::Aggr& AnyPlan::_internal_aggr() const {
  const ::PolarXRPC::ExecPlan::Aggr* p = aggr_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::Aggr&>(
      ::PolarXRPC::ExecPlan::_Aggr_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::Aggr& AnyPlan::aggr() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.AnyPlan.aggr)
  return _internal_aggr();
}
inline void AnyPlan::unsafe_arena_set_allocated_aggr(
    ::PolarXRPC::ExecPlan::Aggr* aggr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aggr_);
  }
  aggr_ = aggr;
  if (aggr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.AnyPlan.aggr)
}
inline ::PolarXRPC::ExecPlan::Aggr* AnyPlan::release_aggr() {
  _has_bits_[0] &= ~0x00000040u;
  ::PolarXRPC::ExecPlan::Aggr* temp = aggr_;
  aggr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::Aggr* AnyPlan::unsafe_arena_release_aggr() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.AnyPlan.aggr)
  _has_bits_[0] &= ~0x00000040u;
  ::PolarXRPC::ExecPlan::Aggr* temp = aggr_;
  aggr_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::Aggr* AnyPlan::_internal_mutable_aggr() {
  _has_bits_[0] |= 0x00000040u;
  if (aggr_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::Aggr>(GetArenaForAllocation());
    aggr_ = p;
  }
  return aggr_;
}
inline ::PolarXRPC::ExecPlan::Aggr* AnyPlan::mutable_aggr() {
  ::PolarXRPC::ExecPlan::Aggr* _msg = _internal_mutable_aggr();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.AnyPlan.aggr)
  return _msg;
}
inline void AnyPlan::set_allocated_aggr(::PolarXRPC::ExecPlan::Aggr* aggr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete aggr_;
  }
  if (aggr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::Aggr>::GetOwningArena(aggr);
    if (message_arena != submessage_arena) {
      aggr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aggr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  aggr_ = aggr;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.AnyPlan.aggr)
}

// -------------------------------------------------------------------

// ExecPlan

// optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
inline bool ExecPlan::_internal_has_transaction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || transaction_ != nullptr);
  return value;
}
inline bool ExecPlan::has_transaction() const {
  return _internal_has_transaction();
}
inline void ExecPlan::clear_transaction() {
  if (transaction_ != nullptr) transaction_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::PolarXRPC::ExecPlan::Transaction& ExecPlan::_internal_transaction() const {
  const ::PolarXRPC::ExecPlan::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::Transaction&>(
      ::PolarXRPC::ExecPlan::_Transaction_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::Transaction& ExecPlan::transaction() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.transaction)
  return _internal_transaction();
}
inline void ExecPlan::unsafe_arena_set_allocated_transaction(
    ::PolarXRPC::ExecPlan::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.ExecPlan.transaction)
}
inline ::PolarXRPC::ExecPlan::Transaction* ExecPlan::release_transaction() {
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::Transaction* ExecPlan::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.ExecPlan.transaction)
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::ExecPlan::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::Transaction* ExecPlan::_internal_mutable_transaction() {
  _has_bits_[0] |= 0x00000008u;
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::PolarXRPC::ExecPlan::Transaction* ExecPlan::mutable_transaction() {
  ::PolarXRPC::ExecPlan::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.ExecPlan.transaction)
  return _msg;
}
inline void ExecPlan::set_allocated_transaction(::PolarXRPC::ExecPlan::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::Transaction>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.ExecPlan.transaction)
}

// optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
inline bool ExecPlan::_internal_has_plan() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || plan_ != nullptr);
  return value;
}
inline bool ExecPlan::has_plan() const {
  return _internal_has_plan();
}
inline void ExecPlan::clear_plan() {
  if (plan_ != nullptr) plan_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& ExecPlan::_internal_plan() const {
  const ::PolarXRPC::ExecPlan::AnyPlan* p = plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::ExecPlan::AnyPlan&>(
      ::PolarXRPC::ExecPlan::_AnyPlan_default_instance_);
}
inline const ::PolarXRPC::ExecPlan::AnyPlan& ExecPlan::plan() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.plan)
  return _internal_plan();
}
inline void ExecPlan::unsafe_arena_set_allocated_plan(
    ::PolarXRPC::ExecPlan::AnyPlan* plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  plan_ = plan;
  if (plan) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.ExecPlan.ExecPlan.plan)
}
inline ::PolarXRPC::ExecPlan::AnyPlan* ExecPlan::release_plan() {
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = plan_;
  plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* ExecPlan::unsafe_arena_release_plan() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.ExecPlan.plan)
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::ExecPlan::AnyPlan* temp = plan_;
  plan_ = nullptr;
  return temp;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* ExecPlan::_internal_mutable_plan() {
  _has_bits_[0] |= 0x00000010u;
  if (plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::ExecPlan::AnyPlan>(GetArenaForAllocation());
    plan_ = p;
  }
  return plan_;
}
inline ::PolarXRPC::ExecPlan::AnyPlan* ExecPlan::mutable_plan() {
  ::PolarXRPC::ExecPlan::AnyPlan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.ExecPlan.plan)
  return _msg;
}
inline void ExecPlan::set_allocated_plan(::PolarXRPC::ExecPlan::AnyPlan* plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete plan_;
  }
  if (plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::ExecPlan::AnyPlan>::GetOwningArena(plan);
    if (message_arena != submessage_arena) {
      plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  plan_ = plan;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.ExecPlan.plan)
}

// optional bytes plan_digest = 3;
inline bool ExecPlan::_internal_has_plan_digest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExecPlan::has_plan_digest() const {
  return _internal_has_plan_digest();
}
inline void ExecPlan::clear_plan_digest() {
  plan_digest_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExecPlan::plan_digest() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.plan_digest)
  return _internal_plan_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecPlan::set_plan_digest(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 plan_digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.plan_digest)
}
inline std::string* ExecPlan::mutable_plan_digest() {
  std::string* _s = _internal_mutable_plan_digest();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.ExecPlan.plan_digest)
  return _s;
}
inline const std::string& ExecPlan::_internal_plan_digest() const {
  return plan_digest_.Get();
}
inline void ExecPlan::_internal_set_plan_digest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  plan_digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecPlan::_internal_mutable_plan_digest() {
  _has_bits_[0] |= 0x00000001u;
  return plan_digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecPlan::release_plan_digest() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.ExecPlan.plan_digest)
  if (!_internal_has_plan_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = plan_digest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plan_digest_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plan_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecPlan::set_allocated_plan_digest(std::string* plan_digest) {
  if (plan_digest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  plan_digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plan_digest,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (plan_digest_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    plan_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.ExecPlan.plan_digest)
}

// repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
inline int ExecPlan::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ExecPlan::parameters_size() const {
  return _internal_parameters_size();
}
inline ::PolarXRPC::Datatypes::Scalar* ExecPlan::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.ExecPlan.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >*
ExecPlan::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.ExecPlan.parameters)
  return &parameters_;
}
inline const ::PolarXRPC::Datatypes::Scalar& ExecPlan::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::PolarXRPC::Datatypes::Scalar& ExecPlan::parameters(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.parameters)
  return _internal_parameters(index);
}
inline ::PolarXRPC::Datatypes::Scalar* ExecPlan::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::PolarXRPC::Datatypes::Scalar* ExecPlan::add_parameters() {
  ::PolarXRPC::Datatypes::Scalar* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.ExecPlan.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Scalar >&
ExecPlan::parameters() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.ExecPlan.parameters)
  return parameters_;
}

// repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
inline int ExecPlan::_internal_session_variables_size() const {
  return session_variables_.size();
}
inline int ExecPlan::session_variables_size() const {
  return _internal_session_variables_size();
}
inline ::PolarXRPC::Datatypes::SessionVariable* ExecPlan::mutable_session_variables(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.ExecPlan.session_variables)
  return session_variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >*
ExecPlan::mutable_session_variables() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.ExecPlan.ExecPlan.session_variables)
  return &session_variables_;
}
inline const ::PolarXRPC::Datatypes::SessionVariable& ExecPlan::_internal_session_variables(int index) const {
  return session_variables_.Get(index);
}
inline const ::PolarXRPC::Datatypes::SessionVariable& ExecPlan::session_variables(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.session_variables)
  return _internal_session_variables(index);
}
inline ::PolarXRPC::Datatypes::SessionVariable* ExecPlan::_internal_add_session_variables() {
  return session_variables_.Add();
}
inline ::PolarXRPC::Datatypes::SessionVariable* ExecPlan::add_session_variables() {
  ::PolarXRPC::Datatypes::SessionVariable* _add = _internal_add_session_variables();
  // @@protoc_insertion_point(field_add:PolarXRPC.ExecPlan.ExecPlan.session_variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >&
ExecPlan::session_variables() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.ExecPlan.ExecPlan.session_variables)
  return session_variables_;
}

// optional int32 token = 6;
inline bool ExecPlan::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExecPlan::has_token() const {
  return _internal_has_token();
}
inline void ExecPlan::clear_token() {
  token_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ExecPlan::_internal_token() const {
  return token_;
}
inline int32_t ExecPlan::token() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.token)
  return _internal_token();
}
inline void ExecPlan::_internal_set_token(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  token_ = value;
}
inline void ExecPlan::set_token(int32_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.token)
}

// optional bool reset_error = 7;
inline bool ExecPlan::_internal_has_reset_error() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExecPlan::has_reset_error() const {
  return _internal_has_reset_error();
}
inline void ExecPlan::clear_reset_error() {
  reset_error_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ExecPlan::_internal_reset_error() const {
  return reset_error_;
}
inline bool ExecPlan::reset_error() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.reset_error)
  return _internal_reset_error();
}
inline void ExecPlan::_internal_set_reset_error(bool value) {
  _has_bits_[0] |= 0x00000040u;
  reset_error_ = value;
}
inline void ExecPlan::set_reset_error(bool value) {
  _internal_set_reset_error(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.reset_error)
}

// optional bool compact_metadata = 8 [default = false];
inline bool ExecPlan::_internal_has_compact_metadata() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExecPlan::has_compact_metadata() const {
  return _internal_has_compact_metadata();
}
inline void ExecPlan::clear_compact_metadata() {
  compact_metadata_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ExecPlan::_internal_compact_metadata() const {
  return compact_metadata_;
}
inline bool ExecPlan::compact_metadata() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.compact_metadata)
  return _internal_compact_metadata();
}
inline void ExecPlan::_internal_set_compact_metadata(bool value) {
  _has_bits_[0] |= 0x00000080u;
  compact_metadata_ = value;
}
inline void ExecPlan::set_compact_metadata(bool value) {
  _internal_set_compact_metadata(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.compact_metadata)
}

// optional uint64 snapshot_seq = 9;
inline bool ExecPlan::_internal_has_snapshot_seq() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ExecPlan::has_snapshot_seq() const {
  return _internal_has_snapshot_seq();
}
inline void ExecPlan::clear_snapshot_seq() {
  snapshot_seq_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline uint64_t ExecPlan::_internal_snapshot_seq() const {
  return snapshot_seq_;
}
inline uint64_t ExecPlan::snapshot_seq() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.snapshot_seq)
  return _internal_snapshot_seq();
}
inline void ExecPlan::_internal_set_snapshot_seq(uint64_t value) {
  _has_bits_[0] |= 0x00000400u;
  snapshot_seq_ = value;
}
inline void ExecPlan::set_snapshot_seq(uint64_t value) {
  _internal_set_snapshot_seq(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.snapshot_seq)
}

// optional uint64 commit_seq = 10;
inline bool ExecPlan::_internal_has_commit_seq() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ExecPlan::has_commit_seq() const {
  return _internal_has_commit_seq();
}
inline void ExecPlan::clear_commit_seq() {
  commit_seq_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000800u;
}
inline uint64_t ExecPlan::_internal_commit_seq() const {
  return commit_seq_;
}
inline uint64_t ExecPlan::commit_seq() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.commit_seq)
  return _internal_commit_seq();
}
inline void ExecPlan::_internal_set_commit_seq(uint64_t value) {
  _has_bits_[0] |= 0x00000800u;
  commit_seq_ = value;
}
inline void ExecPlan::set_commit_seq(uint64_t value) {
  _internal_set_commit_seq(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.commit_seq)
}

// optional bool use_cts_transaction = 12;
inline bool ExecPlan::_internal_has_use_cts_transaction() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExecPlan::has_use_cts_transaction() const {
  return _internal_has_use_cts_transaction();
}
inline void ExecPlan::clear_use_cts_transaction() {
  use_cts_transaction_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ExecPlan::_internal_use_cts_transaction() const {
  return use_cts_transaction_;
}
inline bool ExecPlan::use_cts_transaction() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.use_cts_transaction)
  return _internal_use_cts_transaction();
}
inline void ExecPlan::_internal_set_use_cts_transaction(bool value) {
  _has_bits_[0] |= 0x00000100u;
  use_cts_transaction_ = value;
}
inline void ExecPlan::set_use_cts_transaction(bool value) {
  _internal_set_use_cts_transaction(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.use_cts_transaction)
}

// optional bool chunk_result = 11 [default = false];
inline bool ExecPlan::_internal_has_chunk_result() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ExecPlan::has_chunk_result() const {
  return _internal_has_chunk_result();
}
inline void ExecPlan::clear_chunk_result() {
  chunk_result_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ExecPlan::_internal_chunk_result() const {
  return chunk_result_;
}
inline bool ExecPlan::chunk_result() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.chunk_result)
  return _internal_chunk_result();
}
inline void ExecPlan::_internal_set_chunk_result(bool value) {
  _has_bits_[0] |= 0x00000200u;
  chunk_result_ = value;
}
inline void ExecPlan::set_chunk_result(bool value) {
  _internal_set_chunk_result(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.chunk_result)
}

// optional bool feed_back = 13 [default = false];
inline bool ExecPlan::_internal_has_feed_back() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ExecPlan::has_feed_back() const {
  return _internal_has_feed_back();
}
inline void ExecPlan::clear_feed_back() {
  feed_back_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool ExecPlan::_internal_feed_back() const {
  return feed_back_;
}
inline bool ExecPlan::feed_back() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.feed_back)
  return _internal_feed_back();
}
inline void ExecPlan::_internal_set_feed_back(bool value) {
  _has_bits_[0] |= 0x00002000u;
  feed_back_ = value;
}
inline void ExecPlan::set_feed_back(bool value) {
  _internal_set_feed_back(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.feed_back)
}

// optional bytes trace_id = 14;
inline bool ExecPlan::_internal_has_trace_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExecPlan::has_trace_id() const {
  return _internal_has_trace_id();
}
inline void ExecPlan::clear_trace_id() {
  trace_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExecPlan::trace_id() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecPlan::set_trace_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 trace_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.trace_id)
}
inline std::string* ExecPlan::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.ExecPlan.trace_id)
  return _s;
}
inline const std::string& ExecPlan::_internal_trace_id() const {
  return trace_id_.Get();
}
inline void ExecPlan::_internal_set_trace_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecPlan::_internal_mutable_trace_id() {
  _has_bits_[0] |= 0x00000002u;
  return trace_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecPlan::release_trace_id() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.ExecPlan.trace_id)
  if (!_internal_has_trace_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = trace_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trace_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecPlan::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  trace_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trace_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trace_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.ExecPlan.trace_id)
}

// optional bytes audit_str = 15;
inline bool ExecPlan::_internal_has_audit_str() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExecPlan::has_audit_str() const {
  return _internal_has_audit_str();
}
inline void ExecPlan::clear_audit_str() {
  audit_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ExecPlan::audit_str() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.audit_str)
  return _internal_audit_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecPlan::set_audit_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 audit_str_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.audit_str)
}
inline std::string* ExecPlan::mutable_audit_str() {
  std::string* _s = _internal_mutable_audit_str();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.ExecPlan.ExecPlan.audit_str)
  return _s;
}
inline const std::string& ExecPlan::_internal_audit_str() const {
  return audit_str_.Get();
}
inline void ExecPlan::_internal_set_audit_str(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  audit_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecPlan::_internal_mutable_audit_str() {
  _has_bits_[0] |= 0x00000004u;
  return audit_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecPlan::release_audit_str() {
  // @@protoc_insertion_point(field_release:PolarXRPC.ExecPlan.ExecPlan.audit_str)
  if (!_internal_has_audit_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = audit_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (audit_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    audit_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecPlan::set_allocated_audit_str(std::string* audit_str) {
  if (audit_str != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  audit_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audit_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (audit_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    audit_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.ExecPlan.ExecPlan.audit_str)
}

// optional uint64 capabilities = 16;
inline bool ExecPlan::_internal_has_capabilities() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ExecPlan::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void ExecPlan::clear_capabilities() {
  capabilities_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline uint64_t ExecPlan::_internal_capabilities() const {
  return capabilities_;
}
inline uint64_t ExecPlan::capabilities() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.capabilities)
  return _internal_capabilities();
}
inline void ExecPlan::_internal_set_capabilities(uint64_t value) {
  _has_bits_[0] |= 0x00001000u;
  capabilities_ = value;
}
inline void ExecPlan::set_capabilities(uint64_t value) {
  _internal_set_capabilities(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.capabilities)
}

// optional bool mark_distributed = 17;
inline bool ExecPlan::_internal_has_mark_distributed() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ExecPlan::has_mark_distributed() const {
  return _internal_has_mark_distributed();
}
inline void ExecPlan::clear_mark_distributed() {
  mark_distributed_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ExecPlan::_internal_mark_distributed() const {
  return mark_distributed_;
}
inline bool ExecPlan::mark_distributed() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.mark_distributed)
  return _internal_mark_distributed();
}
inline void ExecPlan::_internal_set_mark_distributed(bool value) {
  _has_bits_[0] |= 0x00004000u;
  mark_distributed_ = value;
}
inline void ExecPlan::set_mark_distributed(bool value) {
  _internal_set_mark_distributed(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.mark_distributed)
}

// optional bool query_via_flashback_area = 18;
inline bool ExecPlan::_internal_has_query_via_flashback_area() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ExecPlan::has_query_via_flashback_area() const {
  return _internal_has_query_via_flashback_area();
}
inline void ExecPlan::clear_query_via_flashback_area() {
  query_via_flashback_area_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool ExecPlan::_internal_query_via_flashback_area() const {
  return query_via_flashback_area_;
}
inline bool ExecPlan::query_via_flashback_area() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.ExecPlan.ExecPlan.query_via_flashback_area)
  return _internal_query_via_flashback_area();
}
inline void ExecPlan::_internal_set_query_via_flashback_area(bool value) {
  _has_bits_[0] |= 0x00008000u;
  query_via_flashback_area_ = value;
}
inline void ExecPlan::set_query_via_flashback_area(bool value) {
  _internal_set_query_via_flashback_area(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.ExecPlan.ExecPlan.query_via_flashback_area)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ExecPlan
}  // namespace PolarXRPC

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PolarXRPC::ExecPlan::AutoSp_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PolarXRPC::ExecPlan::AutoSp_Operation>() {
  return ::PolarXRPC::ExecPlan::AutoSp_Operation_descriptor();
}
template <> struct is_proto_enum< ::PolarXRPC::ExecPlan::Aggr_AggrType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PolarXRPC::ExecPlan::Aggr_AggrType>() {
  return ::PolarXRPC::ExecPlan::Aggr_AggrType_descriptor();
}
template <> struct is_proto_enum< ::PolarXRPC::ExecPlan::AnyPlan_PlanType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PolarXRPC::ExecPlan::AnyPlan_PlanType>() {
  return ::PolarXRPC::ExecPlan::AnyPlan_PlanType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_polarx_5fexec_5fplan_2eproto
