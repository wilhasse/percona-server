// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polarx_exec_plan.proto

#include "polarx_exec_plan.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace PolarXRPC {
namespace ExecPlan {
constexpr NewSession::NewSession(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct NewSessionDefaultTypeInternal {
  constexpr NewSessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NewSessionDefaultTypeInternal() {}
  union {
    NewSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NewSessionDefaultTypeInternal _NewSession_default_instance_;
constexpr CloseSession::CloseSession(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CloseSessionDefaultTypeInternal {
  constexpr CloseSessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CloseSessionDefaultTypeInternal() {}
  union {
    CloseSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CloseSessionDefaultTypeInternal _CloseSession_default_instance_;
constexpr EnumSession::EnumSession(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct EnumSessionDefaultTypeInternal {
  constexpr EnumSessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EnumSessionDefaultTypeInternal() {}
  union {
    EnumSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EnumSessionDefaultTypeInternal _EnumSession_default_instance_;
constexpr SessionInfo::SessionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SessionInfoDefaultTypeInternal {
  constexpr SessionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SessionInfoDefaultTypeInternal() {}
  union {
    SessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SessionInfoDefaultTypeInternal _SessionInfo_default_instance_;
constexpr SessionInfos::SessionInfos(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessions_(){}
struct SessionInfosDefaultTypeInternal {
  constexpr SessionInfosDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SessionInfosDefaultTypeInternal() {}
  union {
    SessionInfos _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SessionInfosDefaultTypeInternal _SessionInfos_default_instance_;
constexpr TableInfo::TableInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(nullptr)
  , schema_name_(nullptr)
  , version_(int64_t{0}){}
struct TableInfoDefaultTypeInternal {
  constexpr TableInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TableInfoDefaultTypeInternal() {}
  union {
    TableInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TableInfoDefaultTypeInternal _TableInfo_default_instance_;
constexpr IndexInfo::IndexInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(nullptr)
  , use_parts_(0){}
struct IndexInfoDefaultTypeInternal {
  constexpr IndexInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IndexInfoDefaultTypeInternal() {}
  union {
    IndexInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IndexInfoDefaultTypeInternal _IndexInfo_default_instance_;
constexpr Transaction::Transaction(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TransactionDefaultTypeInternal {
  constexpr TransactionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransactionDefaultTypeInternal() {}
  union {
    Transaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransactionDefaultTypeInternal _Transaction_default_instance_;
constexpr BloomFilter::BloomFilter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : strategy_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , total_bits_(0u)
  , number_hash_(0u){}
struct BloomFilterDefaultTypeInternal {
  constexpr BloomFilterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BloomFilterDefaultTypeInternal() {}
  union {
    BloomFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BloomFilterDefaultTypeInternal _BloomFilter_default_instance_;
constexpr GetTSO::GetTSO(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : leader_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , batch_count_(0){}
struct GetTSODefaultTypeInternal {
  constexpr GetTSODefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetTSODefaultTypeInternal() {}
  union {
    GetTSO _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetTSODefaultTypeInternal _GetTSO_default_instance_;
constexpr ResultTSO::ResultTSO(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ts_(uint64_t{0u})
  , error_no_(0){}
struct ResultTSODefaultTypeInternal {
  constexpr ResultTSODefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ResultTSODefaultTypeInternal() {}
  union {
    ResultTSO _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ResultTSODefaultTypeInternal _ResultTSO_default_instance_;
constexpr AutoSp::AutoSp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sp_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , op_(0)

  , reset_error_(false){}
struct AutoSpDefaultTypeInternal {
  constexpr AutoSpDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AutoSpDefaultTypeInternal() {}
  union {
    AutoSp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AutoSpDefaultTypeInternal _AutoSp_default_instance_;
constexpr KeyExpr::KeyExpr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : field_(nullptr)
  , value_(nullptr){}
struct KeyExprDefaultTypeInternal {
  constexpr KeyExprDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyExprDefaultTypeInternal() {}
  union {
    KeyExpr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyExprDefaultTypeInternal _KeyExpr_default_instance_;
constexpr GetExpr::GetExpr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keys_(){}
struct GetExprDefaultTypeInternal {
  constexpr GetExprDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetExprDefaultTypeInternal() {}
  union {
    GetExpr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetExprDefaultTypeInternal _GetExpr_default_instance_;
constexpr GetPlan::GetPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keys_()
  , table_info_(nullptr)
  , index_info_(nullptr){}
struct GetPlanDefaultTypeInternal {
  constexpr GetPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetPlanDefaultTypeInternal() {}
  union {
    GetPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetPlanDefaultTypeInternal _GetPlan_default_instance_;
constexpr TableScanPlan::TableScanPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : table_info_(nullptr)
  , index_info_(nullptr)
  , reverse_(false){}
struct TableScanPlanDefaultTypeInternal {
  constexpr TableScanPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TableScanPlanDefaultTypeInternal() {}
  union {
    TableScanPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TableScanPlanDefaultTypeInternal _TableScanPlan_default_instance_;
constexpr KeyOnlyRangeScan::KeyOnlyRangeScan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : snapshot_(nullptr)
  , table_info_(nullptr)
  , index_info_(nullptr)
  , key_(nullptr)
  , end_key_(nullptr)
  , reverse_(false)
  , flag_(int64_t{0}){}
struct KeyOnlyRangeScanDefaultTypeInternal {
  constexpr KeyOnlyRangeScanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyOnlyRangeScanDefaultTypeInternal() {}
  union {
    KeyOnlyRangeScan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyOnlyRangeScanDefaultTypeInternal _KeyOnlyRangeScan_default_instance_;
constexpr RangeScan::RangeScan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : snapshot_(nullptr)
  , table_info_(nullptr)
  , index_info_(nullptr)
  , key_(nullptr)
  , end_key_(nullptr)
  , reverse_(false)
  , flag_(int64_t{0}){}
struct RangeScanDefaultTypeInternal {
  constexpr RangeScanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RangeScanDefaultTypeInternal() {}
  union {
    RangeScan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RangeScanDefaultTypeInternal _RangeScan_default_instance_;
constexpr TableProject::TableProject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fields_()
  , sub_read_plan_(nullptr){}
struct TableProjectDefaultTypeInternal {
  constexpr TableProjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TableProjectDefaultTypeInternal() {}
  union {
    TableProject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TableProjectDefaultTypeInternal _TableProject_default_instance_;
constexpr Project::Project(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fields_()
  , exprs_()
  , sub_read_plan_(nullptr){}
struct ProjectDefaultTypeInternal {
  constexpr ProjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ProjectDefaultTypeInternal() {}
  union {
    Project _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ProjectDefaultTypeInternal _Project_default_instance_;
constexpr Filter::Filter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sub_read_plan_(nullptr)
  , expr_(nullptr){}
struct FilterDefaultTypeInternal {
  constexpr FilterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FilterDefaultTypeInternal() {}
  union {
    Filter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FilterDefaultTypeInternal _Filter_default_instance_;
constexpr Aggr::Aggr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sub_read_plan_(nullptr)
  , field_(nullptr)
  , expr_(nullptr)
  , type_(1)
{}
struct AggrDefaultTypeInternal {
  constexpr AggrDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AggrDefaultTypeInternal() {}
  union {
    Aggr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AggrDefaultTypeInternal _Aggr_default_instance_;
constexpr AnyPlan::AnyPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : get_plan_(nullptr)
  , table_scan_plan_(nullptr)
  , table_project_(nullptr)
  , project_(nullptr)
  , filter_(nullptr)
  , range_scan_(nullptr)
  , aggr_(nullptr)
  , plan_type_(1)
{}
struct AnyPlanDefaultTypeInternal {
  constexpr AnyPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnyPlanDefaultTypeInternal() {}
  union {
    AnyPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnyPlanDefaultTypeInternal _AnyPlan_default_instance_;
constexpr ExecPlan::ExecPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parameters_()
  , session_variables_()
  , plan_digest_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , trace_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , audit_str_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , transaction_(nullptr)
  , plan_(nullptr)
  , token_(0)
  , reset_error_(false)
  , compact_metadata_(false)
  , use_cts_transaction_(false)
  , chunk_result_(false)
  , snapshot_seq_(uint64_t{0u})
  , commit_seq_(uint64_t{0u})
  , capabilities_(uint64_t{0u})
  , feed_back_(false)
  , mark_distributed_(false)
  , query_via_flashback_area_(false){}
struct ExecPlanDefaultTypeInternal {
  constexpr ExecPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExecPlanDefaultTypeInternal() {}
  union {
    ExecPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExecPlanDefaultTypeInternal _ExecPlan_default_instance_;
}  // namespace ExecPlan
}  // namespace PolarXRPC
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_polarx_5fexec_5fplan_2eproto[24];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_polarx_5fexec_5fplan_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_polarx_5fexec_5fplan_2eproto = nullptr;

const uint32_t TableStruct_polarx_5fexec_5fplan_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::NewSession, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::CloseSession, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::EnumSession, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::SessionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::SessionInfos, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::SessionInfos, sessions_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableInfo, version_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableInfo, name_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableInfo, schema_name_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::IndexInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::IndexInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::IndexInfo, name_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::IndexInfo, use_parts_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Transaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::BloomFilter, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::BloomFilter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::BloomFilter, total_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::BloomFilter, number_hash_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::BloomFilter, strategy_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::BloomFilter, data_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetTSO, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetTSO, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetTSO, leader_name_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetTSO, batch_count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ResultTSO, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ResultTSO, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ResultTSO, error_no_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ResultTSO, ts_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AutoSp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AutoSp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AutoSp, op_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AutoSp, sp_name_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AutoSp, reset_error_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyExpr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyExpr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyExpr, field_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyExpr, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetExpr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetExpr, keys_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetPlan, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetPlan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetPlan, table_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetPlan, index_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::GetPlan, keys_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableScanPlan, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableScanPlan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableScanPlan, table_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableScanPlan, index_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableScanPlan, reverse_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, snapshot_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, table_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, index_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, key_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, end_key_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, reverse_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::KeyOnlyRangeScan, flag_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, snapshot_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, table_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, index_info_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, key_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, end_key_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, reverse_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::RangeScan, flag_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableProject, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableProject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableProject, sub_read_plan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::TableProject, fields_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Project, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Project, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Project, sub_read_plan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Project, fields_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Project, exprs_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Filter, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Filter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Filter, sub_read_plan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Filter, expr_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Aggr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Aggr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Aggr, sub_read_plan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Aggr, type_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Aggr, field_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::Aggr, expr_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, plan_type_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, get_plan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, table_scan_plan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, table_project_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, project_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, filter_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, range_scan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::AnyPlan, aggr_),
  7,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, transaction_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, plan_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, plan_digest_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, parameters_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, session_variables_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, token_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, reset_error_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, compact_metadata_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, snapshot_seq_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, commit_seq_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, use_cts_transaction_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, chunk_result_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, feed_back_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, trace_id_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, audit_str_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, capabilities_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, mark_distributed_),
  PROTOBUF_FIELD_OFFSET(::PolarXRPC::ExecPlan::ExecPlan, query_via_flashback_area_),
  3,
  4,
  0,
  ~0u,
  ~0u,
  5,
  6,
  7,
  10,
  11,
  8,
  9,
  13,
  1,
  2,
  12,
  14,
  15,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::PolarXRPC::ExecPlan::NewSession)},
  { 6, -1, -1, sizeof(::PolarXRPC::ExecPlan::CloseSession)},
  { 12, -1, -1, sizeof(::PolarXRPC::ExecPlan::EnumSession)},
  { 18, -1, -1, sizeof(::PolarXRPC::ExecPlan::SessionInfo)},
  { 24, -1, -1, sizeof(::PolarXRPC::ExecPlan::SessionInfos)},
  { 31, 40, -1, sizeof(::PolarXRPC::ExecPlan::TableInfo)},
  { 43, 51, -1, sizeof(::PolarXRPC::ExecPlan::IndexInfo)},
  { 53, -1, -1, sizeof(::PolarXRPC::ExecPlan::Transaction)},
  { 59, 69, -1, sizeof(::PolarXRPC::ExecPlan::BloomFilter)},
  { 73, 81, -1, sizeof(::PolarXRPC::ExecPlan::GetTSO)},
  { 83, 91, -1, sizeof(::PolarXRPC::ExecPlan::ResultTSO)},
  { 93, 102, -1, sizeof(::PolarXRPC::ExecPlan::AutoSp)},
  { 105, 113, -1, sizeof(::PolarXRPC::ExecPlan::KeyExpr)},
  { 115, -1, -1, sizeof(::PolarXRPC::ExecPlan::GetExpr)},
  { 122, 131, -1, sizeof(::PolarXRPC::ExecPlan::GetPlan)},
  { 134, 143, -1, sizeof(::PolarXRPC::ExecPlan::TableScanPlan)},
  { 146, 159, -1, sizeof(::PolarXRPC::ExecPlan::KeyOnlyRangeScan)},
  { 166, 179, -1, sizeof(::PolarXRPC::ExecPlan::RangeScan)},
  { 186, 194, -1, sizeof(::PolarXRPC::ExecPlan::TableProject)},
  { 196, 205, -1, sizeof(::PolarXRPC::ExecPlan::Project)},
  { 208, 216, -1, sizeof(::PolarXRPC::ExecPlan::Filter)},
  { 218, 228, -1, sizeof(::PolarXRPC::ExecPlan::Aggr)},
  { 232, 246, -1, sizeof(::PolarXRPC::ExecPlan::AnyPlan)},
  { 254, 278, -1, sizeof(::PolarXRPC::ExecPlan::ExecPlan)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_NewSession_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_CloseSession_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_EnumSession_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_SessionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_SessionInfos_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_TableInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_IndexInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_Transaction_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_BloomFilter_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_GetTSO_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_ResultTSO_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_AutoSp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_KeyExpr_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_GetExpr_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_GetPlan_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_TableScanPlan_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_KeyOnlyRangeScan_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_RangeScan_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_TableProject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_Project_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_Filter_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_Aggr_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_AnyPlan_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::PolarXRPC::ExecPlan::_ExecPlan_default_instance_),
};

const char descriptor_table_protodef_polarx_5fexec_5fplan_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026polarx_exec_plan.proto\022\022PolarXRPC.Exec"
  "Plan\032\021polarx_expr.proto\032\026polarx_datatype"
  "s.proto\"\014\n\nNewSession\"\016\n\014CloseSession\"\r\n"
  "\013EnumSession\"\r\n\013SessionInfo\"A\n\014SessionIn"
  "fos\0221\n\010sessions\030\001 \003(\0132\037.PolarXRPC.ExecPl"
  "an.SessionInfo\"y\n\tTableInfo\022\017\n\007version\030\001"
  " \001(\003\022)\n\004name\030\002 \002(\0132\033.PolarXRPC.Datatypes"
  ".Scalar\0220\n\013schema_name\030\003 \001(\0132\033.PolarXRPC"
  ".Datatypes.Scalar\"I\n\tIndexInfo\022)\n\004name\030\001"
  " \002(\0132\033.PolarXRPC.Datatypes.Scalar\022\021\n\tuse"
  "_parts\030\002 \001(\005\"\r\n\013Transaction\"V\n\013BloomFilt"
  "er\022\022\n\ntotal_bits\030\001 \002(\r\022\023\n\013number_hash\030\002 "
  "\002(\r\022\020\n\010strategy\030\003 \002(\014\022\014\n\004data\030\004 \002(\014\"2\n\006G"
  "etTSO\022\023\n\013leader_name\030\001 \002(\014\022\023\n\013batch_coun"
  "t\030\002 \002(\005\")\n\tResultTSO\022\020\n\010error_no\030\001 \002(\005\022\n"
  "\n\002ts\030\002 \002(\004\"\221\001\n\006AutoSp\0220\n\002op\030\001 \002(\0162$.Pola"
  "rXRPC.ExecPlan.AutoSp.Operation\022\017\n\007sp_na"
  "me\030\002 \002(\014\022\023\n\013reset_error\030\003 \001(\010\"/\n\tOperati"
  "on\022\007\n\003SET\020\000\022\013\n\007RELEASE\020\001\022\014\n\010ROLLBACK\020\002\"a"
  "\n\007KeyExpr\022*\n\005field\030\001 \002(\0132\033.PolarXRPC.Dat"
  "atypes.Scalar\022*\n\005value\030\002 \002(\0132\033.PolarXRPC"
  ".Datatypes.Scalar\"4\n\007GetExpr\022)\n\004keys\030\001 \003"
  "(\0132\033.PolarXRPC.ExecPlan.KeyExpr\"\232\001\n\007GetP"
  "lan\0221\n\ntable_info\030\001 \002(\0132\035.PolarXRPC.Exec"
  "Plan.TableInfo\0221\n\nindex_info\030\002 \001(\0132\035.Pol"
  "arXRPC.ExecPlan.IndexInfo\022)\n\004keys\030\003 \003(\0132"
  "\033.PolarXRPC.ExecPlan.GetExpr\"\206\001\n\rTableSc"
  "anPlan\0221\n\ntable_info\030\001 \002(\0132\035.PolarXRPC.E"
  "xecPlan.TableInfo\0221\n\nindex_info\030\002 \001(\0132\035."
  "PolarXRPC.ExecPlan.IndexInfo\022\017\n\007reverse\030"
  "\003 \001(\010\"\242\002\n\020KeyOnlyRangeScan\0221\n\010snapshot\030\001"
  " \001(\0132\037.PolarXRPC.ExecPlan.Transaction\0221\n"
  "\ntable_info\030\003 \001(\0132\035.PolarXRPC.ExecPlan.T"
  "ableInfo\0221\n\nindex_info\030\004 \001(\0132\035.PolarXRPC"
  ".ExecPlan.IndexInfo\022(\n\003key\030\005 \001(\0132\033.Polar"
  "XRPC.ExecPlan.GetExpr\022,\n\007end_key\030\006 \001(\0132\033"
  ".PolarXRPC.ExecPlan.GetExpr\022\017\n\007reverse\030\010"
  " \001(\010\022\014\n\004flag\030\t \001(\003\"\233\002\n\tRangeScan\0221\n\010snap"
  "shot\030\001 \001(\0132\037.PolarXRPC.ExecPlan.Transact"
  "ion\0221\n\ntable_info\030\003 \001(\0132\035.PolarXRPC.Exec"
  "Plan.TableInfo\0221\n\nindex_info\030\004 \001(\0132\035.Pol"
  "arXRPC.ExecPlan.IndexInfo\022(\n\003key\030\005 \001(\0132\033"
  ".PolarXRPC.ExecPlan.GetExpr\022,\n\007end_key\030\006"
  " \001(\0132\033.PolarXRPC.ExecPlan.GetExpr\022\017\n\007rev"
  "erse\030\010 \001(\010\022\014\n\004flag\030\t \001(\003\"o\n\014TableProject"
  "\0222\n\rsub_read_plan\030\001 \002(\0132\033.PolarXRPC.Exec"
  "Plan.AnyPlan\022+\n\006fields\030\002 \003(\0132\033.PolarXRPC"
  ".Datatypes.Scalar\"\217\001\n\007Project\0222\n\rsub_rea"
  "d_plan\030\001 \002(\0132\033.PolarXRPC.ExecPlan.AnyPla"
  "n\022+\n\006fields\030\002 \003(\0132\033.PolarXRPC.Datatypes."
  "Scalar\022#\n\005exprs\030\003 \003(\0132\024.PolarXRPC.Expr.E"
  "xpr\"`\n\006Filter\0222\n\rsub_read_plan\030\001 \002(\0132\033.P"
  "olarXRPC.ExecPlan.AnyPlan\022\"\n\004expr\030\002 \002(\0132"
  "\024.PolarXRPC.Expr.Expr\"\327\002\n\004Aggr\0222\n\rsub_re"
  "ad_plan\030\001 \002(\0132\033.PolarXRPC.ExecPlan.AnyPl"
  "an\022/\n\004type\030\002 \002(\0162!.PolarXRPC.ExecPlan.Ag"
  "gr.AggrType\022*\n\005field\030\003 \002(\0132\033.PolarXRPC.D"
  "atatypes.Scalar\022\"\n\004expr\030\004 \002(\0132\024.PolarXRP"
  "C.Expr.Expr\"\231\001\n\010AggrType\022\016\n\nCOUNT_FUNC\020\001"
  "\022\027\n\023COUNT_DISTINCT_FUNC\020\002\022\014\n\010SUM_FUNC\020\003\022"
  "\025\n\021SUM_DISTINCT_FUNC\020\004\022\014\n\010AVG_FUNC\020\005\022\025\n\021"
  "AVG_DISTINCT_FUNC\020\006\022\014\n\010MIN_FUNC\020\007\022\014\n\010MAX"
  "_FUNC\020\010\"\206\004\n\007AnyPlan\0227\n\tplan_type\030\001 \002(\0162$"
  ".PolarXRPC.ExecPlan.AnyPlan.PlanType\022-\n\010"
  "get_plan\030\002 \001(\0132\033.PolarXRPC.ExecPlan.GetP"
  "lan\022:\n\017table_scan_plan\030\003 \001(\0132!.PolarXRPC"
  ".ExecPlan.TableScanPlan\0227\n\rtable_project"
  "\030\004 \001(\0132 .PolarXRPC.ExecPlan.TableProject"
  "\022,\n\007project\030\005 \001(\0132\033.PolarXRPC.ExecPlan.P"
  "roject\022*\n\006filter\030\006 \001(\0132\032.PolarXRPC.ExecP"
  "lan.Filter\0221\n\nrange_scan\030\010 \001(\0132\035.PolarXR"
  "PC.ExecPlan.RangeScan\022&\n\004aggr\030\t \001(\0132\030.Po"
  "larXRPC.ExecPlan.Aggr\"i\n\010PlanType\022\007\n\003GET"
  "\020\001\022\016\n\nTABLE_SCAN\020\002\022\021\n\rTABLE_PROJECT\020\003\022\013\n"
  "\007PROJECT\020\004\022\n\n\006FILTER\020\005\022\016\n\nRANGE_SCAN\020\010\022\010"
  "\n\004AGGR\020\t\"\254\004\n\010ExecPlan\0224\n\013transaction\030\001 \001"
  "(\0132\037.PolarXRPC.ExecPlan.Transaction\022)\n\004p"
  "lan\030\002 \001(\0132\033.PolarXRPC.ExecPlan.AnyPlan\022\023"
  "\n\013plan_digest\030\003 \001(\014\022/\n\nparameters\030\004 \003(\0132"
  "\033.PolarXRPC.Datatypes.Scalar\022\?\n\021session_"
  "variables\030\005 \003(\0132$.PolarXRPC.Datatypes.Se"
  "ssionVariable\022\r\n\005token\030\006 \001(\005\022\023\n\013reset_er"
  "ror\030\007 \001(\010\022\037\n\020compact_metadata\030\010 \001(\010:\005fal"
  "se\022\024\n\014snapshot_seq\030\t \001(\004\022\022\n\ncommit_seq\030\n"
  " \001(\004\022\033\n\023use_cts_transaction\030\014 \001(\010\022\033\n\014chu"
  "nk_result\030\013 \001(\010:\005false\022\030\n\tfeed_back\030\r \001("
  "\010:\005false\022\020\n\010trace_id\030\016 \001(\014\022\021\n\taudit_str\030"
  "\017 \001(\014\022\024\n\014capabilities\030\020 \001(\004\022\030\n\020mark_dist"
  "ributed\030\021 \001(\010\022 \n\030query_via_flashback_are"
  "a\030\022 \001(\010B\031\n\027com.mysql.cj.x.protobuf"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_polarx_5fexec_5fplan_2eproto_deps[2] = {
  &::descriptor_table_polarx_5fdatatypes_2eproto,
  &::descriptor_table_polarx_5fexpr_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_polarx_5fexec_5fplan_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_polarx_5fexec_5fplan_2eproto = {
  false, false, 3594, descriptor_table_protodef_polarx_5fexec_5fplan_2eproto, "polarx_exec_plan.proto", 
  &descriptor_table_polarx_5fexec_5fplan_2eproto_once, descriptor_table_polarx_5fexec_5fplan_2eproto_deps, 2, 24,
  schemas, file_default_instances, TableStruct_polarx_5fexec_5fplan_2eproto::offsets,
  file_level_metadata_polarx_5fexec_5fplan_2eproto, file_level_enum_descriptors_polarx_5fexec_5fplan_2eproto, file_level_service_descriptors_polarx_5fexec_5fplan_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_polarx_5fexec_5fplan_2eproto_getter() {
  return &descriptor_table_polarx_5fexec_5fplan_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_polarx_5fexec_5fplan_2eproto(&descriptor_table_polarx_5fexec_5fplan_2eproto);
namespace PolarXRPC {
namespace ExecPlan {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AutoSp_Operation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_polarx_5fexec_5fplan_2eproto);
  return file_level_enum_descriptors_polarx_5fexec_5fplan_2eproto[0];
}
bool AutoSp_Operation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutoSp_Operation AutoSp::SET;
constexpr AutoSp_Operation AutoSp::RELEASE;
constexpr AutoSp_Operation AutoSp::ROLLBACK;
constexpr AutoSp_Operation AutoSp::Operation_MIN;
constexpr AutoSp_Operation AutoSp::Operation_MAX;
constexpr int AutoSp::Operation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Aggr_AggrType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_polarx_5fexec_5fplan_2eproto);
  return file_level_enum_descriptors_polarx_5fexec_5fplan_2eproto[1];
}
bool Aggr_AggrType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Aggr_AggrType Aggr::COUNT_FUNC;
constexpr Aggr_AggrType Aggr::COUNT_DISTINCT_FUNC;
constexpr Aggr_AggrType Aggr::SUM_FUNC;
constexpr Aggr_AggrType Aggr::SUM_DISTINCT_FUNC;
constexpr Aggr_AggrType Aggr::AVG_FUNC;
constexpr Aggr_AggrType Aggr::AVG_DISTINCT_FUNC;
constexpr Aggr_AggrType Aggr::MIN_FUNC;
constexpr Aggr_AggrType Aggr::MAX_FUNC;
constexpr Aggr_AggrType Aggr::AggrType_MIN;
constexpr Aggr_AggrType Aggr::AggrType_MAX;
constexpr int Aggr::AggrType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnyPlan_PlanType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_polarx_5fexec_5fplan_2eproto);
  return file_level_enum_descriptors_polarx_5fexec_5fplan_2eproto[2];
}
bool AnyPlan_PlanType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AnyPlan_PlanType AnyPlan::GET;
constexpr AnyPlan_PlanType AnyPlan::TABLE_SCAN;
constexpr AnyPlan_PlanType AnyPlan::TABLE_PROJECT;
constexpr AnyPlan_PlanType AnyPlan::PROJECT;
constexpr AnyPlan_PlanType AnyPlan::FILTER;
constexpr AnyPlan_PlanType AnyPlan::RANGE_SCAN;
constexpr AnyPlan_PlanType AnyPlan::AGGR;
constexpr AnyPlan_PlanType AnyPlan::PlanType_MIN;
constexpr AnyPlan_PlanType AnyPlan::PlanType_MAX;
constexpr int AnyPlan::PlanType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class NewSession::_Internal {
 public:
};

NewSession::NewSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.NewSession)
}
NewSession::NewSession(const NewSession& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.NewSession)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewSession::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewSession::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NewSession::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[0]);
}

// ===================================================================

class CloseSession::_Internal {
 public:
};

CloseSession::CloseSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.CloseSession)
}
CloseSession::CloseSession(const CloseSession& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.CloseSession)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CloseSession::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CloseSession::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CloseSession::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[1]);
}

// ===================================================================

class EnumSession::_Internal {
 public:
};

EnumSession::EnumSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.EnumSession)
}
EnumSession::EnumSession(const EnumSession& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.EnumSession)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnumSession::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnumSession::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata EnumSession::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[2]);
}

// ===================================================================

class SessionInfo::_Internal {
 public:
};

SessionInfo::SessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.SessionInfo)
}
SessionInfo::SessionInfo(const SessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.SessionInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SessionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SessionInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SessionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[3]);
}

// ===================================================================

class SessionInfos::_Internal {
 public:
};

SessionInfos::SessionInfos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  sessions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.SessionInfos)
}
SessionInfos::SessionInfos(const SessionInfos& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.SessionInfos)
}

inline void SessionInfos::SharedCtor() {
}

SessionInfos::~SessionInfos() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.SessionInfos)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SessionInfos::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SessionInfos::ArenaDtor(void* object) {
  SessionInfos* _this = reinterpret_cast< SessionInfos* >(object);
  (void)_this;
}
void SessionInfos::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SessionInfos::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SessionInfos::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.SessionInfos)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SessionInfos::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sessions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SessionInfos::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.SessionInfos)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sessions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_sessions(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.SessionInfos)
  return target;
}

size_t SessionInfos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.SessionInfos)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
  total_size += 1UL * this->_internal_sessions_size();
  for (const auto& msg : this->sessions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SessionInfos::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SessionInfos::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SessionInfos::GetClassData() const { return &_class_data_; }

void SessionInfos::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SessionInfos *>(to)->MergeFrom(
      static_cast<const SessionInfos &>(from));
}


void SessionInfos::MergeFrom(const SessionInfos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.SessionInfos)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SessionInfos::CopyFrom(const SessionInfos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.SessionInfos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionInfos::IsInitialized() const {
  return true;
}

void SessionInfos::InternalSwap(SessionInfos* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  sessions_.InternalSwap(&other->sessions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SessionInfos::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[4]);
}

// ===================================================================

class TableInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TableInfo>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& name(const TableInfo* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& schema_name(const TableInfo* msg);
  static void set_has_schema_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::Datatypes::Scalar&
TableInfo::_Internal::name(const TableInfo* msg) {
  return *msg->name_;
}
const ::PolarXRPC::Datatypes::Scalar&
TableInfo::_Internal::schema_name(const TableInfo* msg) {
  return *msg->schema_name_;
}
void TableInfo::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void TableInfo::clear_schema_name() {
  if (schema_name_ != nullptr) schema_name_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
TableInfo::TableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.TableInfo)
}
TableInfo::TableInfo(const TableInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_name()) {
    name_ = new ::PolarXRPC::Datatypes::Scalar(*from.name_);
  } else {
    name_ = nullptr;
  }
  if (from._internal_has_schema_name()) {
    schema_name_ = new ::PolarXRPC::Datatypes::Scalar(*from.schema_name_);
  } else {
    schema_name_ = nullptr;
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.TableInfo)
}

inline void TableInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&name_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&name_)) + sizeof(version_));
}

TableInfo::~TableInfo() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.TableInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TableInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete name_;
  if (this != internal_default_instance()) delete schema_name_;
}

void TableInfo::ArenaDtor(void* object) {
  TableInfo* _this = reinterpret_cast< TableInfo* >(object);
  (void)_this;
}
void TableInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TableInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TableInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.TableInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(name_ != nullptr);
      name_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(schema_name_ != nullptr);
      schema_name_->Clear();
    }
  }
  version_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Datatypes.Scalar name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.TableInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 version = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_version(), target);
  }

  // required .PolarXRPC.Datatypes.Scalar name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::name(this), target, stream);
  }

  // optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::schema_name(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.TableInfo)
  return target;
}

size_t TableInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.TableInfo)
  size_t total_size = 0;

  // required .PolarXRPC.Datatypes.Scalar name = 2;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *name_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *schema_name_);
    }

    // optional int64 version = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TableInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableInfo::GetClassData() const { return &_class_data_; }

void TableInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TableInfo *>(to)->MergeFrom(
      static_cast<const TableInfo &>(from));
}


void TableInfo::MergeFrom(const TableInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.TableInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_name()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_schema_name()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_schema_name());
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableInfo::CopyFrom(const TableInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.TableInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_name()) {
    if (!name_->IsInitialized()) return false;
  }
  if (_internal_has_schema_name()) {
    if (!schema_name_->IsInitialized()) return false;
  }
  return true;
}

void TableInfo::InternalSwap(TableInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableInfo, version_)
      + sizeof(TableInfo::version_)
      - PROTOBUF_FIELD_OFFSET(TableInfo, name_)>(
          reinterpret_cast<char*>(&name_),
          reinterpret_cast<char*>(&other->name_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[5]);
}

// ===================================================================

class IndexInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexInfo>()._has_bits_);
  static const ::PolarXRPC::Datatypes::Scalar& name(const IndexInfo* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_parts(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::Datatypes::Scalar&
IndexInfo::_Internal::name(const IndexInfo* msg) {
  return *msg->name_;
}
void IndexInfo::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
IndexInfo::IndexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.IndexInfo)
}
IndexInfo::IndexInfo(const IndexInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_name()) {
    name_ = new ::PolarXRPC::Datatypes::Scalar(*from.name_);
  } else {
    name_ = nullptr;
  }
  use_parts_ = from.use_parts_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.IndexInfo)
}

inline void IndexInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&name_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_parts_) -
    reinterpret_cast<char*>(&name_)) + sizeof(use_parts_));
}

IndexInfo::~IndexInfo() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.IndexInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IndexInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete name_;
}

void IndexInfo::ArenaDtor(void* object) {
  IndexInfo* _this = reinterpret_cast< IndexInfo* >(object);
  (void)_this;
}
void IndexInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IndexInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IndexInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.IndexInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(name_ != nullptr);
    name_->Clear();
  }
  use_parts_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndexInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.Datatypes.Scalar name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 use_parts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_use_parts(&has_bits);
          use_parts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndexInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.IndexInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.Datatypes.Scalar name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::name(this), target, stream);
  }

  // optional int32 use_parts = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_use_parts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.IndexInfo)
  return target;
}

size_t IndexInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.IndexInfo)
  size_t total_size = 0;

  // required .PolarXRPC.Datatypes.Scalar name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *name_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 use_parts = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_use_parts());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndexInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IndexInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndexInfo::GetClassData() const { return &_class_data_; }

void IndexInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IndexInfo *>(to)->MergeFrom(
      static_cast<const IndexInfo &>(from));
}


void IndexInfo::MergeFrom(const IndexInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.IndexInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_name()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      use_parts_ = from.use_parts_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndexInfo::CopyFrom(const IndexInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.IndexInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_name()) {
    if (!name_->IsInitialized()) return false;
  }
  return true;
}

void IndexInfo::InternalSwap(IndexInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexInfo, use_parts_)
      + sizeof(IndexInfo::use_parts_)
      - PROTOBUF_FIELD_OFFSET(IndexInfo, name_)>(
          reinterpret_cast<char*>(&name_),
          reinterpret_cast<char*>(&other->name_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IndexInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[6]);
}

// ===================================================================

class Transaction::_Internal {
 public:
};

Transaction::Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Transaction)
}
Transaction::Transaction(const Transaction& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Transaction)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transaction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transaction::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Transaction::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[7]);
}

// ===================================================================

class BloomFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<BloomFilter>()._has_bits_);
  static void set_has_total_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_number_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

BloomFilter::BloomFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.BloomFilter)
}
BloomFilter::BloomFilter(const BloomFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  strategy_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    strategy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_strategy()) {
    strategy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_strategy(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&total_bits_, &from.total_bits_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_hash_) -
    reinterpret_cast<char*>(&total_bits_)) + sizeof(number_hash_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.BloomFilter)
}

inline void BloomFilter::SharedCtor() {
strategy_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  strategy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&total_bits_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_hash_) -
    reinterpret_cast<char*>(&total_bits_)) + sizeof(number_hash_));
}

BloomFilter::~BloomFilter() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.BloomFilter)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BloomFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  strategy_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BloomFilter::ArenaDtor(void* object) {
  BloomFilter* _this = reinterpret_cast< BloomFilter* >(object);
  (void)_this;
}
void BloomFilter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BloomFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BloomFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.BloomFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      strategy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&total_bits_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_hash_) -
        reinterpret_cast<char*>(&total_bits_)) + sizeof(number_hash_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BloomFilter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 total_bits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_total_bits(&has_bits);
          total_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 number_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_number_hash(&has_bits);
          number_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes strategy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_strategy();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BloomFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.BloomFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 total_bits = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_total_bits(), target);
  }

  // required uint32 number_hash = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_number_hash(), target);
  }

  // required bytes strategy = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_strategy(), target);
  }

  // required bytes data = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.BloomFilter)
  return target;
}

size_t BloomFilter::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.BloomFilter)
  size_t total_size = 0;

  if (_internal_has_strategy()) {
    // required bytes strategy = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strategy());
  }

  if (_internal_has_data()) {
    // required bytes data = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (_internal_has_total_bits()) {
    // required uint32 total_bits = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_total_bits());
  }

  if (_internal_has_number_hash()) {
    // required uint32 number_hash = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_hash());
  }

  return total_size;
}
size_t BloomFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.BloomFilter)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes strategy = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strategy());

    // required bytes data = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

    // required uint32 total_bits = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_total_bits());

    // required uint32 number_hash = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_hash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BloomFilter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BloomFilter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BloomFilter::GetClassData() const { return &_class_data_; }

void BloomFilter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BloomFilter *>(to)->MergeFrom(
      static_cast<const BloomFilter &>(from));
}


void BloomFilter::MergeFrom(const BloomFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.BloomFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_strategy(from._internal_strategy());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000004u) {
      total_bits_ = from.total_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      number_hash_ = from.number_hash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BloomFilter::CopyFrom(const BloomFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.BloomFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BloomFilter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void BloomFilter::InternalSwap(BloomFilter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &strategy_, lhs_arena,
      &other->strategy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BloomFilter, number_hash_)
      + sizeof(BloomFilter::number_hash_)
      - PROTOBUF_FIELD_OFFSET(BloomFilter, total_bits_)>(
          reinterpret_cast<char*>(&total_bits_),
          reinterpret_cast<char*>(&other->total_bits_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BloomFilter::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[8]);
}

// ===================================================================

class GetTSO::_Internal {
 public:
  using HasBits = decltype(std::declval<GetTSO>()._has_bits_);
  static void set_has_leader_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_batch_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GetTSO::GetTSO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.GetTSO)
}
GetTSO::GetTSO(const GetTSO& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  leader_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    leader_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_leader_name()) {
    leader_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_leader_name(), 
      GetArenaForAllocation());
  }
  batch_count_ = from.batch_count_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.GetTSO)
}

inline void GetTSO::SharedCtor() {
leader_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  leader_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
batch_count_ = 0;
}

GetTSO::~GetTSO() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.GetTSO)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetTSO::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  leader_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetTSO::ArenaDtor(void* object) {
  GetTSO* _this = reinterpret_cast< GetTSO* >(object);
  (void)_this;
}
void GetTSO::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetTSO::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetTSO::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.GetTSO)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    leader_name_.ClearNonDefaultToEmpty();
  }
  batch_count_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetTSO::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes leader_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_leader_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 batch_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_batch_count(&has_bits);
          batch_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetTSO::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.GetTSO)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes leader_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_leader_name(), target);
  }

  // required int32 batch_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_batch_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.GetTSO)
  return target;
}

size_t GetTSO::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.GetTSO)
  size_t total_size = 0;

  if (_internal_has_leader_name()) {
    // required bytes leader_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_leader_name());
  }

  if (_internal_has_batch_count()) {
    // required int32 batch_count = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_batch_count());
  }

  return total_size;
}
size_t GetTSO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.GetTSO)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes leader_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_leader_name());

    // required int32 batch_count = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_batch_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetTSO::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetTSO::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetTSO::GetClassData() const { return &_class_data_; }

void GetTSO::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetTSO *>(to)->MergeFrom(
      static_cast<const GetTSO &>(from));
}


void GetTSO::MergeFrom(const GetTSO& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.GetTSO)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_leader_name(from._internal_leader_name());
    }
    if (cached_has_bits & 0x00000002u) {
      batch_count_ = from.batch_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetTSO::CopyFrom(const GetTSO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.GetTSO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTSO::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetTSO::InternalSwap(GetTSO* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &leader_name_, lhs_arena,
      &other->leader_name_, rhs_arena
  );
  swap(batch_count_, other->batch_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetTSO::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[9]);
}

// ===================================================================

class ResultTSO::_Internal {
 public:
  using HasBits = decltype(std::declval<ResultTSO>()._has_bits_);
  static void set_has_error_no(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ResultTSO::ResultTSO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.ResultTSO)
}
ResultTSO::ResultTSO(const ResultTSO& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ts_, &from.ts_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_no_) -
    reinterpret_cast<char*>(&ts_)) + sizeof(error_no_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.ResultTSO)
}

inline void ResultTSO::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ts_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_no_) -
    reinterpret_cast<char*>(&ts_)) + sizeof(error_no_));
}

ResultTSO::~ResultTSO() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.ResultTSO)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ResultTSO::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResultTSO::ArenaDtor(void* object) {
  ResultTSO* _this = reinterpret_cast< ResultTSO* >(object);
  (void)_this;
}
void ResultTSO::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ResultTSO::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ResultTSO::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.ResultTSO)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ts_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_no_) -
        reinterpret_cast<char*>(&ts_)) + sizeof(error_no_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResultTSO::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 error_no = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_no(&has_bits);
          error_no_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 ts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ts(&has_bits);
          ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResultTSO::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.ResultTSO)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 error_no = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_no(), target);
  }

  // required uint64 ts = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.ResultTSO)
  return target;
}

size_t ResultTSO::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.ResultTSO)
  size_t total_size = 0;

  if (_internal_has_ts()) {
    // required uint64 ts = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_ts());
  }

  if (_internal_has_error_no()) {
    // required int32 error_no = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_error_no());
  }

  return total_size;
}
size_t ResultTSO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.ResultTSO)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 ts = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_ts());

    // required int32 error_no = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_error_no());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResultTSO::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ResultTSO::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResultTSO::GetClassData() const { return &_class_data_; }

void ResultTSO::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ResultTSO *>(to)->MergeFrom(
      static_cast<const ResultTSO &>(from));
}


void ResultTSO::MergeFrom(const ResultTSO& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.ResultTSO)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ts_ = from.ts_;
    }
    if (cached_has_bits & 0x00000002u) {
      error_no_ = from.error_no_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResultTSO::CopyFrom(const ResultTSO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.ResultTSO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResultTSO::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ResultTSO::InternalSwap(ResultTSO* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResultTSO, error_no_)
      + sizeof(ResultTSO::error_no_)
      - PROTOBUF_FIELD_OFFSET(ResultTSO, ts_)>(
          reinterpret_cast<char*>(&ts_),
          reinterpret_cast<char*>(&other->ts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResultTSO::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[10]);
}

// ===================================================================

class AutoSp::_Internal {
 public:
  using HasBits = decltype(std::declval<AutoSp>()._has_bits_);
  static void set_has_op(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sp_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reset_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AutoSp::AutoSp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.AutoSp)
}
AutoSp::AutoSp(const AutoSp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sp_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sp_name()) {
    sp_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sp_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&op_, &from.op_,
    static_cast<size_t>(reinterpret_cast<char*>(&reset_error_) -
    reinterpret_cast<char*>(&op_)) + sizeof(reset_error_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.AutoSp)
}

inline void AutoSp::SharedCtor() {
sp_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&op_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reset_error_) -
    reinterpret_cast<char*>(&op_)) + sizeof(reset_error_));
}

AutoSp::~AutoSp() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.AutoSp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AutoSp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sp_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AutoSp::ArenaDtor(void* object) {
  AutoSp* _this = reinterpret_cast< AutoSp* >(object);
  (void)_this;
}
void AutoSp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AutoSp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutoSp::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.AutoSp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sp_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&op_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reset_error_) -
        reinterpret_cast<char*>(&op_)) + sizeof(reset_error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AutoSp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::ExecPlan::AutoSp_Operation_IsValid(val))) {
            _internal_set_op(static_cast<::PolarXRPC::ExecPlan::AutoSp_Operation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes sp_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sp_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reset_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reset_error(&has_bits);
          reset_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoSp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.AutoSp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op(), target);
  }

  // required bytes sp_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sp_name(), target);
  }

  // optional bool reset_error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reset_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.AutoSp)
  return target;
}

size_t AutoSp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.AutoSp)
  size_t total_size = 0;

  if (_internal_has_sp_name()) {
    // required bytes sp_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sp_name());
  }

  if (_internal_has_op()) {
    // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op());
  }

  return total_size;
}
size_t AutoSp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.AutoSp)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes sp_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sp_name());

    // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool reset_error = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AutoSp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AutoSp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AutoSp::GetClassData() const { return &_class_data_; }

void AutoSp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AutoSp *>(to)->MergeFrom(
      static_cast<const AutoSp &>(from));
}


void AutoSp::MergeFrom(const AutoSp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.AutoSp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sp_name(from._internal_sp_name());
    }
    if (cached_has_bits & 0x00000002u) {
      op_ = from.op_;
    }
    if (cached_has_bits & 0x00000004u) {
      reset_error_ = from.reset_error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AutoSp::CopyFrom(const AutoSp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.AutoSp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoSp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AutoSp::InternalSwap(AutoSp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sp_name_, lhs_arena,
      &other->sp_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutoSp, reset_error_)
      + sizeof(AutoSp::reset_error_)
      - PROTOBUF_FIELD_OFFSET(AutoSp, op_)>(
          reinterpret_cast<char*>(&op_),
          reinterpret_cast<char*>(&other->op_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AutoSp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[11]);
}

// ===================================================================

class KeyExpr::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyExpr>()._has_bits_);
  static const ::PolarXRPC::Datatypes::Scalar& field(const KeyExpr* msg);
  static void set_has_field(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& value(const KeyExpr* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::PolarXRPC::Datatypes::Scalar&
KeyExpr::_Internal::field(const KeyExpr* msg) {
  return *msg->field_;
}
const ::PolarXRPC::Datatypes::Scalar&
KeyExpr::_Internal::value(const KeyExpr* msg) {
  return *msg->value_;
}
void KeyExpr::clear_field() {
  if (field_ != nullptr) field_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void KeyExpr::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
KeyExpr::KeyExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.KeyExpr)
}
KeyExpr::KeyExpr(const KeyExpr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_field()) {
    field_ = new ::PolarXRPC::Datatypes::Scalar(*from.field_);
  } else {
    field_ = nullptr;
  }
  if (from._internal_has_value()) {
    value_ = new ::PolarXRPC::Datatypes::Scalar(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.KeyExpr)
}

inline void KeyExpr::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&field_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&value_) -
    reinterpret_cast<char*>(&field_)) + sizeof(value_));
}

KeyExpr::~KeyExpr() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.KeyExpr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeyExpr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete field_;
  if (this != internal_default_instance()) delete value_;
}

void KeyExpr::ArenaDtor(void* object) {
  KeyExpr* _this = reinterpret_cast< KeyExpr* >(object);
  (void)_this;
}
void KeyExpr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyExpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyExpr::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.KeyExpr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(field_ != nullptr);
      field_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != nullptr);
      value_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyExpr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.Datatypes.Scalar field = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Datatypes.Scalar value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyExpr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.KeyExpr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.Datatypes.Scalar field = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::field(this), target, stream);
  }

  // required .PolarXRPC.Datatypes.Scalar value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::value(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.KeyExpr)
  return target;
}

size_t KeyExpr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.KeyExpr)
  size_t total_size = 0;

  if (_internal_has_field()) {
    // required .PolarXRPC.Datatypes.Scalar field = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);
  }

  if (_internal_has_value()) {
    // required .PolarXRPC.Datatypes.Scalar value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  return total_size;
}
size_t KeyExpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.KeyExpr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .PolarXRPC.Datatypes.Scalar field = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);

    // required .PolarXRPC.Datatypes.Scalar value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyExpr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeyExpr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyExpr::GetClassData() const { return &_class_data_; }

void KeyExpr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeyExpr *>(to)->MergeFrom(
      static_cast<const KeyExpr &>(from));
}


void KeyExpr::MergeFrom(const KeyExpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.KeyExpr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_field()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_field());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyExpr::CopyFrom(const KeyExpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.KeyExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyExpr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_field()) {
    if (!field_->IsInitialized()) return false;
  }
  if (_internal_has_value()) {
    if (!value_->IsInitialized()) return false;
  }
  return true;
}

void KeyExpr::InternalSwap(KeyExpr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyExpr, value_)
      + sizeof(KeyExpr::value_)
      - PROTOBUF_FIELD_OFFSET(KeyExpr, field_)>(
          reinterpret_cast<char*>(&field_),
          reinterpret_cast<char*>(&other->field_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyExpr::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[12]);
}

// ===================================================================

class GetExpr::_Internal {
 public:
};

GetExpr::GetExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  keys_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.GetExpr)
}
GetExpr::GetExpr(const GetExpr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      keys_(from.keys_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.GetExpr)
}

inline void GetExpr::SharedCtor() {
}

GetExpr::~GetExpr() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.GetExpr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetExpr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetExpr::ArenaDtor(void* object) {
  GetExpr* _this = reinterpret_cast< GetExpr* >(object);
  (void)_this;
}
void GetExpr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetExpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetExpr::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.GetExpr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keys_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetExpr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetExpr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.GetExpr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_keys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_keys(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.GetExpr)
  return target;
}

size_t GetExpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.GetExpr)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetExpr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetExpr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetExpr::GetClassData() const { return &_class_data_; }

void GetExpr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetExpr *>(to)->MergeFrom(
      static_cast<const GetExpr &>(from));
}


void GetExpr::MergeFrom(const GetExpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.GetExpr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  keys_.MergeFrom(from.keys_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetExpr::CopyFrom(const GetExpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.GetExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetExpr::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(keys_))
    return false;
  return true;
}

void GetExpr::InternalSwap(GetExpr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  keys_.InternalSwap(&other->keys_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetExpr::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[13]);
}

// ===================================================================

class GetPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<GetPlan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const GetPlan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const GetPlan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::TableInfo&
GetPlan::_Internal::table_info(const GetPlan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
GetPlan::_Internal::index_info(const GetPlan* msg) {
  return *msg->index_info_;
}
GetPlan::GetPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  keys_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.GetPlan)
}
GetPlan::GetPlan(const GetPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      keys_(from.keys_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.GetPlan)
}

inline void GetPlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_info_) -
    reinterpret_cast<char*>(&table_info_)) + sizeof(index_info_));
}

GetPlan::~GetPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.GetPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
}

void GetPlan::ArenaDtor(void* object) {
  GetPlan* _this = reinterpret_cast< GetPlan* >(object);
  (void)_this;
}
void GetPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.GetPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keys_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.GetPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::index_info(this), target, stream);
  }

  // repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_keys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_keys(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.GetPlan)
  return target;
}

size_t GetPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.GetPlan)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (_internal_has_table_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *table_info_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *index_info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetPlan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetPlan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetPlan::GetClassData() const { return &_class_data_; }

void GetPlan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetPlan *>(to)->MergeFrom(
      static_cast<const GetPlan &>(from));
}


void GetPlan::MergeFrom(const GetPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.GetPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  keys_.MergeFrom(from.keys_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetPlan::CopyFrom(const GetPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.GetPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPlan::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(keys_))
    return false;
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  return true;
}

void GetPlan::InternalSwap(GetPlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  keys_.InternalSwap(&other->keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetPlan, index_info_)
      + sizeof(GetPlan::index_info_)
      - PROTOBUF_FIELD_OFFSET(GetPlan, table_info_)>(
          reinterpret_cast<char*>(&table_info_),
          reinterpret_cast<char*>(&other->table_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetPlan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[14]);
}

// ===================================================================

class TableScanPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<TableScanPlan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const TableScanPlan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const TableScanPlan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::TableInfo&
TableScanPlan::_Internal::table_info(const TableScanPlan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
TableScanPlan::_Internal::index_info(const TableScanPlan* msg) {
  return *msg->index_info_;
}
TableScanPlan::TableScanPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.TableScanPlan)
}
TableScanPlan::TableScanPlan(const TableScanPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  reverse_ = from.reverse_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.TableScanPlan)
}

inline void TableScanPlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reverse_) -
    reinterpret_cast<char*>(&table_info_)) + sizeof(reverse_));
}

TableScanPlan::~TableScanPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.TableScanPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TableScanPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
}

void TableScanPlan::ArenaDtor(void* object) {
  TableScanPlan* _this = reinterpret_cast< TableScanPlan* >(object);
  (void)_this;
}
void TableScanPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TableScanPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TableScanPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.TableScanPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
  }
  reverse_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableScanPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reverse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableScanPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.TableScanPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::index_info(this), target, stream);
  }

  // optional bool reverse = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reverse(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.TableScanPlan)
  return target;
}

size_t TableScanPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.TableScanPlan)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (_internal_has_table_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *table_info_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_info_);
    }

    // optional bool reverse = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableScanPlan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TableScanPlan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableScanPlan::GetClassData() const { return &_class_data_; }

void TableScanPlan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TableScanPlan *>(to)->MergeFrom(
      static_cast<const TableScanPlan &>(from));
}


void TableScanPlan::MergeFrom(const TableScanPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.TableScanPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
    if (cached_has_bits & 0x00000004u) {
      reverse_ = from.reverse_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableScanPlan::CopyFrom(const TableScanPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.TableScanPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableScanPlan::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  return true;
}

void TableScanPlan::InternalSwap(TableScanPlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableScanPlan, reverse_)
      + sizeof(TableScanPlan::reverse_)
      - PROTOBUF_FIELD_OFFSET(TableScanPlan, table_info_)>(
          reinterpret_cast<char*>(&table_info_),
          reinterpret_cast<char*>(&other->table_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableScanPlan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[15]);
}

// ===================================================================

class KeyOnlyRangeScan::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyOnlyRangeScan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::Transaction& snapshot(const KeyOnlyRangeScan* msg);
  static void set_has_snapshot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const KeyOnlyRangeScan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const KeyOnlyRangeScan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& key(const KeyOnlyRangeScan* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& end_key(const KeyOnlyRangeScan* msg);
  static void set_has_end_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::PolarXRPC::ExecPlan::Transaction&
KeyOnlyRangeScan::_Internal::snapshot(const KeyOnlyRangeScan* msg) {
  return *msg->snapshot_;
}
const ::PolarXRPC::ExecPlan::TableInfo&
KeyOnlyRangeScan::_Internal::table_info(const KeyOnlyRangeScan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
KeyOnlyRangeScan::_Internal::index_info(const KeyOnlyRangeScan* msg) {
  return *msg->index_info_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
KeyOnlyRangeScan::_Internal::key(const KeyOnlyRangeScan* msg) {
  return *msg->key_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
KeyOnlyRangeScan::_Internal::end_key(const KeyOnlyRangeScan* msg) {
  return *msg->end_key_;
}
KeyOnlyRangeScan::KeyOnlyRangeScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
}
KeyOnlyRangeScan::KeyOnlyRangeScan(const KeyOnlyRangeScan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_snapshot()) {
    snapshot_ = new ::PolarXRPC::ExecPlan::Transaction(*from.snapshot_);
  } else {
    snapshot_ = nullptr;
  }
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  if (from._internal_has_key()) {
    key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.key_);
  } else {
    key_ = nullptr;
  }
  if (from._internal_has_end_key()) {
    end_key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.end_key_);
  } else {
    end_key_ = nullptr;
  }
  ::memcpy(&reverse_, &from.reverse_,
    static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
}

inline void KeyOnlyRangeScan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&snapshot_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&snapshot_)) + sizeof(flag_));
}

KeyOnlyRangeScan::~KeyOnlyRangeScan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeyOnlyRangeScan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete snapshot_;
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
  if (this != internal_default_instance()) delete key_;
  if (this != internal_default_instance()) delete end_key_;
}

void KeyOnlyRangeScan::ArenaDtor(void* object) {
  KeyOnlyRangeScan* _this = reinterpret_cast< KeyOnlyRangeScan* >(object);
  (void)_this;
}
void KeyOnlyRangeScan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyOnlyRangeScan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyOnlyRangeScan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(snapshot_ != nullptr);
      snapshot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(key_ != nullptr);
      key_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(end_key_ != nullptr);
      end_key_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&reverse_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flag_) -
        reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyOnlyRangeScan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reverse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 flag = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_flag(&has_bits);
          flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyOnlyRangeScan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::snapshot(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::index_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::key(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::end_key(this), target, stream);
  }

  // optional bool reverse = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_reverse(), target);
  }

  // optional int64 flag = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  return target;
}

size_t KeyOnlyRangeScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *snapshot_);
    }

    // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_info_);
    }

    // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_info_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *key_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_key_);
    }

    // optional bool reverse = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional int64 flag = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_flag());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyOnlyRangeScan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeyOnlyRangeScan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyOnlyRangeScan::GetClassData() const { return &_class_data_; }

void KeyOnlyRangeScan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeyOnlyRangeScan *>(to)->MergeFrom(
      static_cast<const KeyOnlyRangeScan &>(from));
}


void KeyOnlyRangeScan::MergeFrom(const KeyOnlyRangeScan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_snapshot()->::PolarXRPC::ExecPlan::Transaction::MergeFrom(from._internal_snapshot());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_end_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_end_key());
    }
    if (cached_has_bits & 0x00000020u) {
      reverse_ = from.reverse_;
    }
    if (cached_has_bits & 0x00000040u) {
      flag_ = from.flag_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyOnlyRangeScan::CopyFrom(const KeyOnlyRangeScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyOnlyRangeScan::IsInitialized() const {
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  if (_internal_has_key()) {
    if (!key_->IsInitialized()) return false;
  }
  if (_internal_has_end_key()) {
    if (!end_key_->IsInitialized()) return false;
  }
  return true;
}

void KeyOnlyRangeScan::InternalSwap(KeyOnlyRangeScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyOnlyRangeScan, flag_)
      + sizeof(KeyOnlyRangeScan::flag_)
      - PROTOBUF_FIELD_OFFSET(KeyOnlyRangeScan, snapshot_)>(
          reinterpret_cast<char*>(&snapshot_),
          reinterpret_cast<char*>(&other->snapshot_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyOnlyRangeScan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[16]);
}

// ===================================================================

class RangeScan::_Internal {
 public:
  using HasBits = decltype(std::declval<RangeScan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::Transaction& snapshot(const RangeScan* msg);
  static void set_has_snapshot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const RangeScan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const RangeScan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& key(const RangeScan* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& end_key(const RangeScan* msg);
  static void set_has_end_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::PolarXRPC::ExecPlan::Transaction&
RangeScan::_Internal::snapshot(const RangeScan* msg) {
  return *msg->snapshot_;
}
const ::PolarXRPC::ExecPlan::TableInfo&
RangeScan::_Internal::table_info(const RangeScan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
RangeScan::_Internal::index_info(const RangeScan* msg) {
  return *msg->index_info_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
RangeScan::_Internal::key(const RangeScan* msg) {
  return *msg->key_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
RangeScan::_Internal::end_key(const RangeScan* msg) {
  return *msg->end_key_;
}
RangeScan::RangeScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.RangeScan)
}
RangeScan::RangeScan(const RangeScan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_snapshot()) {
    snapshot_ = new ::PolarXRPC::ExecPlan::Transaction(*from.snapshot_);
  } else {
    snapshot_ = nullptr;
  }
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  if (from._internal_has_key()) {
    key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.key_);
  } else {
    key_ = nullptr;
  }
  if (from._internal_has_end_key()) {
    end_key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.end_key_);
  } else {
    end_key_ = nullptr;
  }
  ::memcpy(&reverse_, &from.reverse_,
    static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.RangeScan)
}

inline void RangeScan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&snapshot_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&snapshot_)) + sizeof(flag_));
}

RangeScan::~RangeScan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.RangeScan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RangeScan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete snapshot_;
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
  if (this != internal_default_instance()) delete key_;
  if (this != internal_default_instance()) delete end_key_;
}

void RangeScan::ArenaDtor(void* object) {
  RangeScan* _this = reinterpret_cast< RangeScan* >(object);
  (void)_this;
}
void RangeScan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RangeScan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RangeScan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.RangeScan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(snapshot_ != nullptr);
      snapshot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(key_ != nullptr);
      key_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(end_key_ != nullptr);
      end_key_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&reverse_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flag_) -
        reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangeScan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reverse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 flag = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_flag(&has_bits);
          flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeScan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.RangeScan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::snapshot(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::index_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::key(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::end_key(this), target, stream);
  }

  // optional bool reverse = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_reverse(), target);
  }

  // optional int64 flag = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.RangeScan)
  return target;
}

size_t RangeScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.RangeScan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *snapshot_);
    }

    // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_info_);
    }

    // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_info_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *key_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_key_);
    }

    // optional bool reverse = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional int64 flag = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_flag());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangeScan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RangeScan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangeScan::GetClassData() const { return &_class_data_; }

void RangeScan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RangeScan *>(to)->MergeFrom(
      static_cast<const RangeScan &>(from));
}


void RangeScan::MergeFrom(const RangeScan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.RangeScan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_snapshot()->::PolarXRPC::ExecPlan::Transaction::MergeFrom(from._internal_snapshot());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_end_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_end_key());
    }
    if (cached_has_bits & 0x00000020u) {
      reverse_ = from.reverse_;
    }
    if (cached_has_bits & 0x00000040u) {
      flag_ = from.flag_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangeScan::CopyFrom(const RangeScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.RangeScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeScan::IsInitialized() const {
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  if (_internal_has_key()) {
    if (!key_->IsInitialized()) return false;
  }
  if (_internal_has_end_key()) {
    if (!end_key_->IsInitialized()) return false;
  }
  return true;
}

void RangeScan::InternalSwap(RangeScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeScan, flag_)
      + sizeof(RangeScan::flag_)
      - PROTOBUF_FIELD_OFFSET(RangeScan, snapshot_)>(
          reinterpret_cast<char*>(&snapshot_),
          reinterpret_cast<char*>(&other->snapshot_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeScan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[17]);
}

// ===================================================================

class TableProject::_Internal {
 public:
  using HasBits = decltype(std::declval<TableProject>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const TableProject* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
TableProject::_Internal::sub_read_plan(const TableProject* msg) {
  return *msg->sub_read_plan_;
}
void TableProject::clear_fields() {
  fields_.Clear();
}
TableProject::TableProject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fields_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.TableProject)
}
TableProject::TableProject(const TableProject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fields_(from.fields_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.TableProject)
}

inline void TableProject::SharedCtor() {
sub_read_plan_ = nullptr;
}

TableProject::~TableProject() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.TableProject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TableProject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
}

void TableProject::ArenaDtor(void* object) {
  TableProject* _this = reinterpret_cast< TableProject* >(object);
  (void)_this;
}
void TableProject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TableProject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TableProject::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.TableProject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fields_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(sub_read_plan_ != nullptr);
    sub_read_plan_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableProject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableProject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.TableProject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fields_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_fields(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.TableProject)
  return target;
}

size_t TableProject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.TableProject)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (_internal_has_sub_read_plan()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableProject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TableProject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableProject::GetClassData() const { return &_class_data_; }

void TableProject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TableProject *>(to)->MergeFrom(
      static_cast<const TableProject &>(from));
}


void TableProject::MergeFrom(const TableProject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.TableProject)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fields_.MergeFrom(from.fields_);
  if (from._internal_has_sub_read_plan()) {
    _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableProject::CopyFrom(const TableProject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.TableProject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableProject::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(fields_))
    return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  return true;
}

void TableProject::InternalSwap(TableProject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fields_.InternalSwap(&other->fields_);
  swap(sub_read_plan_, other->sub_read_plan_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TableProject::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[18]);
}

// ===================================================================

class Project::_Internal {
 public:
  using HasBits = decltype(std::declval<Project>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const Project* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
Project::_Internal::sub_read_plan(const Project* msg) {
  return *msg->sub_read_plan_;
}
void Project::clear_fields() {
  fields_.Clear();
}
void Project::clear_exprs() {
  exprs_.Clear();
}
Project::Project(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fields_(arena),
  exprs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Project)
}
Project::Project(const Project& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fields_(from.fields_),
      exprs_(from.exprs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Project)
}

inline void Project::SharedCtor() {
sub_read_plan_ = nullptr;
}

Project::~Project() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.Project)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Project::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
}

void Project::ArenaDtor(void* object) {
  Project* _this = reinterpret_cast< Project* >(object);
  (void)_this;
}
void Project::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Project::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Project::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.Project)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fields_.Clear();
  exprs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(sub_read_plan_ != nullptr);
    sub_read_plan_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Project::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Expr.Expr exprs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Project::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.Project)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fields_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_fields(i), target, stream);
  }

  // repeated .PolarXRPC.Expr.Expr exprs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_exprs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.Project)
  return target;
}

size_t Project::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.Project)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (_internal_has_sub_read_plan()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PolarXRPC.Expr.Expr exprs = 3;
  total_size += 1UL * this->_internal_exprs_size();
  for (const auto& msg : this->exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Project::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Project::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Project::GetClassData() const { return &_class_data_; }

void Project::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Project *>(to)->MergeFrom(
      static_cast<const Project &>(from));
}


void Project::MergeFrom(const Project& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.Project)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fields_.MergeFrom(from.fields_);
  exprs_.MergeFrom(from.exprs_);
  if (from._internal_has_sub_read_plan()) {
    _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Project::CopyFrom(const Project& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.Project)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Project::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(fields_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(exprs_))
    return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  return true;
}

void Project::InternalSwap(Project* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fields_.InternalSwap(&other->fields_);
  exprs_.InternalSwap(&other->exprs_);
  swap(sub_read_plan_, other->sub_read_plan_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Project::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[19]);
}

// ===================================================================

class Filter::_Internal {
 public:
  using HasBits = decltype(std::declval<Filter>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const Filter* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::Expr::Expr& expr(const Filter* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
Filter::_Internal::sub_read_plan(const Filter* msg) {
  return *msg->sub_read_plan_;
}
const ::PolarXRPC::Expr::Expr&
Filter::_Internal::expr(const Filter* msg) {
  return *msg->expr_;
}
void Filter::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
Filter::Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Filter)
}
Filter::Filter(const Filter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  if (from._internal_has_expr()) {
    expr_ = new ::PolarXRPC::Expr::Expr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Filter)
}

inline void Filter::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sub_read_plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&expr_) -
    reinterpret_cast<char*>(&sub_read_plan_)) + sizeof(expr_));
}

Filter::~Filter() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.Filter)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Filter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
  if (this != internal_default_instance()) delete expr_;
}

void Filter::ArenaDtor(void* object) {
  Filter* _this = reinterpret_cast< Filter* >(object);
  (void)_this;
}
void Filter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Filter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Filter::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.Filter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sub_read_plan_ != nullptr);
      sub_read_plan_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Filter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Expr.Expr expr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Filter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.Filter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // required .PolarXRPC.Expr.Expr expr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.Filter)
  return target;
}

size_t Filter::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.Filter)
  size_t total_size = 0;

  if (_internal_has_sub_read_plan()) {
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }

  if (_internal_has_expr()) {
    // required .PolarXRPC.Expr.Expr expr = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);
  }

  return total_size;
}
size_t Filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.Filter)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);

    // required .PolarXRPC.Expr.Expr expr = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Filter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Filter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Filter::GetClassData() const { return &_class_data_; }

void Filter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Filter *>(to)->MergeFrom(
      static_cast<const Filter &>(from));
}


void Filter::MergeFrom(const Filter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.Filter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_expr()->::PolarXRPC::Expr::Expr::MergeFrom(from._internal_expr());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Filter::CopyFrom(const Filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.Filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  if (_internal_has_expr()) {
    if (!expr_->IsInitialized()) return false;
  }
  return true;
}

void Filter::InternalSwap(Filter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Filter, expr_)
      + sizeof(Filter::expr_)
      - PROTOBUF_FIELD_OFFSET(Filter, sub_read_plan_)>(
          reinterpret_cast<char*>(&sub_read_plan_),
          reinterpret_cast<char*>(&other->sub_read_plan_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Filter::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[20]);
}

// ===================================================================

class Aggr::_Internal {
 public:
  using HasBits = decltype(std::declval<Aggr>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const Aggr* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& field(const Aggr* msg);
  static void set_has_field(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::Expr::Expr& expr(const Aggr* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
Aggr::_Internal::sub_read_plan(const Aggr* msg) {
  return *msg->sub_read_plan_;
}
const ::PolarXRPC::Datatypes::Scalar&
Aggr::_Internal::field(const Aggr* msg) {
  return *msg->field_;
}
const ::PolarXRPC::Expr::Expr&
Aggr::_Internal::expr(const Aggr* msg) {
  return *msg->expr_;
}
void Aggr::clear_field() {
  if (field_ != nullptr) field_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Aggr::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
Aggr::Aggr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Aggr)
}
Aggr::Aggr(const Aggr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  if (from._internal_has_field()) {
    field_ = new ::PolarXRPC::Datatypes::Scalar(*from.field_);
  } else {
    field_ = nullptr;
  }
  if (from._internal_has_expr()) {
    expr_ = new ::PolarXRPC::Expr::Expr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Aggr)
}

inline void Aggr::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sub_read_plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&expr_) -
    reinterpret_cast<char*>(&sub_read_plan_)) + sizeof(expr_));
type_ = 1;
}

Aggr::~Aggr() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.Aggr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Aggr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
  if (this != internal_default_instance()) delete field_;
  if (this != internal_default_instance()) delete expr_;
}

void Aggr::ArenaDtor(void* object) {
  Aggr* _this = reinterpret_cast< Aggr* >(object);
  (void)_this;
}
void Aggr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Aggr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Aggr::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.Aggr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sub_read_plan_ != nullptr);
      sub_read_plan_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(field_ != nullptr);
      field_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Aggr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::ExecPlan::Aggr_AggrType_IsValid(val))) {
            _internal_set_type(static_cast<::PolarXRPC::ExecPlan::Aggr_AggrType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Datatypes.Scalar field = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Expr.Expr expr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Aggr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.Aggr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // required .PolarXRPC.Datatypes.Scalar field = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::field(this), target, stream);
  }

  // required .PolarXRPC.Expr.Expr expr = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.Aggr)
  return target;
}

size_t Aggr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.Aggr)
  size_t total_size = 0;

  if (_internal_has_sub_read_plan()) {
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }

  if (_internal_has_field()) {
    // required .PolarXRPC.Datatypes.Scalar field = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);
  }

  if (_internal_has_expr()) {
    // required .PolarXRPC.Expr.Expr expr = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);
  }

  if (_internal_has_type()) {
    // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t Aggr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.Aggr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);

    // required .PolarXRPC.Datatypes.Scalar field = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);

    // required .PolarXRPC.Expr.Expr expr = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);

    // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Aggr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Aggr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Aggr::GetClassData() const { return &_class_data_; }

void Aggr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Aggr *>(to)->MergeFrom(
      static_cast<const Aggr &>(from));
}


void Aggr::MergeFrom(const Aggr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.Aggr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_field()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_field());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_expr()->::PolarXRPC::Expr::Expr::MergeFrom(from._internal_expr());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Aggr::CopyFrom(const Aggr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.Aggr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Aggr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  if (_internal_has_field()) {
    if (!field_->IsInitialized()) return false;
  }
  if (_internal_has_expr()) {
    if (!expr_->IsInitialized()) return false;
  }
  return true;
}

void Aggr::InternalSwap(Aggr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Aggr, expr_)
      + sizeof(Aggr::expr_)
      - PROTOBUF_FIELD_OFFSET(Aggr, sub_read_plan_)>(
          reinterpret_cast<char*>(&sub_read_plan_),
          reinterpret_cast<char*>(&other->sub_read_plan_));
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Aggr::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[21]);
}

// ===================================================================

class AnyPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<AnyPlan>()._has_bits_);
  static void set_has_plan_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::PolarXRPC::ExecPlan::GetPlan& get_plan(const AnyPlan* msg);
  static void set_has_get_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::TableScanPlan& table_scan_plan(const AnyPlan* msg);
  static void set_has_table_scan_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::ExecPlan::TableProject& table_project(const AnyPlan* msg);
  static void set_has_table_project(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::ExecPlan::Project& project(const AnyPlan* msg);
  static void set_has_project(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::Filter& filter(const AnyPlan* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::PolarXRPC::ExecPlan::RangeScan& range_scan(const AnyPlan* msg);
  static void set_has_range_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::PolarXRPC::ExecPlan::Aggr& aggr(const AnyPlan* msg);
  static void set_has_aggr(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000080) ^ 0x00000080) != 0;
  }
};

const ::PolarXRPC::ExecPlan::GetPlan&
AnyPlan::_Internal::get_plan(const AnyPlan* msg) {
  return *msg->get_plan_;
}
const ::PolarXRPC::ExecPlan::TableScanPlan&
AnyPlan::_Internal::table_scan_plan(const AnyPlan* msg) {
  return *msg->table_scan_plan_;
}
const ::PolarXRPC::ExecPlan::TableProject&
AnyPlan::_Internal::table_project(const AnyPlan* msg) {
  return *msg->table_project_;
}
const ::PolarXRPC::ExecPlan::Project&
AnyPlan::_Internal::project(const AnyPlan* msg) {
  return *msg->project_;
}
const ::PolarXRPC::ExecPlan::Filter&
AnyPlan::_Internal::filter(const AnyPlan* msg) {
  return *msg->filter_;
}
const ::PolarXRPC::ExecPlan::RangeScan&
AnyPlan::_Internal::range_scan(const AnyPlan* msg) {
  return *msg->range_scan_;
}
const ::PolarXRPC::ExecPlan::Aggr&
AnyPlan::_Internal::aggr(const AnyPlan* msg) {
  return *msg->aggr_;
}
AnyPlan::AnyPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.AnyPlan)
}
AnyPlan::AnyPlan(const AnyPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_get_plan()) {
    get_plan_ = new ::PolarXRPC::ExecPlan::GetPlan(*from.get_plan_);
  } else {
    get_plan_ = nullptr;
  }
  if (from._internal_has_table_scan_plan()) {
    table_scan_plan_ = new ::PolarXRPC::ExecPlan::TableScanPlan(*from.table_scan_plan_);
  } else {
    table_scan_plan_ = nullptr;
  }
  if (from._internal_has_table_project()) {
    table_project_ = new ::PolarXRPC::ExecPlan::TableProject(*from.table_project_);
  } else {
    table_project_ = nullptr;
  }
  if (from._internal_has_project()) {
    project_ = new ::PolarXRPC::ExecPlan::Project(*from.project_);
  } else {
    project_ = nullptr;
  }
  if (from._internal_has_filter()) {
    filter_ = new ::PolarXRPC::ExecPlan::Filter(*from.filter_);
  } else {
    filter_ = nullptr;
  }
  if (from._internal_has_range_scan()) {
    range_scan_ = new ::PolarXRPC::ExecPlan::RangeScan(*from.range_scan_);
  } else {
    range_scan_ = nullptr;
  }
  if (from._internal_has_aggr()) {
    aggr_ = new ::PolarXRPC::ExecPlan::Aggr(*from.aggr_);
  } else {
    aggr_ = nullptr;
  }
  plan_type_ = from.plan_type_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.AnyPlan)
}

inline void AnyPlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&get_plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&aggr_) -
    reinterpret_cast<char*>(&get_plan_)) + sizeof(aggr_));
plan_type_ = 1;
}

AnyPlan::~AnyPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.AnyPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AnyPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete get_plan_;
  if (this != internal_default_instance()) delete table_scan_plan_;
  if (this != internal_default_instance()) delete table_project_;
  if (this != internal_default_instance()) delete project_;
  if (this != internal_default_instance()) delete filter_;
  if (this != internal_default_instance()) delete range_scan_;
  if (this != internal_default_instance()) delete aggr_;
}

void AnyPlan::ArenaDtor(void* object) {
  AnyPlan* _this = reinterpret_cast< AnyPlan* >(object);
  (void)_this;
}
void AnyPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnyPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AnyPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.AnyPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(get_plan_ != nullptr);
      get_plan_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(table_scan_plan_ != nullptr);
      table_scan_plan_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(table_project_ != nullptr);
      table_project_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(project_ != nullptr);
      project_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(filter_ != nullptr);
      filter_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(range_scan_ != nullptr);
      range_scan_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(aggr_ != nullptr);
      aggr_->Clear();
    }
    plan_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnyPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::ExecPlan::AnyPlan_PlanType_IsValid(val))) {
            _internal_set_plan_type(static_cast<::PolarXRPC::ExecPlan::AnyPlan_PlanType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_scan_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_project(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.Project project = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_project(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.Filter filter = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_range_scan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_aggr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnyPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.AnyPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_plan_type(), target);
  }

  // optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::get_plan(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::table_scan_plan(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::table_project(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.Project project = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::project(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.Filter filter = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::filter(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::range_scan(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::aggr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.AnyPlan)
  return target;
}

size_t AnyPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.AnyPlan)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
  if (_internal_has_plan_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_plan_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *get_plan_);
    }

    // optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_scan_plan_);
    }

    // optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_project_);
    }

    // optional .PolarXRPC.ExecPlan.Project project = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *project_);
    }

    // optional .PolarXRPC.ExecPlan.Filter filter = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_);
    }

    // optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *range_scan_);
    }

    // optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *aggr_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnyPlan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AnyPlan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnyPlan::GetClassData() const { return &_class_data_; }

void AnyPlan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AnyPlan *>(to)->MergeFrom(
      static_cast<const AnyPlan &>(from));
}


void AnyPlan::MergeFrom(const AnyPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.AnyPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_get_plan()->::PolarXRPC::ExecPlan::GetPlan::MergeFrom(from._internal_get_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_table_scan_plan()->::PolarXRPC::ExecPlan::TableScanPlan::MergeFrom(from._internal_table_scan_plan());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_table_project()->::PolarXRPC::ExecPlan::TableProject::MergeFrom(from._internal_table_project());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_project()->::PolarXRPC::ExecPlan::Project::MergeFrom(from._internal_project());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_filter()->::PolarXRPC::ExecPlan::Filter::MergeFrom(from._internal_filter());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_range_scan()->::PolarXRPC::ExecPlan::RangeScan::MergeFrom(from._internal_range_scan());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_aggr()->::PolarXRPC::ExecPlan::Aggr::MergeFrom(from._internal_aggr());
    }
    if (cached_has_bits & 0x00000080u) {
      plan_type_ = from.plan_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnyPlan::CopyFrom(const AnyPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.AnyPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnyPlan::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_get_plan()) {
    if (!get_plan_->IsInitialized()) return false;
  }
  if (_internal_has_table_scan_plan()) {
    if (!table_scan_plan_->IsInitialized()) return false;
  }
  if (_internal_has_table_project()) {
    if (!table_project_->IsInitialized()) return false;
  }
  if (_internal_has_project()) {
    if (!project_->IsInitialized()) return false;
  }
  if (_internal_has_filter()) {
    if (!filter_->IsInitialized()) return false;
  }
  if (_internal_has_range_scan()) {
    if (!range_scan_->IsInitialized()) return false;
  }
  if (_internal_has_aggr()) {
    if (!aggr_->IsInitialized()) return false;
  }
  return true;
}

void AnyPlan::InternalSwap(AnyPlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnyPlan, aggr_)
      + sizeof(AnyPlan::aggr_)
      - PROTOBUF_FIELD_OFFSET(AnyPlan, get_plan_)>(
          reinterpret_cast<char*>(&get_plan_),
          reinterpret_cast<char*>(&other->get_plan_));
  swap(plan_type_, other->plan_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnyPlan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[22]);
}

// ===================================================================

class ExecPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<ExecPlan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::Transaction& transaction(const ExecPlan* msg);
  static void set_has_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::AnyPlan& plan(const ExecPlan* msg);
  static void set_has_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_plan_digest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reset_error(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_compact_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_snapshot_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_commit_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_use_cts_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_chunk_result(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_feed_back(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_trace_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_audit_str(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_capabilities(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_mark_distributed(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_query_via_flashback_area(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::PolarXRPC::ExecPlan::Transaction&
ExecPlan::_Internal::transaction(const ExecPlan* msg) {
  return *msg->transaction_;
}
const ::PolarXRPC::ExecPlan::AnyPlan&
ExecPlan::_Internal::plan(const ExecPlan* msg) {
  return *msg->plan_;
}
void ExecPlan::clear_parameters() {
  parameters_.Clear();
}
void ExecPlan::clear_session_variables() {
  session_variables_.Clear();
}
ExecPlan::ExecPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  parameters_(arena),
  session_variables_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.ExecPlan)
}
ExecPlan::ExecPlan(const ExecPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      parameters_(from.parameters_),
      session_variables_(from.session_variables_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  plan_digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    plan_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_plan_digest()) {
    plan_digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_plan_digest(), 
      GetArenaForAllocation());
  }
  trace_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trace_id()) {
    trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_trace_id(), 
      GetArenaForAllocation());
  }
  audit_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    audit_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audit_str()) {
    audit_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_audit_str(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_transaction()) {
    transaction_ = new ::PolarXRPC::ExecPlan::Transaction(*from.transaction_);
  } else {
    transaction_ = nullptr;
  }
  if (from._internal_has_plan()) {
    plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.plan_);
  } else {
    plan_ = nullptr;
  }
  ::memcpy(&token_, &from.token_,
    static_cast<size_t>(reinterpret_cast<char*>(&query_via_flashback_area_) -
    reinterpret_cast<char*>(&token_)) + sizeof(query_via_flashback_area_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.ExecPlan)
}

inline void ExecPlan::SharedCtor() {
plan_digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  plan_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trace_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
audit_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  audit_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&transaction_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&query_via_flashback_area_) -
    reinterpret_cast<char*>(&transaction_)) + sizeof(query_via_flashback_area_));
}

ExecPlan::~ExecPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.ExecPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ExecPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  plan_digest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  trace_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  audit_str_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete transaction_;
  if (this != internal_default_instance()) delete plan_;
}

void ExecPlan::ArenaDtor(void* object) {
  ExecPlan* _this = reinterpret_cast< ExecPlan* >(object);
  (void)_this;
}
void ExecPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExecPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExecPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.ExecPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parameters_.Clear();
  session_variables_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      plan_digest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      trace_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      audit_str_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(transaction_ != nullptr);
      transaction_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(plan_ != nullptr);
      plan_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&token_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&compact_metadata_) -
        reinterpret_cast<char*>(&token_)) + sizeof(compact_metadata_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&use_cts_transaction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&query_via_flashback_area_) -
        reinterpret_cast<char*>(&use_cts_transaction_)) + sizeof(query_via_flashback_area_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExecPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes plan_digest = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_plan_digest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_session_variables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 token = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_token(&has_bits);
          token_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reset_error = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_reset_error(&has_bits);
          reset_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool compact_metadata = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_compact_metadata(&has_bits);
          compact_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 snapshot_seq = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_snapshot_seq(&has_bits);
          snapshot_seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 commit_seq = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_commit_seq(&has_bits);
          commit_seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool chunk_result = 11 [default = false];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_chunk_result(&has_bits);
          chunk_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_cts_transaction = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_use_cts_transaction(&has_bits);
          use_cts_transaction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool feed_back = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_feed_back(&has_bits);
          feed_back_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes trace_id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_trace_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes audit_str = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_audit_str();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 capabilities = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_capabilities(&has_bits);
          capabilities_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mark_distributed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_mark_distributed(&has_bits);
          mark_distributed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool query_via_flashback_area = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_query_via_flashback_area(&has_bits);
          query_via_flashback_area_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExecPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.ExecPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::transaction(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::plan(this), target, stream);
  }

  // optional bytes plan_digest = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_plan_digest(), target);
  }

  // repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_parameters_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_parameters(i), target, stream);
  }

  // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_session_variables_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_session_variables(i), target, stream);
  }

  // optional int32 token = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_token(), target);
  }

  // optional bool reset_error = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_reset_error(), target);
  }

  // optional bool compact_metadata = 8 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_compact_metadata(), target);
  }

  // optional uint64 snapshot_seq = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_snapshot_seq(), target);
  }

  // optional uint64 commit_seq = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_commit_seq(), target);
  }

  // optional bool chunk_result = 11 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_chunk_result(), target);
  }

  // optional bool use_cts_transaction = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_use_cts_transaction(), target);
  }

  // optional bool feed_back = 13 [default = false];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_feed_back(), target);
  }

  // optional bytes trace_id = 14;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_trace_id(), target);
  }

  // optional bytes audit_str = 15;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_audit_str(), target);
  }

  // optional uint64 capabilities = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(16, this->_internal_capabilities(), target);
  }

  // optional bool mark_distributed = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_mark_distributed(), target);
  }

  // optional bool query_via_flashback_area = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_query_via_flashback_area(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.ExecPlan)
  return target;
}

size_t ExecPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.ExecPlan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
  total_size += 1UL * this->_internal_session_variables_size();
  for (const auto& msg : this->session_variables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes plan_digest = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_plan_digest());
    }

    // optional bytes trace_id = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_trace_id());
    }

    // optional bytes audit_str = 15;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_audit_str());
    }

    // optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transaction_);
    }

    // optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *plan_);
    }

    // optional int32 token = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_token());
    }

    // optional bool reset_error = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool compact_metadata = 8 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool use_cts_transaction = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool chunk_result = 11 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional uint64 snapshot_seq = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_snapshot_seq());
    }

    // optional uint64 commit_seq = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_commit_seq());
    }

    // optional uint64 capabilities = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_capabilities());
    }

    // optional bool feed_back = 13 [default = false];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool mark_distributed = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool query_via_flashback_area = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExecPlan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ExecPlan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExecPlan::GetClassData() const { return &_class_data_; }

void ExecPlan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ExecPlan *>(to)->MergeFrom(
      static_cast<const ExecPlan &>(from));
}


void ExecPlan::MergeFrom(const ExecPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.ExecPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  parameters_.MergeFrom(from.parameters_);
  session_variables_.MergeFrom(from.session_variables_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_plan_digest(from._internal_plan_digest());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_trace_id(from._internal_trace_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_audit_str(from._internal_audit_str());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_transaction()->::PolarXRPC::ExecPlan::Transaction::MergeFrom(from._internal_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_plan());
    }
    if (cached_has_bits & 0x00000020u) {
      token_ = from.token_;
    }
    if (cached_has_bits & 0x00000040u) {
      reset_error_ = from.reset_error_;
    }
    if (cached_has_bits & 0x00000080u) {
      compact_metadata_ = from.compact_metadata_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      use_cts_transaction_ = from.use_cts_transaction_;
    }
    if (cached_has_bits & 0x00000200u) {
      chunk_result_ = from.chunk_result_;
    }
    if (cached_has_bits & 0x00000400u) {
      snapshot_seq_ = from.snapshot_seq_;
    }
    if (cached_has_bits & 0x00000800u) {
      commit_seq_ = from.commit_seq_;
    }
    if (cached_has_bits & 0x00001000u) {
      capabilities_ = from.capabilities_;
    }
    if (cached_has_bits & 0x00002000u) {
      feed_back_ = from.feed_back_;
    }
    if (cached_has_bits & 0x00004000u) {
      mark_distributed_ = from.mark_distributed_;
    }
    if (cached_has_bits & 0x00008000u) {
      query_via_flashback_area_ = from.query_via_flashback_area_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExecPlan::CopyFrom(const ExecPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.ExecPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecPlan::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(parameters_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(session_variables_))
    return false;
  if (_internal_has_plan()) {
    if (!plan_->IsInitialized()) return false;
  }
  return true;
}

void ExecPlan::InternalSwap(ExecPlan* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  parameters_.InternalSwap(&other->parameters_);
  session_variables_.InternalSwap(&other->session_variables_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &plan_digest_, lhs_arena,
      &other->plan_digest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &trace_id_, lhs_arena,
      &other->trace_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &audit_str_, lhs_arena,
      &other->audit_str_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExecPlan, query_via_flashback_area_)
      + sizeof(ExecPlan::query_via_flashback_area_)
      - PROTOBUF_FIELD_OFFSET(ExecPlan, transaction_)>(
          reinterpret_cast<char*>(&transaction_),
          reinterpret_cast<char*>(&other->transaction_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExecPlan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_polarx_5fexec_5fplan_2eproto_getter, &descriptor_table_polarx_5fexec_5fplan_2eproto_once,
      file_level_metadata_polarx_5fexec_5fplan_2eproto[23]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace ExecPlan
}  // namespace PolarXRPC
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::NewSession* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::NewSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::NewSession >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::CloseSession* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::CloseSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::CloseSession >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::EnumSession* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::EnumSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::EnumSession >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::SessionInfo* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::SessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::SessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::SessionInfos* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::SessionInfos >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::SessionInfos >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::TableInfo* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::TableInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::TableInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::IndexInfo* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::IndexInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::IndexInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Transaction* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Transaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Transaction >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::BloomFilter* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::BloomFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::BloomFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::GetTSO* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::GetTSO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::GetTSO >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::ResultTSO* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::ResultTSO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::ResultTSO >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::AutoSp* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::AutoSp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::AutoSp >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::KeyExpr* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::KeyExpr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::KeyExpr >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::GetExpr* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::GetExpr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::GetExpr >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::GetPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::GetPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::GetPlan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::TableScanPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::TableScanPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::TableScanPlan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::KeyOnlyRangeScan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::KeyOnlyRangeScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::KeyOnlyRangeScan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::RangeScan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::RangeScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::RangeScan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::TableProject* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::TableProject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::TableProject >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Project* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Project >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Project >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Filter* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Filter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Filter >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Aggr* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Aggr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Aggr >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::AnyPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::AnyPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::AnyPlan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::ExecPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::ExecPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::ExecPlan >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
