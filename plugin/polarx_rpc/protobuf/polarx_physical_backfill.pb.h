// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polarx_physical_backfill.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_polarx_5fphysical_5fbackfill_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_polarx_5fphysical_5fbackfill_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_polarx_5fphysical_5fbackfill_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_polarx_5fphysical_5fbackfill_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_polarx_5fphysical_5fbackfill_2eproto;
namespace PolarXRPC {
namespace PhysicalBackfill {
class DiskInfo;
struct DiskInfoDefaultTypeInternal;
extern DiskInfoDefaultTypeInternal _DiskInfo_default_instance_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FileManageOperator;
struct FileManageOperatorDefaultTypeInternal;
extern FileManageOperatorDefaultTypeInternal _FileManageOperator_default_instance_;
class FileManageOperatorResponse;
struct FileManageOperatorResponseDefaultTypeInternal;
extern FileManageOperatorResponseDefaultTypeInternal _FileManageOperatorResponse_default_instance_;
class GetFileInfoOperator;
struct GetFileInfoOperatorDefaultTypeInternal;
extern GetFileInfoOperatorDefaultTypeInternal _GetFileInfoOperator_default_instance_;
class TableInfo;
struct TableInfoDefaultTypeInternal;
extern TableInfoDefaultTypeInternal _TableInfo_default_instance_;
class TransferFileDataOperator;
struct TransferFileDataOperatorDefaultTypeInternal;
extern TransferFileDataOperatorDefaultTypeInternal _TransferFileDataOperator_default_instance_;
}  // namespace PhysicalBackfill
}  // namespace PolarXRPC
PROTOBUF_NAMESPACE_OPEN
template<> ::PolarXRPC::PhysicalBackfill::DiskInfo* Arena::CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::DiskInfo>(Arena*);
template<> ::PolarXRPC::PhysicalBackfill::FileInfo* Arena::CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::FileInfo>(Arena*);
template<> ::PolarXRPC::PhysicalBackfill::FileManageOperator* Arena::CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::FileManageOperator>(Arena*);
template<> ::PolarXRPC::PhysicalBackfill::FileManageOperatorResponse* Arena::CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::FileManageOperatorResponse>(Arena*);
template<> ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator* Arena::CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::GetFileInfoOperator>(Arena*);
template<> ::PolarXRPC::PhysicalBackfill::TableInfo* Arena::CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::TableInfo>(Arena*);
template<> ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator* Arena::CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::TransferFileDataOperator>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PolarXRPC {
namespace PhysicalBackfill {

enum GetFileInfoOperator_Type : int {
  GetFileInfoOperator_Type_CHECK_SRC_FILE_EXISTENCE = 1,
  GetFileInfoOperator_Type_CHECK_TAR_FILE_EXISTENCE = 2,
  GetFileInfoOperator_Type_GET_TAR_IBD_DIR = 3,
  GetFileInfoOperator_Type_GET_SRC_FILE_LEN = 4,
  GetFileInfoOperator_Type_GET_SRC_DIR_FREE_SPACE = 5,
  GetFileInfoOperator_Type_GET_TAR_DIR_FREE_SPACE = 6,
  GetFileInfoOperator_Type_GET_SRC_IBD_TEMP_DIR = 7,
  GetFileInfoOperator_Type_GET_TAR_FILE_LEN = 8
};
bool GetFileInfoOperator_Type_IsValid(int value);
constexpr GetFileInfoOperator_Type GetFileInfoOperator_Type_Type_MIN = GetFileInfoOperator_Type_CHECK_SRC_FILE_EXISTENCE;
constexpr GetFileInfoOperator_Type GetFileInfoOperator_Type_Type_MAX = GetFileInfoOperator_Type_GET_TAR_FILE_LEN;
constexpr int GetFileInfoOperator_Type_Type_ARRAYSIZE = GetFileInfoOperator_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetFileInfoOperator_Type_descriptor();
template<typename T>
inline const std::string& GetFileInfoOperator_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetFileInfoOperator_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetFileInfoOperator_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetFileInfoOperator_Type_descriptor(), enum_t_value);
}
inline bool GetFileInfoOperator_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetFileInfoOperator_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetFileInfoOperator_Type>(
    GetFileInfoOperator_Type_descriptor(), name, value);
}
enum TransferFileDataOperator_Type : int {
  TransferFileDataOperator_Type_GET_DATA_FROM_SRC_IBD = 1,
  TransferFileDataOperator_Type_PUT_DATA_TO_TAR_IBD = 2
};
bool TransferFileDataOperator_Type_IsValid(int value);
constexpr TransferFileDataOperator_Type TransferFileDataOperator_Type_Type_MIN = TransferFileDataOperator_Type_GET_DATA_FROM_SRC_IBD;
constexpr TransferFileDataOperator_Type TransferFileDataOperator_Type_Type_MAX = TransferFileDataOperator_Type_PUT_DATA_TO_TAR_IBD;
constexpr int TransferFileDataOperator_Type_Type_ARRAYSIZE = TransferFileDataOperator_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferFileDataOperator_Type_descriptor();
template<typename T>
inline const std::string& TransferFileDataOperator_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransferFileDataOperator_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransferFileDataOperator_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransferFileDataOperator_Type_descriptor(), enum_t_value);
}
inline bool TransferFileDataOperator_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransferFileDataOperator_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransferFileDataOperator_Type>(
    TransferFileDataOperator_Type_descriptor(), name, value);
}
enum FileManageOperator_Type : int {
  FileManageOperator_Type_CREATE_TEMP_DIR_IN_SRC = 1,
  FileManageOperator_Type_COPY_IBD_TO_TEMP_DIR_IN_SRC = 2,
  FileManageOperator_Type_DELETE_IBD_FROM_TEMP_DIR_IN_SRC = 3,
  FileManageOperator_Type_FLUSH_TABLE_IN_SRC = 4,
  FileManageOperator_Type_UNLOCK_TABLE_IN_SRC = 5,
  FileManageOperator_Type_DELETE_TEMP_DIR_IN_SRC = 6,
  FileManageOperator_Type_FALLOCATE_IBD = 7
};
bool FileManageOperator_Type_IsValid(int value);
constexpr FileManageOperator_Type FileManageOperator_Type_Type_MIN = FileManageOperator_Type_CREATE_TEMP_DIR_IN_SRC;
constexpr FileManageOperator_Type FileManageOperator_Type_Type_MAX = FileManageOperator_Type_FALLOCATE_IBD;
constexpr int FileManageOperator_Type_Type_ARRAYSIZE = FileManageOperator_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileManageOperator_Type_descriptor();
template<typename T>
inline const std::string& FileManageOperator_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileManageOperator_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileManageOperator_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileManageOperator_Type_descriptor(), enum_t_value);
}
inline bool FileManageOperator_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileManageOperator_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileManageOperator_Type>(
    FileManageOperator_Type_descriptor(), name, value);
}
// ===================================================================

class TableInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.PhysicalBackfill.TableInfo) */ {
 public:
  inline TableInfo() : TableInfo(nullptr) {}
  ~TableInfo() override;
  explicit constexpr TableInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableInfo(const TableInfo& from);
  TableInfo(TableInfo&& from) noexcept
    : TableInfo() {
    *this = ::std::move(from);
  }

  inline TableInfo& operator=(const TableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableInfo& operator=(TableInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableInfo* internal_default_instance() {
    return reinterpret_cast<const TableInfo*>(
               &_TableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TableInfo& a, TableInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TableInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.PhysicalBackfill.TableInfo";
  }
  protected:
  explicit TableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalPartitionNameFieldNumber = 4,
    kFileInfoFieldNumber = 5,
    kTableSchemaFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kPartitionedFieldNumber = 3,
  };
  // repeated string physical_partition_name = 4;
  int physical_partition_name_size() const;
  private:
  int _internal_physical_partition_name_size() const;
  public:
  void clear_physical_partition_name();
  const std::string& physical_partition_name(int index) const;
  std::string* mutable_physical_partition_name(int index);
  void set_physical_partition_name(int index, const std::string& value);
  void set_physical_partition_name(int index, std::string&& value);
  void set_physical_partition_name(int index, const char* value);
  void set_physical_partition_name(int index, const char* value, size_t size);
  std::string* add_physical_partition_name();
  void add_physical_partition_name(const std::string& value);
  void add_physical_partition_name(std::string&& value);
  void add_physical_partition_name(const char* value);
  void add_physical_partition_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& physical_partition_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_physical_partition_name();
  private:
  const std::string& _internal_physical_partition_name(int index) const;
  std::string* _internal_add_physical_partition_name();
  public:

  // repeated .PolarXRPC.PhysicalBackfill.FileInfo file_info = 5;
  int file_info_size() const;
  private:
  int _internal_file_info_size() const;
  public:
  void clear_file_info();
  ::PolarXRPC::PhysicalBackfill::FileInfo* mutable_file_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::PhysicalBackfill::FileInfo >*
      mutable_file_info();
  private:
  const ::PolarXRPC::PhysicalBackfill::FileInfo& _internal_file_info(int index) const;
  ::PolarXRPC::PhysicalBackfill::FileInfo* _internal_add_file_info();
  public:
  const ::PolarXRPC::PhysicalBackfill::FileInfo& file_info(int index) const;
  ::PolarXRPC::PhysicalBackfill::FileInfo* add_file_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::PhysicalBackfill::FileInfo >&
      file_info() const;

  // required string table_schema = 1;
  bool has_table_schema() const;
  private:
  bool _internal_has_table_schema() const;
  public:
  void clear_table_schema();
  const std::string& table_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_schema();
  PROTOBUF_NODISCARD std::string* release_table_schema();
  void set_allocated_table_schema(std::string* table_schema);
  private:
  const std::string& _internal_table_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_schema(const std::string& value);
  std::string* _internal_mutable_table_schema();
  public:

  // required string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // required bool partitioned = 3;
  bool has_partitioned() const;
  private:
  bool _internal_has_partitioned() const;
  public:
  void clear_partitioned();
  bool partitioned() const;
  void set_partitioned(bool value);
  private:
  bool _internal_partitioned() const;
  void _internal_set_partitioned(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.PhysicalBackfill.TableInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> physical_partition_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::PhysicalBackfill::FileInfo > file_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_schema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  bool partitioned_;
  friend struct ::TableStruct_polarx_5fphysical_5fbackfill_2eproto;
};
// -------------------------------------------------------------------

class FileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.PhysicalBackfill.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() override;
  explicit constexpr FileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.PhysicalBackfill.FileInfo";
  }
  protected:
  explicit FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectoryFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kPartitionNameFieldNumber = 3,
    kDataSizeFieldNumber = 4,
    kExistenceFieldNumber = 5,
    kTempFileFieldNumber = 6,
  };
  // required string directory = 1;
  bool has_directory() const;
  private:
  bool _internal_has_directory() const;
  public:
  void clear_directory();
  const std::string& directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directory();
  PROTOBUF_NODISCARD std::string* release_directory();
  void set_allocated_directory(std::string* directory);
  private:
  const std::string& _internal_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory(const std::string& value);
  std::string* _internal_mutable_directory();
  public:

  // required string file_name = 2;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // required string partition_name = 3 [default = ""];
  bool has_partition_name() const;
  private:
  bool _internal_has_partition_name() const;
  public:
  void clear_partition_name();
  const std::string& partition_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_name();
  PROTOBUF_NODISCARD std::string* release_partition_name();
  void set_allocated_partition_name(std::string* partition_name);
  private:
  const std::string& _internal_partition_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_name(const std::string& value);
  std::string* _internal_mutable_partition_name();
  public:

  // optional uint64 data_size = 4;
  bool has_data_size() const;
  private:
  bool _internal_has_data_size() const;
  public:
  void clear_data_size();
  uint64_t data_size() const;
  void set_data_size(uint64_t value);
  private:
  uint64_t _internal_data_size() const;
  void _internal_set_data_size(uint64_t value);
  public:

  // optional bool existence = 5;
  bool has_existence() const;
  private:
  bool _internal_has_existence() const;
  public:
  void clear_existence();
  bool existence() const;
  void set_existence(bool value);
  private:
  bool _internal_existence() const;
  void _internal_set_existence(bool value);
  public:

  // optional bool temp_file = 6;
  bool has_temp_file() const;
  private:
  bool _internal_has_temp_file() const;
  public:
  void clear_temp_file();
  bool temp_file() const;
  void set_temp_file(bool value);
  private:
  bool _internal_temp_file() const;
  void _internal_set_temp_file(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.PhysicalBackfill.FileInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_name_;
  uint64_t data_size_;
  bool existence_;
  bool temp_file_;
  friend struct ::TableStruct_polarx_5fphysical_5fbackfill_2eproto;
};
// -------------------------------------------------------------------

class DiskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.PhysicalBackfill.DiskInfo) */ {
 public:
  inline DiskInfo() : DiskInfo(nullptr) {}
  ~DiskInfo() override;
  explicit constexpr DiskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskInfo(const DiskInfo& from);
  DiskInfo(DiskInfo&& from) noexcept
    : DiskInfo() {
    *this = ::std::move(from);
  }

  inline DiskInfo& operator=(const DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskInfo& operator=(DiskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskInfo* internal_default_instance() {
    return reinterpret_cast<const DiskInfo*>(
               &_DiskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DiskInfo& a, DiskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DiskInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.PhysicalBackfill.DiskInfo";
  }
  protected:
  explicit DiskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectoryFieldNumber = 1,
    kTotalSizeFieldNumber = 2,
    kFreeSizeFieldNumber = 3,
    kUsedSizeFieldNumber = 4,
  };
  // required string directory = 1;
  bool has_directory() const;
  private:
  bool _internal_has_directory() const;
  public:
  void clear_directory();
  const std::string& directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directory();
  PROTOBUF_NODISCARD std::string* release_directory();
  void set_allocated_directory(std::string* directory);
  private:
  const std::string& _internal_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory(const std::string& value);
  std::string* _internal_mutable_directory();
  public:

  // optional uint64 total_size = 2;
  bool has_total_size() const;
  private:
  bool _internal_has_total_size() const;
  public:
  void clear_total_size();
  uint64_t total_size() const;
  void set_total_size(uint64_t value);
  private:
  uint64_t _internal_total_size() const;
  void _internal_set_total_size(uint64_t value);
  public:

  // optional uint64 free_size = 3;
  bool has_free_size() const;
  private:
  bool _internal_has_free_size() const;
  public:
  void clear_free_size();
  uint64_t free_size() const;
  void set_free_size(uint64_t value);
  private:
  uint64_t _internal_free_size() const;
  void _internal_set_free_size(uint64_t value);
  public:

  // optional uint64 used_size = 4;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  uint64_t used_size() const;
  void set_used_size(uint64_t value);
  private:
  uint64_t _internal_used_size() const;
  void _internal_set_used_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.PhysicalBackfill.DiskInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_;
  uint64_t total_size_;
  uint64_t free_size_;
  uint64_t used_size_;
  friend struct ::TableStruct_polarx_5fphysical_5fbackfill_2eproto;
};
// -------------------------------------------------------------------

class GetFileInfoOperator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.PhysicalBackfill.GetFileInfoOperator) */ {
 public:
  inline GetFileInfoOperator() : GetFileInfoOperator(nullptr) {}
  ~GetFileInfoOperator() override;
  explicit constexpr GetFileInfoOperator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileInfoOperator(const GetFileInfoOperator& from);
  GetFileInfoOperator(GetFileInfoOperator&& from) noexcept
    : GetFileInfoOperator() {
    *this = ::std::move(from);
  }

  inline GetFileInfoOperator& operator=(const GetFileInfoOperator& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileInfoOperator& operator=(GetFileInfoOperator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileInfoOperator& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileInfoOperator* internal_default_instance() {
    return reinterpret_cast<const GetFileInfoOperator*>(
               &_GetFileInfoOperator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetFileInfoOperator& a, GetFileInfoOperator& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileInfoOperator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileInfoOperator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileInfoOperator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileInfoOperator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileInfoOperator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileInfoOperator& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileInfoOperator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.PhysicalBackfill.GetFileInfoOperator";
  }
  protected:
  explicit GetFileInfoOperator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetFileInfoOperator_Type Type;
  static constexpr Type CHECK_SRC_FILE_EXISTENCE =
    GetFileInfoOperator_Type_CHECK_SRC_FILE_EXISTENCE;
  static constexpr Type CHECK_TAR_FILE_EXISTENCE =
    GetFileInfoOperator_Type_CHECK_TAR_FILE_EXISTENCE;
  static constexpr Type GET_TAR_IBD_DIR =
    GetFileInfoOperator_Type_GET_TAR_IBD_DIR;
  static constexpr Type GET_SRC_FILE_LEN =
    GetFileInfoOperator_Type_GET_SRC_FILE_LEN;
  static constexpr Type GET_SRC_DIR_FREE_SPACE =
    GetFileInfoOperator_Type_GET_SRC_DIR_FREE_SPACE;
  static constexpr Type GET_TAR_DIR_FREE_SPACE =
    GetFileInfoOperator_Type_GET_TAR_DIR_FREE_SPACE;
  static constexpr Type GET_SRC_IBD_TEMP_DIR =
    GetFileInfoOperator_Type_GET_SRC_IBD_TEMP_DIR;
  static constexpr Type GET_TAR_FILE_LEN =
    GetFileInfoOperator_Type_GET_TAR_FILE_LEN;
  static inline bool Type_IsValid(int value) {
    return GetFileInfoOperator_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    GetFileInfoOperator_Type_Type_MIN;
  static constexpr Type Type_MAX =
    GetFileInfoOperator_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    GetFileInfoOperator_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return GetFileInfoOperator_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return GetFileInfoOperator_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return GetFileInfoOperator_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTableInfoFieldNumber = 2,
    kDiskInfoFieldNumber = 3,
    kOperatorTypeFieldNumber = 1,
  };
  // optional .PolarXRPC.PhysicalBackfill.TableInfo table_info = 2;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const ::PolarXRPC::PhysicalBackfill::TableInfo& table_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::PhysicalBackfill::TableInfo* release_table_info();
  ::PolarXRPC::PhysicalBackfill::TableInfo* mutable_table_info();
  void set_allocated_table_info(::PolarXRPC::PhysicalBackfill::TableInfo* table_info);
  private:
  const ::PolarXRPC::PhysicalBackfill::TableInfo& _internal_table_info() const;
  ::PolarXRPC::PhysicalBackfill::TableInfo* _internal_mutable_table_info();
  public:
  void unsafe_arena_set_allocated_table_info(
      ::PolarXRPC::PhysicalBackfill::TableInfo* table_info);
  ::PolarXRPC::PhysicalBackfill::TableInfo* unsafe_arena_release_table_info();

  // optional .PolarXRPC.PhysicalBackfill.DiskInfo disk_info = 3;
  bool has_disk_info() const;
  private:
  bool _internal_has_disk_info() const;
  public:
  void clear_disk_info();
  const ::PolarXRPC::PhysicalBackfill::DiskInfo& disk_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::PhysicalBackfill::DiskInfo* release_disk_info();
  ::PolarXRPC::PhysicalBackfill::DiskInfo* mutable_disk_info();
  void set_allocated_disk_info(::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info);
  private:
  const ::PolarXRPC::PhysicalBackfill::DiskInfo& _internal_disk_info() const;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* _internal_mutable_disk_info();
  public:
  void unsafe_arena_set_allocated_disk_info(
      ::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info);
  ::PolarXRPC::PhysicalBackfill::DiskInfo* unsafe_arena_release_disk_info();

  // required .PolarXRPC.PhysicalBackfill.GetFileInfoOperator.Type operator_type = 1;
  bool has_operator_type() const;
  private:
  bool _internal_has_operator_type() const;
  public:
  void clear_operator_type();
  ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type operator_type() const;
  void set_operator_type(::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type value);
  private:
  ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type _internal_operator_type() const;
  void _internal_set_operator_type(::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.PhysicalBackfill.GetFileInfoOperator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::PhysicalBackfill::TableInfo* table_info_;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info_;
  int operator_type_;
  friend struct ::TableStruct_polarx_5fphysical_5fbackfill_2eproto;
};
// -------------------------------------------------------------------

class TransferFileDataOperator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.PhysicalBackfill.TransferFileDataOperator) */ {
 public:
  inline TransferFileDataOperator() : TransferFileDataOperator(nullptr) {}
  ~TransferFileDataOperator() override;
  explicit constexpr TransferFileDataOperator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferFileDataOperator(const TransferFileDataOperator& from);
  TransferFileDataOperator(TransferFileDataOperator&& from) noexcept
    : TransferFileDataOperator() {
    *this = ::std::move(from);
  }

  inline TransferFileDataOperator& operator=(const TransferFileDataOperator& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferFileDataOperator& operator=(TransferFileDataOperator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferFileDataOperator& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferFileDataOperator* internal_default_instance() {
    return reinterpret_cast<const TransferFileDataOperator*>(
               &_TransferFileDataOperator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TransferFileDataOperator& a, TransferFileDataOperator& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferFileDataOperator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferFileDataOperator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferFileDataOperator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferFileDataOperator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferFileDataOperator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferFileDataOperator& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferFileDataOperator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.PhysicalBackfill.TransferFileDataOperator";
  }
  protected:
  explicit TransferFileDataOperator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransferFileDataOperator_Type Type;
  static constexpr Type GET_DATA_FROM_SRC_IBD =
    TransferFileDataOperator_Type_GET_DATA_FROM_SRC_IBD;
  static constexpr Type PUT_DATA_TO_TAR_IBD =
    TransferFileDataOperator_Type_PUT_DATA_TO_TAR_IBD;
  static inline bool Type_IsValid(int value) {
    return TransferFileDataOperator_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TransferFileDataOperator_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TransferFileDataOperator_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TransferFileDataOperator_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return TransferFileDataOperator_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TransferFileDataOperator_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TransferFileDataOperator_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 5,
    kFileInfoFieldNumber = 2,
    kDiskInfoFieldNumber = 3,
    kBufferLenFieldNumber = 4,
    kOffsetFieldNumber = 6,
    kOperatorTypeFieldNumber = 1,
  };
  // optional bytes buffer = 5;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // required .PolarXRPC.PhysicalBackfill.FileInfo file_info = 2;
  bool has_file_info() const;
  private:
  bool _internal_has_file_info() const;
  public:
  void clear_file_info();
  const ::PolarXRPC::PhysicalBackfill::FileInfo& file_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::PhysicalBackfill::FileInfo* release_file_info();
  ::PolarXRPC::PhysicalBackfill::FileInfo* mutable_file_info();
  void set_allocated_file_info(::PolarXRPC::PhysicalBackfill::FileInfo* file_info);
  private:
  const ::PolarXRPC::PhysicalBackfill::FileInfo& _internal_file_info() const;
  ::PolarXRPC::PhysicalBackfill::FileInfo* _internal_mutable_file_info();
  public:
  void unsafe_arena_set_allocated_file_info(
      ::PolarXRPC::PhysicalBackfill::FileInfo* file_info);
  ::PolarXRPC::PhysicalBackfill::FileInfo* unsafe_arena_release_file_info();

  // optional .PolarXRPC.PhysicalBackfill.DiskInfo disk_info = 3;
  bool has_disk_info() const;
  private:
  bool _internal_has_disk_info() const;
  public:
  void clear_disk_info();
  const ::PolarXRPC::PhysicalBackfill::DiskInfo& disk_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::PhysicalBackfill::DiskInfo* release_disk_info();
  ::PolarXRPC::PhysicalBackfill::DiskInfo* mutable_disk_info();
  void set_allocated_disk_info(::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info);
  private:
  const ::PolarXRPC::PhysicalBackfill::DiskInfo& _internal_disk_info() const;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* _internal_mutable_disk_info();
  public:
  void unsafe_arena_set_allocated_disk_info(
      ::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info);
  ::PolarXRPC::PhysicalBackfill::DiskInfo* unsafe_arena_release_disk_info();

  // required uint64 buffer_len = 4;
  bool has_buffer_len() const;
  private:
  bool _internal_has_buffer_len() const;
  public:
  void clear_buffer_len();
  uint64_t buffer_len() const;
  void set_buffer_len(uint64_t value);
  private:
  uint64_t _internal_buffer_len() const;
  void _internal_set_buffer_len(uint64_t value);
  public:

  // required uint64 offset = 6;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // required .PolarXRPC.PhysicalBackfill.TransferFileDataOperator.Type operator_type = 1;
  bool has_operator_type() const;
  private:
  bool _internal_has_operator_type() const;
  public:
  void clear_operator_type();
  ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type operator_type() const;
  void set_operator_type(::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type value);
  private:
  ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type _internal_operator_type() const;
  void _internal_set_operator_type(::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.PhysicalBackfill.TransferFileDataOperator)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  ::PolarXRPC::PhysicalBackfill::FileInfo* file_info_;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info_;
  uint64_t buffer_len_;
  uint64_t offset_;
  int operator_type_;
  friend struct ::TableStruct_polarx_5fphysical_5fbackfill_2eproto;
};
// -------------------------------------------------------------------

class FileManageOperator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.PhysicalBackfill.FileManageOperator) */ {
 public:
  inline FileManageOperator() : FileManageOperator(nullptr) {}
  ~FileManageOperator() override;
  explicit constexpr FileManageOperator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileManageOperator(const FileManageOperator& from);
  FileManageOperator(FileManageOperator&& from) noexcept
    : FileManageOperator() {
    *this = ::std::move(from);
  }

  inline FileManageOperator& operator=(const FileManageOperator& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileManageOperator& operator=(FileManageOperator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileManageOperator& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileManageOperator* internal_default_instance() {
    return reinterpret_cast<const FileManageOperator*>(
               &_FileManageOperator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FileManageOperator& a, FileManageOperator& b) {
    a.Swap(&b);
  }
  inline void Swap(FileManageOperator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileManageOperator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileManageOperator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileManageOperator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileManageOperator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileManageOperator& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileManageOperator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.PhysicalBackfill.FileManageOperator";
  }
  protected:
  explicit FileManageOperator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FileManageOperator_Type Type;
  static constexpr Type CREATE_TEMP_DIR_IN_SRC =
    FileManageOperator_Type_CREATE_TEMP_DIR_IN_SRC;
  static constexpr Type COPY_IBD_TO_TEMP_DIR_IN_SRC =
    FileManageOperator_Type_COPY_IBD_TO_TEMP_DIR_IN_SRC;
  static constexpr Type DELETE_IBD_FROM_TEMP_DIR_IN_SRC =
    FileManageOperator_Type_DELETE_IBD_FROM_TEMP_DIR_IN_SRC;
  static constexpr Type FLUSH_TABLE_IN_SRC =
    FileManageOperator_Type_FLUSH_TABLE_IN_SRC;
  static constexpr Type UNLOCK_TABLE_IN_SRC =
    FileManageOperator_Type_UNLOCK_TABLE_IN_SRC;
  static constexpr Type DELETE_TEMP_DIR_IN_SRC =
    FileManageOperator_Type_DELETE_TEMP_DIR_IN_SRC;
  static constexpr Type FALLOCATE_IBD =
    FileManageOperator_Type_FALLOCATE_IBD;
  static inline bool Type_IsValid(int value) {
    return FileManageOperator_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    FileManageOperator_Type_Type_MIN;
  static constexpr Type Type_MAX =
    FileManageOperator_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    FileManageOperator_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return FileManageOperator_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return FileManageOperator_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return FileManageOperator_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTableInfoFieldNumber = 2,
    kOperatorTypeFieldNumber = 1,
  };
  // optional .PolarXRPC.PhysicalBackfill.TableInfo table_info = 2;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const ::PolarXRPC::PhysicalBackfill::TableInfo& table_info() const;
  PROTOBUF_NODISCARD ::PolarXRPC::PhysicalBackfill::TableInfo* release_table_info();
  ::PolarXRPC::PhysicalBackfill::TableInfo* mutable_table_info();
  void set_allocated_table_info(::PolarXRPC::PhysicalBackfill::TableInfo* table_info);
  private:
  const ::PolarXRPC::PhysicalBackfill::TableInfo& _internal_table_info() const;
  ::PolarXRPC::PhysicalBackfill::TableInfo* _internal_mutable_table_info();
  public:
  void unsafe_arena_set_allocated_table_info(
      ::PolarXRPC::PhysicalBackfill::TableInfo* table_info);
  ::PolarXRPC::PhysicalBackfill::TableInfo* unsafe_arena_release_table_info();

  // required .PolarXRPC.PhysicalBackfill.FileManageOperator.Type operator_type = 1;
  bool has_operator_type() const;
  private:
  bool _internal_has_operator_type() const;
  public:
  void clear_operator_type();
  ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type operator_type() const;
  void set_operator_type(::PolarXRPC::PhysicalBackfill::FileManageOperator_Type value);
  private:
  ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type _internal_operator_type() const;
  void _internal_set_operator_type(::PolarXRPC::PhysicalBackfill::FileManageOperator_Type value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.PhysicalBackfill.FileManageOperator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PolarXRPC::PhysicalBackfill::TableInfo* table_info_;
  int operator_type_;
  friend struct ::TableStruct_polarx_5fphysical_5fbackfill_2eproto;
};
// -------------------------------------------------------------------

class FileManageOperatorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse) */ {
 public:
  inline FileManageOperatorResponse() : FileManageOperatorResponse(nullptr) {}
  ~FileManageOperatorResponse() override;
  explicit constexpr FileManageOperatorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileManageOperatorResponse(const FileManageOperatorResponse& from);
  FileManageOperatorResponse(FileManageOperatorResponse&& from) noexcept
    : FileManageOperatorResponse() {
    *this = ::std::move(from);
  }

  inline FileManageOperatorResponse& operator=(const FileManageOperatorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileManageOperatorResponse& operator=(FileManageOperatorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileManageOperatorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileManageOperatorResponse* internal_default_instance() {
    return reinterpret_cast<const FileManageOperatorResponse*>(
               &_FileManageOperatorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FileManageOperatorResponse& a, FileManageOperatorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FileManageOperatorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileManageOperatorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileManageOperatorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileManageOperatorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileManageOperatorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileManageOperatorResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileManageOperatorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.PhysicalBackfill.FileManageOperatorResponse";
  }
  protected:
  explicit FileManageOperatorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional string detail = 2;
  bool has_detail() const;
  private:
  bool _internal_has_detail() const;
  public:
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // required bool result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  bool result_;
  friend struct ::TableStruct_polarx_5fphysical_5fbackfill_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TableInfo

// required string table_schema = 1;
inline bool TableInfo::_internal_has_table_schema() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableInfo::has_table_schema() const {
  return _internal_has_table_schema();
}
inline void TableInfo::clear_table_schema() {
  table_schema_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableInfo::table_schema() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TableInfo.table_schema)
  return _internal_table_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableInfo::set_table_schema(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TableInfo.table_schema)
}
inline std::string* TableInfo::mutable_table_schema() {
  std::string* _s = _internal_mutable_table_schema();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.TableInfo.table_schema)
  return _s;
}
inline const std::string& TableInfo::_internal_table_schema() const {
  return table_schema_.Get();
}
inline void TableInfo::_internal_set_table_schema(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TableInfo::_internal_mutable_table_schema() {
  _has_bits_[0] |= 0x00000001u;
  return table_schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TableInfo::release_table_schema() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.TableInfo.table_schema)
  if (!_internal_has_table_schema()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = table_schema_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_schema_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_schema_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableInfo::set_allocated_table_schema(std::string* table_schema) {
  if (table_schema != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_schema,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_schema_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_schema_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.TableInfo.table_schema)
}

// required string table_name = 2;
inline bool TableInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void TableInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TableInfo::table_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TableInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TableInfo.table_name)
}
inline std::string* TableInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.TableInfo.table_name)
  return _s;
}
inline const std::string& TableInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void TableInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TableInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TableInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.TableInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.TableInfo.table_name)
}

// required bool partitioned = 3;
inline bool TableInfo::_internal_has_partitioned() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableInfo::has_partitioned() const {
  return _internal_has_partitioned();
}
inline void TableInfo::clear_partitioned() {
  partitioned_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TableInfo::_internal_partitioned() const {
  return partitioned_;
}
inline bool TableInfo::partitioned() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TableInfo.partitioned)
  return _internal_partitioned();
}
inline void TableInfo::_internal_set_partitioned(bool value) {
  _has_bits_[0] |= 0x00000004u;
  partitioned_ = value;
}
inline void TableInfo::set_partitioned(bool value) {
  _internal_set_partitioned(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TableInfo.partitioned)
}

// repeated string physical_partition_name = 4;
inline int TableInfo::_internal_physical_partition_name_size() const {
  return physical_partition_name_.size();
}
inline int TableInfo::physical_partition_name_size() const {
  return _internal_physical_partition_name_size();
}
inline void TableInfo::clear_physical_partition_name() {
  physical_partition_name_.Clear();
}
inline std::string* TableInfo::add_physical_partition_name() {
  std::string* _s = _internal_add_physical_partition_name();
  // @@protoc_insertion_point(field_add_mutable:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
  return _s;
}
inline const std::string& TableInfo::_internal_physical_partition_name(int index) const {
  return physical_partition_name_.Get(index);
}
inline const std::string& TableInfo::physical_partition_name(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
  return _internal_physical_partition_name(index);
}
inline std::string* TableInfo::mutable_physical_partition_name(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
  return physical_partition_name_.Mutable(index);
}
inline void TableInfo::set_physical_partition_name(int index, const std::string& value) {
  physical_partition_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline void TableInfo::set_physical_partition_name(int index, std::string&& value) {
  physical_partition_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline void TableInfo::set_physical_partition_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  physical_partition_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline void TableInfo::set_physical_partition_name(int index, const char* value, size_t size) {
  physical_partition_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline std::string* TableInfo::_internal_add_physical_partition_name() {
  return physical_partition_name_.Add();
}
inline void TableInfo::add_physical_partition_name(const std::string& value) {
  physical_partition_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline void TableInfo::add_physical_partition_name(std::string&& value) {
  physical_partition_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline void TableInfo::add_physical_partition_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  physical_partition_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline void TableInfo::add_physical_partition_name(const char* value, size_t size) {
  physical_partition_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TableInfo::physical_partition_name() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
  return physical_partition_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TableInfo::mutable_physical_partition_name() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.PhysicalBackfill.TableInfo.physical_partition_name)
  return &physical_partition_name_;
}

// repeated .PolarXRPC.PhysicalBackfill.FileInfo file_info = 5;
inline int TableInfo::_internal_file_info_size() const {
  return file_info_.size();
}
inline int TableInfo::file_info_size() const {
  return _internal_file_info_size();
}
inline void TableInfo::clear_file_info() {
  file_info_.Clear();
}
inline ::PolarXRPC::PhysicalBackfill::FileInfo* TableInfo::mutable_file_info(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.TableInfo.file_info)
  return file_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::PhysicalBackfill::FileInfo >*
TableInfo::mutable_file_info() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.PhysicalBackfill.TableInfo.file_info)
  return &file_info_;
}
inline const ::PolarXRPC::PhysicalBackfill::FileInfo& TableInfo::_internal_file_info(int index) const {
  return file_info_.Get(index);
}
inline const ::PolarXRPC::PhysicalBackfill::FileInfo& TableInfo::file_info(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TableInfo.file_info)
  return _internal_file_info(index);
}
inline ::PolarXRPC::PhysicalBackfill::FileInfo* TableInfo::_internal_add_file_info() {
  return file_info_.Add();
}
inline ::PolarXRPC::PhysicalBackfill::FileInfo* TableInfo::add_file_info() {
  ::PolarXRPC::PhysicalBackfill::FileInfo* _add = _internal_add_file_info();
  // @@protoc_insertion_point(field_add:PolarXRPC.PhysicalBackfill.TableInfo.file_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::PhysicalBackfill::FileInfo >&
TableInfo::file_info() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.PhysicalBackfill.TableInfo.file_info)
  return file_info_;
}

// -------------------------------------------------------------------

// FileInfo

// required string directory = 1;
inline bool FileInfo::_internal_has_directory() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileInfo::has_directory() const {
  return _internal_has_directory();
}
inline void FileInfo::clear_directory() {
  directory_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileInfo::directory() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileInfo.directory)
  return _internal_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_directory(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileInfo.directory)
}
inline std::string* FileInfo::mutable_directory() {
  std::string* _s = _internal_mutable_directory();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.FileInfo.directory)
  return _s;
}
inline const std::string& FileInfo::_internal_directory() const {
  return directory_.Get();
}
inline void FileInfo::_internal_set_directory(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_directory() {
  _has_bits_[0] |= 0x00000001u;
  return directory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_directory() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.FileInfo.directory)
  if (!_internal_has_directory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = directory_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileInfo::set_allocated_directory(std::string* directory) {
  if (directory != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.FileInfo.directory)
}

// required string file_name = 2;
inline bool FileInfo::_internal_has_file_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileInfo::has_file_name() const {
  return _internal_has_file_name();
}
inline void FileInfo::clear_file_name() {
  file_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileInfo.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_file_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileInfo.file_name)
}
inline std::string* FileInfo::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.FileInfo.file_name)
  return _s;
}
inline const std::string& FileInfo::_internal_file_name() const {
  return file_name_.Get();
}
inline void FileInfo::_internal_set_file_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_file_name() {
  _has_bits_[0] |= 0x00000002u;
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.FileInfo.file_name)
  if (!_internal_has_file_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = file_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.FileInfo.file_name)
}

// required string partition_name = 3 [default = ""];
inline bool FileInfo::_internal_has_partition_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FileInfo::has_partition_name() const {
  return _internal_has_partition_name();
}
inline void FileInfo::clear_partition_name() {
  partition_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FileInfo::partition_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileInfo.partition_name)
  return _internal_partition_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_partition_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 partition_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileInfo.partition_name)
}
inline std::string* FileInfo::mutable_partition_name() {
  std::string* _s = _internal_mutable_partition_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.FileInfo.partition_name)
  return _s;
}
inline const std::string& FileInfo::_internal_partition_name() const {
  return partition_name_.Get();
}
inline void FileInfo::_internal_set_partition_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  partition_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_partition_name() {
  _has_bits_[0] |= 0x00000004u;
  return partition_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_partition_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.FileInfo.partition_name)
  if (!_internal_has_partition_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = partition_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partition_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    partition_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileInfo::set_allocated_partition_name(std::string* partition_name) {
  if (partition_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  partition_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partition_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    partition_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.FileInfo.partition_name)
}

// optional uint64 data_size = 4;
inline bool FileInfo::_internal_has_data_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FileInfo::has_data_size() const {
  return _internal_has_data_size();
}
inline void FileInfo::clear_data_size() {
  data_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t FileInfo::_internal_data_size() const {
  return data_size_;
}
inline uint64_t FileInfo::data_size() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileInfo.data_size)
  return _internal_data_size();
}
inline void FileInfo::_internal_set_data_size(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  data_size_ = value;
}
inline void FileInfo::set_data_size(uint64_t value) {
  _internal_set_data_size(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileInfo.data_size)
}

// optional bool existence = 5;
inline bool FileInfo::_internal_has_existence() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FileInfo::has_existence() const {
  return _internal_has_existence();
}
inline void FileInfo::clear_existence() {
  existence_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool FileInfo::_internal_existence() const {
  return existence_;
}
inline bool FileInfo::existence() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileInfo.existence)
  return _internal_existence();
}
inline void FileInfo::_internal_set_existence(bool value) {
  _has_bits_[0] |= 0x00000010u;
  existence_ = value;
}
inline void FileInfo::set_existence(bool value) {
  _internal_set_existence(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileInfo.existence)
}

// optional bool temp_file = 6;
inline bool FileInfo::_internal_has_temp_file() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FileInfo::has_temp_file() const {
  return _internal_has_temp_file();
}
inline void FileInfo::clear_temp_file() {
  temp_file_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool FileInfo::_internal_temp_file() const {
  return temp_file_;
}
inline bool FileInfo::temp_file() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileInfo.temp_file)
  return _internal_temp_file();
}
inline void FileInfo::_internal_set_temp_file(bool value) {
  _has_bits_[0] |= 0x00000020u;
  temp_file_ = value;
}
inline void FileInfo::set_temp_file(bool value) {
  _internal_set_temp_file(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileInfo.temp_file)
}

// -------------------------------------------------------------------

// DiskInfo

// required string directory = 1;
inline bool DiskInfo::_internal_has_directory() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DiskInfo::has_directory() const {
  return _internal_has_directory();
}
inline void DiskInfo::clear_directory() {
  directory_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DiskInfo::directory() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.DiskInfo.directory)
  return _internal_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskInfo::set_directory(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.DiskInfo.directory)
}
inline std::string* DiskInfo::mutable_directory() {
  std::string* _s = _internal_mutable_directory();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.DiskInfo.directory)
  return _s;
}
inline const std::string& DiskInfo::_internal_directory() const {
  return directory_.Get();
}
inline void DiskInfo::_internal_set_directory(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DiskInfo::_internal_mutable_directory() {
  _has_bits_[0] |= 0x00000001u;
  return directory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DiskInfo::release_directory() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.DiskInfo.directory)
  if (!_internal_has_directory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = directory_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DiskInfo::set_allocated_directory(std::string* directory) {
  if (directory != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.DiskInfo.directory)
}

// optional uint64 total_size = 2;
inline bool DiskInfo::_internal_has_total_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DiskInfo::has_total_size() const {
  return _internal_has_total_size();
}
inline void DiskInfo::clear_total_size() {
  total_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t DiskInfo::_internal_total_size() const {
  return total_size_;
}
inline uint64_t DiskInfo::total_size() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.DiskInfo.total_size)
  return _internal_total_size();
}
inline void DiskInfo::_internal_set_total_size(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  total_size_ = value;
}
inline void DiskInfo::set_total_size(uint64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.DiskInfo.total_size)
}

// optional uint64 free_size = 3;
inline bool DiskInfo::_internal_has_free_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DiskInfo::has_free_size() const {
  return _internal_has_free_size();
}
inline void DiskInfo::clear_free_size() {
  free_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DiskInfo::_internal_free_size() const {
  return free_size_;
}
inline uint64_t DiskInfo::free_size() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.DiskInfo.free_size)
  return _internal_free_size();
}
inline void DiskInfo::_internal_set_free_size(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  free_size_ = value;
}
inline void DiskInfo::set_free_size(uint64_t value) {
  _internal_set_free_size(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.DiskInfo.free_size)
}

// optional uint64 used_size = 4;
inline bool DiskInfo::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DiskInfo::has_used_size() const {
  return _internal_has_used_size();
}
inline void DiskInfo::clear_used_size() {
  used_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t DiskInfo::_internal_used_size() const {
  return used_size_;
}
inline uint64_t DiskInfo::used_size() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.DiskInfo.used_size)
  return _internal_used_size();
}
inline void DiskInfo::_internal_set_used_size(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  used_size_ = value;
}
inline void DiskInfo::set_used_size(uint64_t value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.DiskInfo.used_size)
}

// -------------------------------------------------------------------

// GetFileInfoOperator

// required .PolarXRPC.PhysicalBackfill.GetFileInfoOperator.Type operator_type = 1;
inline bool GetFileInfoOperator::_internal_has_operator_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetFileInfoOperator::has_operator_type() const {
  return _internal_has_operator_type();
}
inline void GetFileInfoOperator::clear_operator_type() {
  operator_type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type GetFileInfoOperator::_internal_operator_type() const {
  return static_cast< ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type >(operator_type_);
}
inline ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type GetFileInfoOperator::operator_type() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.operator_type)
  return _internal_operator_type();
}
inline void GetFileInfoOperator::_internal_set_operator_type(::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type value) {
  assert(::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  operator_type_ = value;
}
inline void GetFileInfoOperator::set_operator_type(::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type value) {
  _internal_set_operator_type(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.operator_type)
}

// optional .PolarXRPC.PhysicalBackfill.TableInfo table_info = 2;
inline bool GetFileInfoOperator::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || table_info_ != nullptr);
  return value;
}
inline bool GetFileInfoOperator::has_table_info() const {
  return _internal_has_table_info();
}
inline void GetFileInfoOperator::clear_table_info() {
  if (table_info_ != nullptr) table_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::PhysicalBackfill::TableInfo& GetFileInfoOperator::_internal_table_info() const {
  const ::PolarXRPC::PhysicalBackfill::TableInfo* p = table_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::PhysicalBackfill::TableInfo&>(
      ::PolarXRPC::PhysicalBackfill::_TableInfo_default_instance_);
}
inline const ::PolarXRPC::PhysicalBackfill::TableInfo& GetFileInfoOperator::table_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.table_info)
  return _internal_table_info();
}
inline void GetFileInfoOperator::unsafe_arena_set_allocated_table_info(
    ::PolarXRPC::PhysicalBackfill::TableInfo* table_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_info_);
  }
  table_info_ = table_info;
  if (table_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.table_info)
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* GetFileInfoOperator::release_table_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::PhysicalBackfill::TableInfo* temp = table_info_;
  table_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* GetFileInfoOperator::unsafe_arena_release_table_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.table_info)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::PhysicalBackfill::TableInfo* temp = table_info_;
  table_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* GetFileInfoOperator::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000001u;
  if (table_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::TableInfo>(GetArenaForAllocation());
    table_info_ = p;
  }
  return table_info_;
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* GetFileInfoOperator::mutable_table_info() {
  ::PolarXRPC::PhysicalBackfill::TableInfo* _msg = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.table_info)
  return _msg;
}
inline void GetFileInfoOperator::set_allocated_table_info(::PolarXRPC::PhysicalBackfill::TableInfo* table_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_info_;
  }
  if (table_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::PhysicalBackfill::TableInfo>::GetOwningArena(table_info);
    if (message_arena != submessage_arena) {
      table_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_info_ = table_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.table_info)
}

// optional .PolarXRPC.PhysicalBackfill.DiskInfo disk_info = 3;
inline bool GetFileInfoOperator::_internal_has_disk_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || disk_info_ != nullptr);
  return value;
}
inline bool GetFileInfoOperator::has_disk_info() const {
  return _internal_has_disk_info();
}
inline void GetFileInfoOperator::clear_disk_info() {
  if (disk_info_ != nullptr) disk_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::PhysicalBackfill::DiskInfo& GetFileInfoOperator::_internal_disk_info() const {
  const ::PolarXRPC::PhysicalBackfill::DiskInfo* p = disk_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::PhysicalBackfill::DiskInfo&>(
      ::PolarXRPC::PhysicalBackfill::_DiskInfo_default_instance_);
}
inline const ::PolarXRPC::PhysicalBackfill::DiskInfo& GetFileInfoOperator::disk_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.disk_info)
  return _internal_disk_info();
}
inline void GetFileInfoOperator::unsafe_arena_set_allocated_disk_info(
    ::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disk_info_);
  }
  disk_info_ = disk_info;
  if (disk_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.disk_info)
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* GetFileInfoOperator::release_disk_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* temp = disk_info_;
  disk_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* GetFileInfoOperator::unsafe_arena_release_disk_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.disk_info)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* temp = disk_info_;
  disk_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* GetFileInfoOperator::_internal_mutable_disk_info() {
  _has_bits_[0] |= 0x00000002u;
  if (disk_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::DiskInfo>(GetArenaForAllocation());
    disk_info_ = p;
  }
  return disk_info_;
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* GetFileInfoOperator::mutable_disk_info() {
  ::PolarXRPC::PhysicalBackfill::DiskInfo* _msg = _internal_mutable_disk_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.disk_info)
  return _msg;
}
inline void GetFileInfoOperator::set_allocated_disk_info(::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete disk_info_;
  }
  if (disk_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::PhysicalBackfill::DiskInfo>::GetOwningArena(disk_info);
    if (message_arena != submessage_arena) {
      disk_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disk_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  disk_info_ = disk_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.GetFileInfoOperator.disk_info)
}

// -------------------------------------------------------------------

// TransferFileDataOperator

// required .PolarXRPC.PhysicalBackfill.TransferFileDataOperator.Type operator_type = 1;
inline bool TransferFileDataOperator::_internal_has_operator_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TransferFileDataOperator::has_operator_type() const {
  return _internal_has_operator_type();
}
inline void TransferFileDataOperator::clear_operator_type() {
  operator_type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type TransferFileDataOperator::_internal_operator_type() const {
  return static_cast< ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type >(operator_type_);
}
inline ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type TransferFileDataOperator::operator_type() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.operator_type)
  return _internal_operator_type();
}
inline void TransferFileDataOperator::_internal_set_operator_type(::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type value) {
  assert(::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  operator_type_ = value;
}
inline void TransferFileDataOperator::set_operator_type(::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type value) {
  _internal_set_operator_type(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.operator_type)
}

// required .PolarXRPC.PhysicalBackfill.FileInfo file_info = 2;
inline bool TransferFileDataOperator::_internal_has_file_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || file_info_ != nullptr);
  return value;
}
inline bool TransferFileDataOperator::has_file_info() const {
  return _internal_has_file_info();
}
inline void TransferFileDataOperator::clear_file_info() {
  if (file_info_ != nullptr) file_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::PhysicalBackfill::FileInfo& TransferFileDataOperator::_internal_file_info() const {
  const ::PolarXRPC::PhysicalBackfill::FileInfo* p = file_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::PhysicalBackfill::FileInfo&>(
      ::PolarXRPC::PhysicalBackfill::_FileInfo_default_instance_);
}
inline const ::PolarXRPC::PhysicalBackfill::FileInfo& TransferFileDataOperator::file_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.file_info)
  return _internal_file_info();
}
inline void TransferFileDataOperator::unsafe_arena_set_allocated_file_info(
    ::PolarXRPC::PhysicalBackfill::FileInfo* file_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_info_);
  }
  file_info_ = file_info;
  if (file_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.file_info)
}
inline ::PolarXRPC::PhysicalBackfill::FileInfo* TransferFileDataOperator::release_file_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::PhysicalBackfill::FileInfo* temp = file_info_;
  file_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::FileInfo* TransferFileDataOperator::unsafe_arena_release_file_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.file_info)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::PhysicalBackfill::FileInfo* temp = file_info_;
  file_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::FileInfo* TransferFileDataOperator::_internal_mutable_file_info() {
  _has_bits_[0] |= 0x00000002u;
  if (file_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::FileInfo>(GetArenaForAllocation());
    file_info_ = p;
  }
  return file_info_;
}
inline ::PolarXRPC::PhysicalBackfill::FileInfo* TransferFileDataOperator::mutable_file_info() {
  ::PolarXRPC::PhysicalBackfill::FileInfo* _msg = _internal_mutable_file_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.file_info)
  return _msg;
}
inline void TransferFileDataOperator::set_allocated_file_info(::PolarXRPC::PhysicalBackfill::FileInfo* file_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete file_info_;
  }
  if (file_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::PhysicalBackfill::FileInfo>::GetOwningArena(file_info);
    if (message_arena != submessage_arena) {
      file_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_info_ = file_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.file_info)
}

// optional .PolarXRPC.PhysicalBackfill.DiskInfo disk_info = 3;
inline bool TransferFileDataOperator::_internal_has_disk_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || disk_info_ != nullptr);
  return value;
}
inline bool TransferFileDataOperator::has_disk_info() const {
  return _internal_has_disk_info();
}
inline void TransferFileDataOperator::clear_disk_info() {
  if (disk_info_ != nullptr) disk_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::PolarXRPC::PhysicalBackfill::DiskInfo& TransferFileDataOperator::_internal_disk_info() const {
  const ::PolarXRPC::PhysicalBackfill::DiskInfo* p = disk_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::PhysicalBackfill::DiskInfo&>(
      ::PolarXRPC::PhysicalBackfill::_DiskInfo_default_instance_);
}
inline const ::PolarXRPC::PhysicalBackfill::DiskInfo& TransferFileDataOperator::disk_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.disk_info)
  return _internal_disk_info();
}
inline void TransferFileDataOperator::unsafe_arena_set_allocated_disk_info(
    ::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disk_info_);
  }
  disk_info_ = disk_info;
  if (disk_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.disk_info)
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* TransferFileDataOperator::release_disk_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* temp = disk_info_;
  disk_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* TransferFileDataOperator::unsafe_arena_release_disk_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.disk_info)
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::PhysicalBackfill::DiskInfo* temp = disk_info_;
  disk_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* TransferFileDataOperator::_internal_mutable_disk_info() {
  _has_bits_[0] |= 0x00000004u;
  if (disk_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::DiskInfo>(GetArenaForAllocation());
    disk_info_ = p;
  }
  return disk_info_;
}
inline ::PolarXRPC::PhysicalBackfill::DiskInfo* TransferFileDataOperator::mutable_disk_info() {
  ::PolarXRPC::PhysicalBackfill::DiskInfo* _msg = _internal_mutable_disk_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.disk_info)
  return _msg;
}
inline void TransferFileDataOperator::set_allocated_disk_info(::PolarXRPC::PhysicalBackfill::DiskInfo* disk_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete disk_info_;
  }
  if (disk_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::PhysicalBackfill::DiskInfo>::GetOwningArena(disk_info);
    if (message_arena != submessage_arena) {
      disk_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disk_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  disk_info_ = disk_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.disk_info)
}

// required uint64 buffer_len = 4;
inline bool TransferFileDataOperator::_internal_has_buffer_len() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TransferFileDataOperator::has_buffer_len() const {
  return _internal_has_buffer_len();
}
inline void TransferFileDataOperator::clear_buffer_len() {
  buffer_len_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t TransferFileDataOperator::_internal_buffer_len() const {
  return buffer_len_;
}
inline uint64_t TransferFileDataOperator::buffer_len() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.buffer_len)
  return _internal_buffer_len();
}
inline void TransferFileDataOperator::_internal_set_buffer_len(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  buffer_len_ = value;
}
inline void TransferFileDataOperator::set_buffer_len(uint64_t value) {
  _internal_set_buffer_len(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.buffer_len)
}

// optional bytes buffer = 5;
inline bool TransferFileDataOperator::_internal_has_buffer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransferFileDataOperator::has_buffer() const {
  return _internal_has_buffer();
}
inline void TransferFileDataOperator::clear_buffer() {
  buffer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransferFileDataOperator::buffer() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferFileDataOperator::set_buffer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.buffer)
}
inline std::string* TransferFileDataOperator::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.buffer)
  return _s;
}
inline const std::string& TransferFileDataOperator::_internal_buffer() const {
  return buffer_.Get();
}
inline void TransferFileDataOperator::_internal_set_buffer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferFileDataOperator::_internal_mutable_buffer() {
  _has_bits_[0] |= 0x00000001u;
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferFileDataOperator::release_buffer() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.buffer)
  if (!_internal_has_buffer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = buffer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buffer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransferFileDataOperator::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buffer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.buffer)
}

// required uint64 offset = 6;
inline bool TransferFileDataOperator::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TransferFileDataOperator::has_offset() const {
  return _internal_has_offset();
}
inline void TransferFileDataOperator::clear_offset() {
  offset_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t TransferFileDataOperator::_internal_offset() const {
  return offset_;
}
inline uint64_t TransferFileDataOperator::offset() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.offset)
  return _internal_offset();
}
inline void TransferFileDataOperator::_internal_set_offset(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  offset_ = value;
}
inline void TransferFileDataOperator::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.TransferFileDataOperator.offset)
}

// -------------------------------------------------------------------

// FileManageOperator

// required .PolarXRPC.PhysicalBackfill.FileManageOperator.Type operator_type = 1;
inline bool FileManageOperator::_internal_has_operator_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileManageOperator::has_operator_type() const {
  return _internal_has_operator_type();
}
inline void FileManageOperator::clear_operator_type() {
  operator_type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type FileManageOperator::_internal_operator_type() const {
  return static_cast< ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type >(operator_type_);
}
inline ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type FileManageOperator::operator_type() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileManageOperator.operator_type)
  return _internal_operator_type();
}
inline void FileManageOperator::_internal_set_operator_type(::PolarXRPC::PhysicalBackfill::FileManageOperator_Type value) {
  assert(::PolarXRPC::PhysicalBackfill::FileManageOperator_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  operator_type_ = value;
}
inline void FileManageOperator::set_operator_type(::PolarXRPC::PhysicalBackfill::FileManageOperator_Type value) {
  _internal_set_operator_type(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileManageOperator.operator_type)
}

// optional .PolarXRPC.PhysicalBackfill.TableInfo table_info = 2;
inline bool FileManageOperator::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || table_info_ != nullptr);
  return value;
}
inline bool FileManageOperator::has_table_info() const {
  return _internal_has_table_info();
}
inline void FileManageOperator::clear_table_info() {
  if (table_info_ != nullptr) table_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::PhysicalBackfill::TableInfo& FileManageOperator::_internal_table_info() const {
  const ::PolarXRPC::PhysicalBackfill::TableInfo* p = table_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::PhysicalBackfill::TableInfo&>(
      ::PolarXRPC::PhysicalBackfill::_TableInfo_default_instance_);
}
inline const ::PolarXRPC::PhysicalBackfill::TableInfo& FileManageOperator::table_info() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileManageOperator.table_info)
  return _internal_table_info();
}
inline void FileManageOperator::unsafe_arena_set_allocated_table_info(
    ::PolarXRPC::PhysicalBackfill::TableInfo* table_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_info_);
  }
  table_info_ = table_info;
  if (table_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.PhysicalBackfill.FileManageOperator.table_info)
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* FileManageOperator::release_table_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::PhysicalBackfill::TableInfo* temp = table_info_;
  table_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* FileManageOperator::unsafe_arena_release_table_info() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.FileManageOperator.table_info)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::PhysicalBackfill::TableInfo* temp = table_info_;
  table_info_ = nullptr;
  return temp;
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* FileManageOperator::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000001u;
  if (table_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::PhysicalBackfill::TableInfo>(GetArenaForAllocation());
    table_info_ = p;
  }
  return table_info_;
}
inline ::PolarXRPC::PhysicalBackfill::TableInfo* FileManageOperator::mutable_table_info() {
  ::PolarXRPC::PhysicalBackfill::TableInfo* _msg = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.FileManageOperator.table_info)
  return _msg;
}
inline void FileManageOperator::set_allocated_table_info(::PolarXRPC::PhysicalBackfill::TableInfo* table_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_info_;
  }
  if (table_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::PhysicalBackfill::TableInfo>::GetOwningArena(table_info);
    if (message_arena != submessage_arena) {
      table_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_info_ = table_info;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.FileManageOperator.table_info)
}

// -------------------------------------------------------------------

// FileManageOperatorResponse

// required bool result = 1;
inline bool FileManageOperatorResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileManageOperatorResponse::has_result() const {
  return _internal_has_result();
}
inline void FileManageOperatorResponse::clear_result() {
  result_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool FileManageOperatorResponse::_internal_result() const {
  return result_;
}
inline bool FileManageOperatorResponse::result() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse.result)
  return _internal_result();
}
inline void FileManageOperatorResponse::_internal_set_result(bool value) {
  _has_bits_[0] |= 0x00000002u;
  result_ = value;
}
inline void FileManageOperatorResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse.result)
}

// optional string detail = 2;
inline bool FileManageOperatorResponse::_internal_has_detail() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileManageOperatorResponse::has_detail() const {
  return _internal_has_detail();
}
inline void FileManageOperatorResponse::clear_detail() {
  detail_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileManageOperatorResponse::detail() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileManageOperatorResponse::set_detail(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse.detail)
}
inline std::string* FileManageOperatorResponse::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse.detail)
  return _s;
}
inline const std::string& FileManageOperatorResponse::_internal_detail() const {
  return detail_.Get();
}
inline void FileManageOperatorResponse::_internal_set_detail(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileManageOperatorResponse::_internal_mutable_detail() {
  _has_bits_[0] |= 0x00000001u;
  return detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileManageOperatorResponse::release_detail() {
  // @@protoc_insertion_point(field_release:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse.detail)
  if (!_internal_has_detail()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = detail_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (detail_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    detail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileManageOperatorResponse::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detail,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (detail_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    detail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.PhysicalBackfill.FileManageOperatorResponse.detail)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PhysicalBackfill
}  // namespace PolarXRPC

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type>() {
  return ::PolarXRPC::PhysicalBackfill::GetFileInfoOperator_Type_descriptor();
}
template <> struct is_proto_enum< ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type>() {
  return ::PolarXRPC::PhysicalBackfill::TransferFileDataOperator_Type_descriptor();
}
template <> struct is_proto_enum< ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type>() {
  return ::PolarXRPC::PhysicalBackfill::FileManageOperator_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_polarx_5fphysical_5fbackfill_2eproto
