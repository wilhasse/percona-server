// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polarx_exec_plan.proto

#include "polarx_exec_plan.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace PolarXRPC {
namespace ExecPlan {
constexpr NewSession::NewSession(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct NewSessionDefaultTypeInternal {
  constexpr NewSessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NewSessionDefaultTypeInternal() {}
  union {
    NewSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NewSessionDefaultTypeInternal _NewSession_default_instance_;
constexpr CloseSession::CloseSession(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CloseSessionDefaultTypeInternal {
  constexpr CloseSessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CloseSessionDefaultTypeInternal() {}
  union {
    CloseSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CloseSessionDefaultTypeInternal _CloseSession_default_instance_;
constexpr EnumSession::EnumSession(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct EnumSessionDefaultTypeInternal {
  constexpr EnumSessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EnumSessionDefaultTypeInternal() {}
  union {
    EnumSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EnumSessionDefaultTypeInternal _EnumSession_default_instance_;
constexpr SessionInfo::SessionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SessionInfoDefaultTypeInternal {
  constexpr SessionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SessionInfoDefaultTypeInternal() {}
  union {
    SessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SessionInfoDefaultTypeInternal _SessionInfo_default_instance_;
constexpr SessionInfos::SessionInfos(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessions_(){}
struct SessionInfosDefaultTypeInternal {
  constexpr SessionInfosDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SessionInfosDefaultTypeInternal() {}
  union {
    SessionInfos _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SessionInfosDefaultTypeInternal _SessionInfos_default_instance_;
constexpr TableInfo::TableInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(nullptr)
  , schema_name_(nullptr)
  , version_(int64_t{0}){}
struct TableInfoDefaultTypeInternal {
  constexpr TableInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TableInfoDefaultTypeInternal() {}
  union {
    TableInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TableInfoDefaultTypeInternal _TableInfo_default_instance_;
constexpr IndexInfo::IndexInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(nullptr)
  , use_parts_(0){}
struct IndexInfoDefaultTypeInternal {
  constexpr IndexInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IndexInfoDefaultTypeInternal() {}
  union {
    IndexInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IndexInfoDefaultTypeInternal _IndexInfo_default_instance_;
constexpr Transaction::Transaction(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct TransactionDefaultTypeInternal {
  constexpr TransactionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransactionDefaultTypeInternal() {}
  union {
    Transaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransactionDefaultTypeInternal _Transaction_default_instance_;
constexpr BloomFilter::BloomFilter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : strategy_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , total_bits_(0u)
  , number_hash_(0u){}
struct BloomFilterDefaultTypeInternal {
  constexpr BloomFilterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BloomFilterDefaultTypeInternal() {}
  union {
    BloomFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BloomFilterDefaultTypeInternal _BloomFilter_default_instance_;
constexpr GetTSO::GetTSO(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : leader_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , batch_count_(0){}
struct GetTSODefaultTypeInternal {
  constexpr GetTSODefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetTSODefaultTypeInternal() {}
  union {
    GetTSO _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetTSODefaultTypeInternal _GetTSO_default_instance_;
constexpr ResultTSO::ResultTSO(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ts_(uint64_t{0u})
  , error_no_(0){}
struct ResultTSODefaultTypeInternal {
  constexpr ResultTSODefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ResultTSODefaultTypeInternal() {}
  union {
    ResultTSO _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ResultTSODefaultTypeInternal _ResultTSO_default_instance_;
constexpr AutoSp::AutoSp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sp_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , op_(0)

  , reset_error_(false){}
struct AutoSpDefaultTypeInternal {
  constexpr AutoSpDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AutoSpDefaultTypeInternal() {}
  union {
    AutoSp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AutoSpDefaultTypeInternal _AutoSp_default_instance_;
constexpr KeyExpr::KeyExpr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : field_(nullptr)
  , value_(nullptr){}
struct KeyExprDefaultTypeInternal {
  constexpr KeyExprDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyExprDefaultTypeInternal() {}
  union {
    KeyExpr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyExprDefaultTypeInternal _KeyExpr_default_instance_;
constexpr GetExpr::GetExpr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keys_(){}
struct GetExprDefaultTypeInternal {
  constexpr GetExprDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetExprDefaultTypeInternal() {}
  union {
    GetExpr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetExprDefaultTypeInternal _GetExpr_default_instance_;
constexpr GetPlan::GetPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keys_()
  , table_info_(nullptr)
  , index_info_(nullptr){}
struct GetPlanDefaultTypeInternal {
  constexpr GetPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetPlanDefaultTypeInternal() {}
  union {
    GetPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetPlanDefaultTypeInternal _GetPlan_default_instance_;
constexpr TableScanPlan::TableScanPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : table_info_(nullptr)
  , index_info_(nullptr)
  , reverse_(false){}
struct TableScanPlanDefaultTypeInternal {
  constexpr TableScanPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TableScanPlanDefaultTypeInternal() {}
  union {
    TableScanPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TableScanPlanDefaultTypeInternal _TableScanPlan_default_instance_;
constexpr KeyOnlyRangeScan::KeyOnlyRangeScan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : snapshot_(nullptr)
  , table_info_(nullptr)
  , index_info_(nullptr)
  , key_(nullptr)
  , end_key_(nullptr)
  , reverse_(false)
  , flag_(int64_t{0}){}
struct KeyOnlyRangeScanDefaultTypeInternal {
  constexpr KeyOnlyRangeScanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyOnlyRangeScanDefaultTypeInternal() {}
  union {
    KeyOnlyRangeScan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyOnlyRangeScanDefaultTypeInternal _KeyOnlyRangeScan_default_instance_;
constexpr RangeScan::RangeScan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : snapshot_(nullptr)
  , table_info_(nullptr)
  , index_info_(nullptr)
  , key_(nullptr)
  , end_key_(nullptr)
  , reverse_(false)
  , flag_(int64_t{0}){}
struct RangeScanDefaultTypeInternal {
  constexpr RangeScanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RangeScanDefaultTypeInternal() {}
  union {
    RangeScan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RangeScanDefaultTypeInternal _RangeScan_default_instance_;
constexpr TableProject::TableProject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fields_()
  , sub_read_plan_(nullptr){}
struct TableProjectDefaultTypeInternal {
  constexpr TableProjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TableProjectDefaultTypeInternal() {}
  union {
    TableProject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TableProjectDefaultTypeInternal _TableProject_default_instance_;
constexpr Project::Project(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fields_()
  , exprs_()
  , sub_read_plan_(nullptr){}
struct ProjectDefaultTypeInternal {
  constexpr ProjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ProjectDefaultTypeInternal() {}
  union {
    Project _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ProjectDefaultTypeInternal _Project_default_instance_;
constexpr Filter::Filter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sub_read_plan_(nullptr)
  , expr_(nullptr){}
struct FilterDefaultTypeInternal {
  constexpr FilterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FilterDefaultTypeInternal() {}
  union {
    Filter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FilterDefaultTypeInternal _Filter_default_instance_;
constexpr Aggr::Aggr(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sub_read_plan_(nullptr)
  , field_(nullptr)
  , expr_(nullptr)
  , type_(1)
{}
struct AggrDefaultTypeInternal {
  constexpr AggrDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AggrDefaultTypeInternal() {}
  union {
    Aggr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AggrDefaultTypeInternal _Aggr_default_instance_;
constexpr AnyPlan::AnyPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : get_plan_(nullptr)
  , table_scan_plan_(nullptr)
  , table_project_(nullptr)
  , project_(nullptr)
  , filter_(nullptr)
  , range_scan_(nullptr)
  , aggr_(nullptr)
  , plan_type_(1)
{}
struct AnyPlanDefaultTypeInternal {
  constexpr AnyPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnyPlanDefaultTypeInternal() {}
  union {
    AnyPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnyPlanDefaultTypeInternal _AnyPlan_default_instance_;
constexpr ExecPlan::ExecPlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parameters_()
  , session_variables_()
  , plan_digest_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , trace_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , audit_str_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , transaction_(nullptr)
  , plan_(nullptr)
  , token_(0)
  , reset_error_(false)
  , compact_metadata_(false)
  , use_cts_transaction_(false)
  , chunk_result_(false)
  , snapshot_seq_(uint64_t{0u})
  , commit_seq_(uint64_t{0u})
  , capabilities_(uint64_t{0u})
  , feed_back_(false)
  , mark_distributed_(false)
  , query_via_flashback_area_(false){}
struct ExecPlanDefaultTypeInternal {
  constexpr ExecPlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExecPlanDefaultTypeInternal() {}
  union {
    ExecPlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExecPlanDefaultTypeInternal _ExecPlan_default_instance_;
}  // namespace ExecPlan
}  // namespace PolarXRPC
namespace PolarXRPC {
namespace ExecPlan {
bool AutoSp_Operation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutoSp_Operation_strings[3] = {};

static const char AutoSp_Operation_names[] =
  "RELEASE"
  "ROLLBACK"
  "SET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutoSp_Operation_entries[] = {
  { {AutoSp_Operation_names + 0, 7}, 1 },
  { {AutoSp_Operation_names + 7, 8}, 2 },
  { {AutoSp_Operation_names + 15, 3}, 0 },
};

static const int AutoSp_Operation_entries_by_number[] = {
  2, // 0 -> SET
  0, // 1 -> RELEASE
  1, // 2 -> ROLLBACK
};

const std::string& AutoSp_Operation_Name(
    AutoSp_Operation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutoSp_Operation_entries,
          AutoSp_Operation_entries_by_number,
          3, AutoSp_Operation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutoSp_Operation_entries,
      AutoSp_Operation_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutoSp_Operation_strings[idx].get();
}
bool AutoSp_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutoSp_Operation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutoSp_Operation_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AutoSp_Operation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutoSp_Operation AutoSp::SET;
constexpr AutoSp_Operation AutoSp::RELEASE;
constexpr AutoSp_Operation AutoSp::ROLLBACK;
constexpr AutoSp_Operation AutoSp::Operation_MIN;
constexpr AutoSp_Operation AutoSp::Operation_MAX;
constexpr int AutoSp::Operation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Aggr_AggrType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Aggr_AggrType_strings[8] = {};

static const char Aggr_AggrType_names[] =
  "AVG_DISTINCT_FUNC"
  "AVG_FUNC"
  "COUNT_DISTINCT_FUNC"
  "COUNT_FUNC"
  "MAX_FUNC"
  "MIN_FUNC"
  "SUM_DISTINCT_FUNC"
  "SUM_FUNC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Aggr_AggrType_entries[] = {
  { {Aggr_AggrType_names + 0, 17}, 6 },
  { {Aggr_AggrType_names + 17, 8}, 5 },
  { {Aggr_AggrType_names + 25, 19}, 2 },
  { {Aggr_AggrType_names + 44, 10}, 1 },
  { {Aggr_AggrType_names + 54, 8}, 8 },
  { {Aggr_AggrType_names + 62, 8}, 7 },
  { {Aggr_AggrType_names + 70, 17}, 4 },
  { {Aggr_AggrType_names + 87, 8}, 3 },
};

static const int Aggr_AggrType_entries_by_number[] = {
  3, // 1 -> COUNT_FUNC
  2, // 2 -> COUNT_DISTINCT_FUNC
  7, // 3 -> SUM_FUNC
  6, // 4 -> SUM_DISTINCT_FUNC
  1, // 5 -> AVG_FUNC
  0, // 6 -> AVG_DISTINCT_FUNC
  5, // 7 -> MIN_FUNC
  4, // 8 -> MAX_FUNC
};

const std::string& Aggr_AggrType_Name(
    Aggr_AggrType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Aggr_AggrType_entries,
          Aggr_AggrType_entries_by_number,
          8, Aggr_AggrType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Aggr_AggrType_entries,
      Aggr_AggrType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Aggr_AggrType_strings[idx].get();
}
bool Aggr_AggrType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Aggr_AggrType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Aggr_AggrType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<Aggr_AggrType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Aggr_AggrType Aggr::COUNT_FUNC;
constexpr Aggr_AggrType Aggr::COUNT_DISTINCT_FUNC;
constexpr Aggr_AggrType Aggr::SUM_FUNC;
constexpr Aggr_AggrType Aggr::SUM_DISTINCT_FUNC;
constexpr Aggr_AggrType Aggr::AVG_FUNC;
constexpr Aggr_AggrType Aggr::AVG_DISTINCT_FUNC;
constexpr Aggr_AggrType Aggr::MIN_FUNC;
constexpr Aggr_AggrType Aggr::MAX_FUNC;
constexpr Aggr_AggrType Aggr::AggrType_MIN;
constexpr Aggr_AggrType Aggr::AggrType_MAX;
constexpr int Aggr::AggrType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AnyPlan_PlanType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AnyPlan_PlanType_strings[7] = {};

static const char AnyPlan_PlanType_names[] =
  "AGGR"
  "FILTER"
  "GET"
  "PROJECT"
  "RANGE_SCAN"
  "TABLE_PROJECT"
  "TABLE_SCAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AnyPlan_PlanType_entries[] = {
  { {AnyPlan_PlanType_names + 0, 4}, 9 },
  { {AnyPlan_PlanType_names + 4, 6}, 5 },
  { {AnyPlan_PlanType_names + 10, 3}, 1 },
  { {AnyPlan_PlanType_names + 13, 7}, 4 },
  { {AnyPlan_PlanType_names + 20, 10}, 8 },
  { {AnyPlan_PlanType_names + 30, 13}, 3 },
  { {AnyPlan_PlanType_names + 43, 10}, 2 },
};

static const int AnyPlan_PlanType_entries_by_number[] = {
  2, // 1 -> GET
  6, // 2 -> TABLE_SCAN
  5, // 3 -> TABLE_PROJECT
  3, // 4 -> PROJECT
  1, // 5 -> FILTER
  4, // 8 -> RANGE_SCAN
  0, // 9 -> AGGR
};

const std::string& AnyPlan_PlanType_Name(
    AnyPlan_PlanType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AnyPlan_PlanType_entries,
          AnyPlan_PlanType_entries_by_number,
          7, AnyPlan_PlanType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AnyPlan_PlanType_entries,
      AnyPlan_PlanType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AnyPlan_PlanType_strings[idx].get();
}
bool AnyPlan_PlanType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnyPlan_PlanType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AnyPlan_PlanType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<AnyPlan_PlanType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AnyPlan_PlanType AnyPlan::GET;
constexpr AnyPlan_PlanType AnyPlan::TABLE_SCAN;
constexpr AnyPlan_PlanType AnyPlan::TABLE_PROJECT;
constexpr AnyPlan_PlanType AnyPlan::PROJECT;
constexpr AnyPlan_PlanType AnyPlan::FILTER;
constexpr AnyPlan_PlanType AnyPlan::RANGE_SCAN;
constexpr AnyPlan_PlanType AnyPlan::AGGR;
constexpr AnyPlan_PlanType AnyPlan::PlanType_MIN;
constexpr AnyPlan_PlanType AnyPlan::PlanType_MAX;
constexpr int AnyPlan::PlanType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class NewSession::_Internal {
 public:
};

NewSession::NewSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.NewSession)
}
NewSession::NewSession(const NewSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.NewSession)
}

inline void NewSession::SharedCtor() {
}

NewSession::~NewSession() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.NewSession)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void NewSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NewSession::ArenaDtor(void* object) {
  NewSession* _this = reinterpret_cast< NewSession* >(object);
  (void)_this;
}
void NewSession::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NewSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NewSession::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.NewSession)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* NewSession::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewSession::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.NewSession)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.NewSession)
  return target;
}

size_t NewSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.NewSession)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NewSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NewSession*>(
      &from));
}

void NewSession::MergeFrom(const NewSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.NewSession)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NewSession::CopyFrom(const NewSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.NewSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewSession::IsInitialized() const {
  return true;
}

void NewSession::InternalSwap(NewSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string NewSession::GetTypeName() const {
  return "PolarXRPC.ExecPlan.NewSession";
}


// ===================================================================

class CloseSession::_Internal {
 public:
};

CloseSession::CloseSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.CloseSession)
}
CloseSession::CloseSession(const CloseSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.CloseSession)
}

inline void CloseSession::SharedCtor() {
}

CloseSession::~CloseSession() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.CloseSession)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CloseSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CloseSession::ArenaDtor(void* object) {
  CloseSession* _this = reinterpret_cast< CloseSession* >(object);
  (void)_this;
}
void CloseSession::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CloseSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CloseSession::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.CloseSession)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CloseSession::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CloseSession::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.CloseSession)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.CloseSession)
  return target;
}

size_t CloseSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.CloseSession)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CloseSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CloseSession*>(
      &from));
}

void CloseSession::MergeFrom(const CloseSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.CloseSession)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CloseSession::CopyFrom(const CloseSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.CloseSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseSession::IsInitialized() const {
  return true;
}

void CloseSession::InternalSwap(CloseSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CloseSession::GetTypeName() const {
  return "PolarXRPC.ExecPlan.CloseSession";
}


// ===================================================================

class EnumSession::_Internal {
 public:
};

EnumSession::EnumSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.EnumSession)
}
EnumSession::EnumSession(const EnumSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.EnumSession)
}

inline void EnumSession::SharedCtor() {
}

EnumSession::~EnumSession() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.EnumSession)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EnumSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EnumSession::ArenaDtor(void* object) {
  EnumSession* _this = reinterpret_cast< EnumSession* >(object);
  (void)_this;
}
void EnumSession::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EnumSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EnumSession::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.EnumSession)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* EnumSession::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnumSession::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.EnumSession)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.EnumSession)
  return target;
}

size_t EnumSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.EnumSession)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EnumSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EnumSession*>(
      &from));
}

void EnumSession::MergeFrom(const EnumSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.EnumSession)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EnumSession::CopyFrom(const EnumSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.EnumSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumSession::IsInitialized() const {
  return true;
}

void EnumSession::InternalSwap(EnumSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string EnumSession::GetTypeName() const {
  return "PolarXRPC.ExecPlan.EnumSession";
}


// ===================================================================

class SessionInfo::_Internal {
 public:
};

SessionInfo::SessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.SessionInfo)
}
SessionInfo::SessionInfo(const SessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.SessionInfo)
}

inline void SessionInfo::SharedCtor() {
}

SessionInfo::~SessionInfo() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.SessionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SessionInfo::ArenaDtor(void* object) {
  SessionInfo* _this = reinterpret_cast< SessionInfo* >(object);
  (void)_this;
}
void SessionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SessionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.SessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SessionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.SessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.SessionInfo)
  return target;
}

size_t SessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.SessionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SessionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SessionInfo*>(
      &from));
}

void SessionInfo::MergeFrom(const SessionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.SessionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionInfo::CopyFrom(const SessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.SessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionInfo::IsInitialized() const {
  return true;
}

void SessionInfo::InternalSwap(SessionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SessionInfo::GetTypeName() const {
  return "PolarXRPC.ExecPlan.SessionInfo";
}


// ===================================================================

class SessionInfos::_Internal {
 public:
};

SessionInfos::SessionInfos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  sessions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.SessionInfos)
}
SessionInfos::SessionInfos(const SessionInfos& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.SessionInfos)
}

inline void SessionInfos::SharedCtor() {
}

SessionInfos::~SessionInfos() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.SessionInfos)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SessionInfos::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SessionInfos::ArenaDtor(void* object) {
  SessionInfos* _this = reinterpret_cast< SessionInfos* >(object);
  (void)_this;
}
void SessionInfos::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SessionInfos::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SessionInfos::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.SessionInfos)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SessionInfos::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sessions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SessionInfos::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.SessionInfos)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sessions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_sessions(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.SessionInfos)
  return target;
}

size_t SessionInfos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.SessionInfos)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.SessionInfo sessions = 1;
  total_size += 1UL * this->_internal_sessions_size();
  for (const auto& msg : this->sessions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SessionInfos::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SessionInfos*>(
      &from));
}

void SessionInfos::MergeFrom(const SessionInfos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.SessionInfos)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionInfos::CopyFrom(const SessionInfos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.SessionInfos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionInfos::IsInitialized() const {
  return true;
}

void SessionInfos::InternalSwap(SessionInfos* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  sessions_.InternalSwap(&other->sessions_);
}

std::string SessionInfos::GetTypeName() const {
  return "PolarXRPC.ExecPlan.SessionInfos";
}


// ===================================================================

class TableInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TableInfo>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& name(const TableInfo* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& schema_name(const TableInfo* msg);
  static void set_has_schema_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::Datatypes::Scalar&
TableInfo::_Internal::name(const TableInfo* msg) {
  return *msg->name_;
}
const ::PolarXRPC::Datatypes::Scalar&
TableInfo::_Internal::schema_name(const TableInfo* msg) {
  return *msg->schema_name_;
}
void TableInfo::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void TableInfo::clear_schema_name() {
  if (schema_name_ != nullptr) schema_name_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
TableInfo::TableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.TableInfo)
}
TableInfo::TableInfo(const TableInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_name()) {
    name_ = new ::PolarXRPC::Datatypes::Scalar(*from.name_);
  } else {
    name_ = nullptr;
  }
  if (from._internal_has_schema_name()) {
    schema_name_ = new ::PolarXRPC::Datatypes::Scalar(*from.schema_name_);
  } else {
    schema_name_ = nullptr;
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.TableInfo)
}

inline void TableInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&name_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&name_)) + sizeof(version_));
}

TableInfo::~TableInfo() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.TableInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TableInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete name_;
  if (this != internal_default_instance()) delete schema_name_;
}

void TableInfo::ArenaDtor(void* object) {
  TableInfo* _this = reinterpret_cast< TableInfo* >(object);
  (void)_this;
}
void TableInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TableInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TableInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.TableInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(name_ != nullptr);
      name_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(schema_name_ != nullptr);
      schema_name_->Clear();
    }
  }
  version_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TableInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Datatypes.Scalar name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.TableInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 version = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_version(), target);
  }

  // required .PolarXRPC.Datatypes.Scalar name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::name(this), target, stream);
  }

  // optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::schema_name(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.TableInfo)
  return target;
}

size_t TableInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.TableInfo)
  size_t total_size = 0;

  // required .PolarXRPC.Datatypes.Scalar name = 2;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *name_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .PolarXRPC.Datatypes.Scalar schema_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *schema_name_);
    }

    // optional int64 version = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TableInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TableInfo*>(
      &from));
}

void TableInfo::MergeFrom(const TableInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.TableInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_name()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_schema_name()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_schema_name());
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TableInfo::CopyFrom(const TableInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.TableInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_name()) {
    if (!name_->IsInitialized()) return false;
  }
  if (_internal_has_schema_name()) {
    if (!schema_name_->IsInitialized()) return false;
  }
  return true;
}

void TableInfo::InternalSwap(TableInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableInfo, version_)
      + sizeof(TableInfo::version_)
      - PROTOBUF_FIELD_OFFSET(TableInfo, name_)>(
          reinterpret_cast<char*>(&name_),
          reinterpret_cast<char*>(&other->name_));
}

std::string TableInfo::GetTypeName() const {
  return "PolarXRPC.ExecPlan.TableInfo";
}


// ===================================================================

class IndexInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexInfo>()._has_bits_);
  static const ::PolarXRPC::Datatypes::Scalar& name(const IndexInfo* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_parts(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::Datatypes::Scalar&
IndexInfo::_Internal::name(const IndexInfo* msg) {
  return *msg->name_;
}
void IndexInfo::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
IndexInfo::IndexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.IndexInfo)
}
IndexInfo::IndexInfo(const IndexInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_name()) {
    name_ = new ::PolarXRPC::Datatypes::Scalar(*from.name_);
  } else {
    name_ = nullptr;
  }
  use_parts_ = from.use_parts_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.IndexInfo)
}

inline void IndexInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&name_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_parts_) -
    reinterpret_cast<char*>(&name_)) + sizeof(use_parts_));
}

IndexInfo::~IndexInfo() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.IndexInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IndexInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete name_;
}

void IndexInfo::ArenaDtor(void* object) {
  IndexInfo* _this = reinterpret_cast< IndexInfo* >(object);
  (void)_this;
}
void IndexInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IndexInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IndexInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.IndexInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(name_ != nullptr);
    name_->Clear();
  }
  use_parts_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IndexInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.Datatypes.Scalar name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 use_parts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_use_parts(&has_bits);
          use_parts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndexInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.IndexInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.Datatypes.Scalar name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::name(this), target, stream);
  }

  // optional int32 use_parts = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_use_parts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.IndexInfo)
  return target;
}

size_t IndexInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.IndexInfo)
  size_t total_size = 0;

  // required .PolarXRPC.Datatypes.Scalar name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *name_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 use_parts = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_use_parts());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IndexInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IndexInfo*>(
      &from));
}

void IndexInfo::MergeFrom(const IndexInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.IndexInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_name()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      use_parts_ = from.use_parts_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IndexInfo::CopyFrom(const IndexInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.IndexInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_name()) {
    if (!name_->IsInitialized()) return false;
  }
  return true;
}

void IndexInfo::InternalSwap(IndexInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexInfo, use_parts_)
      + sizeof(IndexInfo::use_parts_)
      - PROTOBUF_FIELD_OFFSET(IndexInfo, name_)>(
          reinterpret_cast<char*>(&name_),
          reinterpret_cast<char*>(&other->name_));
}

std::string IndexInfo::GetTypeName() const {
  return "PolarXRPC.ExecPlan.IndexInfo";
}


// ===================================================================

class Transaction::_Internal {
 public:
};

Transaction::Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Transaction)
}
Transaction::Transaction(const Transaction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Transaction)
}

inline void Transaction::SharedCtor() {
}

Transaction::~Transaction() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.Transaction)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Transaction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Transaction::ArenaDtor(void* object) {
  Transaction* _this = reinterpret_cast< Transaction* >(object);
  (void)_this;
}
void Transaction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Transaction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Transaction::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.Transaction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Transaction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Transaction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.Transaction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.Transaction)
  return target;
}

size_t Transaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.Transaction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Transaction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Transaction*>(
      &from));
}

void Transaction::MergeFrom(const Transaction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.Transaction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Transaction::CopyFrom(const Transaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.Transaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transaction::IsInitialized() const {
  return true;
}

void Transaction::InternalSwap(Transaction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Transaction::GetTypeName() const {
  return "PolarXRPC.ExecPlan.Transaction";
}


// ===================================================================

class BloomFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<BloomFilter>()._has_bits_);
  static void set_has_total_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_number_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

BloomFilter::BloomFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.BloomFilter)
}
BloomFilter::BloomFilter(const BloomFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  strategy_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    strategy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_strategy()) {
    strategy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_strategy(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&total_bits_, &from.total_bits_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_hash_) -
    reinterpret_cast<char*>(&total_bits_)) + sizeof(number_hash_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.BloomFilter)
}

inline void BloomFilter::SharedCtor() {
strategy_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  strategy_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&total_bits_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_hash_) -
    reinterpret_cast<char*>(&total_bits_)) + sizeof(number_hash_));
}

BloomFilter::~BloomFilter() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.BloomFilter)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BloomFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  strategy_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BloomFilter::ArenaDtor(void* object) {
  BloomFilter* _this = reinterpret_cast< BloomFilter* >(object);
  (void)_this;
}
void BloomFilter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BloomFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BloomFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.BloomFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      strategy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&total_bits_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_hash_) -
        reinterpret_cast<char*>(&total_bits_)) + sizeof(number_hash_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BloomFilter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 total_bits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_total_bits(&has_bits);
          total_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 number_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_number_hash(&has_bits);
          number_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes strategy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_strategy();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BloomFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.BloomFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 total_bits = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_total_bits(), target);
  }

  // required uint32 number_hash = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_number_hash(), target);
  }

  // required bytes strategy = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_strategy(), target);
  }

  // required bytes data = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.BloomFilter)
  return target;
}

size_t BloomFilter::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.BloomFilter)
  size_t total_size = 0;

  if (_internal_has_strategy()) {
    // required bytes strategy = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strategy());
  }

  if (_internal_has_data()) {
    // required bytes data = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (_internal_has_total_bits()) {
    // required uint32 total_bits = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_total_bits());
  }

  if (_internal_has_number_hash()) {
    // required uint32 number_hash = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_hash());
  }

  return total_size;
}
size_t BloomFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.BloomFilter)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes strategy = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strategy());

    // required bytes data = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

    // required uint32 total_bits = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_total_bits());

    // required uint32 number_hash = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_hash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BloomFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BloomFilter*>(
      &from));
}

void BloomFilter::MergeFrom(const BloomFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.BloomFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_strategy(from._internal_strategy());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000004u) {
      total_bits_ = from.total_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      number_hash_ = from.number_hash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BloomFilter::CopyFrom(const BloomFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.BloomFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BloomFilter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void BloomFilter::InternalSwap(BloomFilter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &strategy_, lhs_arena,
      &other->strategy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BloomFilter, number_hash_)
      + sizeof(BloomFilter::number_hash_)
      - PROTOBUF_FIELD_OFFSET(BloomFilter, total_bits_)>(
          reinterpret_cast<char*>(&total_bits_),
          reinterpret_cast<char*>(&other->total_bits_));
}

std::string BloomFilter::GetTypeName() const {
  return "PolarXRPC.ExecPlan.BloomFilter";
}


// ===================================================================

class GetTSO::_Internal {
 public:
  using HasBits = decltype(std::declval<GetTSO>()._has_bits_);
  static void set_has_leader_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_batch_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GetTSO::GetTSO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.GetTSO)
}
GetTSO::GetTSO(const GetTSO& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  leader_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    leader_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_leader_name()) {
    leader_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_leader_name(), 
      GetArenaForAllocation());
  }
  batch_count_ = from.batch_count_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.GetTSO)
}

inline void GetTSO::SharedCtor() {
leader_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  leader_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
batch_count_ = 0;
}

GetTSO::~GetTSO() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.GetTSO)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetTSO::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  leader_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetTSO::ArenaDtor(void* object) {
  GetTSO* _this = reinterpret_cast< GetTSO* >(object);
  (void)_this;
}
void GetTSO::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetTSO::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetTSO::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.GetTSO)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    leader_name_.ClearNonDefaultToEmpty();
  }
  batch_count_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetTSO::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes leader_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_leader_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 batch_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_batch_count(&has_bits);
          batch_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetTSO::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.GetTSO)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes leader_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_leader_name(), target);
  }

  // required int32 batch_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_batch_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.GetTSO)
  return target;
}

size_t GetTSO::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.GetTSO)
  size_t total_size = 0;

  if (_internal_has_leader_name()) {
    // required bytes leader_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_leader_name());
  }

  if (_internal_has_batch_count()) {
    // required int32 batch_count = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_batch_count());
  }

  return total_size;
}
size_t GetTSO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.GetTSO)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes leader_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_leader_name());

    // required int32 batch_count = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_batch_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetTSO::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetTSO*>(
      &from));
}

void GetTSO::MergeFrom(const GetTSO& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.GetTSO)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_leader_name(from._internal_leader_name());
    }
    if (cached_has_bits & 0x00000002u) {
      batch_count_ = from.batch_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetTSO::CopyFrom(const GetTSO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.GetTSO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTSO::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetTSO::InternalSwap(GetTSO* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &leader_name_, lhs_arena,
      &other->leader_name_, rhs_arena
  );
  swap(batch_count_, other->batch_count_);
}

std::string GetTSO::GetTypeName() const {
  return "PolarXRPC.ExecPlan.GetTSO";
}


// ===================================================================

class ResultTSO::_Internal {
 public:
  using HasBits = decltype(std::declval<ResultTSO>()._has_bits_);
  static void set_has_error_no(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ResultTSO::ResultTSO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.ResultTSO)
}
ResultTSO::ResultTSO(const ResultTSO& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&ts_, &from.ts_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_no_) -
    reinterpret_cast<char*>(&ts_)) + sizeof(error_no_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.ResultTSO)
}

inline void ResultTSO::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ts_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_no_) -
    reinterpret_cast<char*>(&ts_)) + sizeof(error_no_));
}

ResultTSO::~ResultTSO() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.ResultTSO)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ResultTSO::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResultTSO::ArenaDtor(void* object) {
  ResultTSO* _this = reinterpret_cast< ResultTSO* >(object);
  (void)_this;
}
void ResultTSO::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ResultTSO::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ResultTSO::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.ResultTSO)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ts_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_no_) -
        reinterpret_cast<char*>(&ts_)) + sizeof(error_no_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ResultTSO::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 error_no = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_no(&has_bits);
          error_no_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 ts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ts(&has_bits);
          ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResultTSO::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.ResultTSO)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 error_no = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_no(), target);
  }

  // required uint64 ts = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.ResultTSO)
  return target;
}

size_t ResultTSO::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.ResultTSO)
  size_t total_size = 0;

  if (_internal_has_ts()) {
    // required uint64 ts = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_ts());
  }

  if (_internal_has_error_no()) {
    // required int32 error_no = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_error_no());
  }

  return total_size;
}
size_t ResultTSO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.ResultTSO)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 ts = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_ts());

    // required int32 error_no = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_error_no());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResultTSO::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ResultTSO*>(
      &from));
}

void ResultTSO::MergeFrom(const ResultTSO& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.ResultTSO)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ts_ = from.ts_;
    }
    if (cached_has_bits & 0x00000002u) {
      error_no_ = from.error_no_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResultTSO::CopyFrom(const ResultTSO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.ResultTSO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResultTSO::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ResultTSO::InternalSwap(ResultTSO* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResultTSO, error_no_)
      + sizeof(ResultTSO::error_no_)
      - PROTOBUF_FIELD_OFFSET(ResultTSO, ts_)>(
          reinterpret_cast<char*>(&ts_),
          reinterpret_cast<char*>(&other->ts_));
}

std::string ResultTSO::GetTypeName() const {
  return "PolarXRPC.ExecPlan.ResultTSO";
}


// ===================================================================

class AutoSp::_Internal {
 public:
  using HasBits = decltype(std::declval<AutoSp>()._has_bits_);
  static void set_has_op(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sp_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reset_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AutoSp::AutoSp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.AutoSp)
}
AutoSp::AutoSp(const AutoSp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sp_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sp_name()) {
    sp_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sp_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&op_, &from.op_,
    static_cast<size_t>(reinterpret_cast<char*>(&reset_error_) -
    reinterpret_cast<char*>(&op_)) + sizeof(reset_error_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.AutoSp)
}

inline void AutoSp::SharedCtor() {
sp_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&op_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reset_error_) -
    reinterpret_cast<char*>(&op_)) + sizeof(reset_error_));
}

AutoSp::~AutoSp() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.AutoSp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AutoSp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sp_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AutoSp::ArenaDtor(void* object) {
  AutoSp* _this = reinterpret_cast< AutoSp* >(object);
  (void)_this;
}
void AutoSp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AutoSp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutoSp::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.AutoSp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sp_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&op_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reset_error_) -
        reinterpret_cast<char*>(&op_)) + sizeof(reset_error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutoSp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::ExecPlan::AutoSp_Operation_IsValid(val))) {
            _internal_set_op(static_cast<::PolarXRPC::ExecPlan::AutoSp_Operation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes sp_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sp_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reset_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reset_error(&has_bits);
          reset_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoSp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.AutoSp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op(), target);
  }

  // required bytes sp_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sp_name(), target);
  }

  // optional bool reset_error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reset_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.AutoSp)
  return target;
}

size_t AutoSp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.AutoSp)
  size_t total_size = 0;

  if (_internal_has_sp_name()) {
    // required bytes sp_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sp_name());
  }

  if (_internal_has_op()) {
    // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op());
  }

  return total_size;
}
size_t AutoSp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.AutoSp)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes sp_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sp_name());

    // required .PolarXRPC.ExecPlan.AutoSp.Operation op = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool reset_error = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutoSp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AutoSp*>(
      &from));
}

void AutoSp::MergeFrom(const AutoSp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.AutoSp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sp_name(from._internal_sp_name());
    }
    if (cached_has_bits & 0x00000002u) {
      op_ = from.op_;
    }
    if (cached_has_bits & 0x00000004u) {
      reset_error_ = from.reset_error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutoSp::CopyFrom(const AutoSp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.AutoSp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoSp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AutoSp::InternalSwap(AutoSp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sp_name_, lhs_arena,
      &other->sp_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutoSp, reset_error_)
      + sizeof(AutoSp::reset_error_)
      - PROTOBUF_FIELD_OFFSET(AutoSp, op_)>(
          reinterpret_cast<char*>(&op_),
          reinterpret_cast<char*>(&other->op_));
}

std::string AutoSp::GetTypeName() const {
  return "PolarXRPC.ExecPlan.AutoSp";
}


// ===================================================================

class KeyExpr::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyExpr>()._has_bits_);
  static const ::PolarXRPC::Datatypes::Scalar& field(const KeyExpr* msg);
  static void set_has_field(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& value(const KeyExpr* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::PolarXRPC::Datatypes::Scalar&
KeyExpr::_Internal::field(const KeyExpr* msg) {
  return *msg->field_;
}
const ::PolarXRPC::Datatypes::Scalar&
KeyExpr::_Internal::value(const KeyExpr* msg) {
  return *msg->value_;
}
void KeyExpr::clear_field() {
  if (field_ != nullptr) field_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void KeyExpr::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
KeyExpr::KeyExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.KeyExpr)
}
KeyExpr::KeyExpr(const KeyExpr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_field()) {
    field_ = new ::PolarXRPC::Datatypes::Scalar(*from.field_);
  } else {
    field_ = nullptr;
  }
  if (from._internal_has_value()) {
    value_ = new ::PolarXRPC::Datatypes::Scalar(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.KeyExpr)
}

inline void KeyExpr::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&field_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&value_) -
    reinterpret_cast<char*>(&field_)) + sizeof(value_));
}

KeyExpr::~KeyExpr() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.KeyExpr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KeyExpr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete field_;
  if (this != internal_default_instance()) delete value_;
}

void KeyExpr::ArenaDtor(void* object) {
  KeyExpr* _this = reinterpret_cast< KeyExpr* >(object);
  (void)_this;
}
void KeyExpr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyExpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyExpr::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.KeyExpr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(field_ != nullptr);
      field_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != nullptr);
      value_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyExpr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.Datatypes.Scalar field = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Datatypes.Scalar value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyExpr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.KeyExpr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.Datatypes.Scalar field = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::field(this), target, stream);
  }

  // required .PolarXRPC.Datatypes.Scalar value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::value(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.KeyExpr)
  return target;
}

size_t KeyExpr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.KeyExpr)
  size_t total_size = 0;

  if (_internal_has_field()) {
    // required .PolarXRPC.Datatypes.Scalar field = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);
  }

  if (_internal_has_value()) {
    // required .PolarXRPC.Datatypes.Scalar value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  return total_size;
}
size_t KeyExpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.KeyExpr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .PolarXRPC.Datatypes.Scalar field = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);

    // required .PolarXRPC.Datatypes.Scalar value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyExpr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KeyExpr*>(
      &from));
}

void KeyExpr::MergeFrom(const KeyExpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.KeyExpr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_field()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_field());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyExpr::CopyFrom(const KeyExpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.KeyExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyExpr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_field()) {
    if (!field_->IsInitialized()) return false;
  }
  if (_internal_has_value()) {
    if (!value_->IsInitialized()) return false;
  }
  return true;
}

void KeyExpr::InternalSwap(KeyExpr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyExpr, value_)
      + sizeof(KeyExpr::value_)
      - PROTOBUF_FIELD_OFFSET(KeyExpr, field_)>(
          reinterpret_cast<char*>(&field_),
          reinterpret_cast<char*>(&other->field_));
}

std::string KeyExpr::GetTypeName() const {
  return "PolarXRPC.ExecPlan.KeyExpr";
}


// ===================================================================

class GetExpr::_Internal {
 public:
};

GetExpr::GetExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  keys_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.GetExpr)
}
GetExpr::GetExpr(const GetExpr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      keys_(from.keys_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.GetExpr)
}

inline void GetExpr::SharedCtor() {
}

GetExpr::~GetExpr() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.GetExpr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetExpr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetExpr::ArenaDtor(void* object) {
  GetExpr* _this = reinterpret_cast< GetExpr* >(object);
  (void)_this;
}
void GetExpr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetExpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetExpr::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.GetExpr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keys_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetExpr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetExpr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.GetExpr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_keys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_keys(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.GetExpr)
  return target;
}

size_t GetExpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.GetExpr)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.KeyExpr keys = 1;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetExpr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetExpr*>(
      &from));
}

void GetExpr::MergeFrom(const GetExpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.GetExpr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  keys_.MergeFrom(from.keys_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetExpr::CopyFrom(const GetExpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.GetExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetExpr::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(keys_))
    return false;
  return true;
}

void GetExpr::InternalSwap(GetExpr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  keys_.InternalSwap(&other->keys_);
}

std::string GetExpr::GetTypeName() const {
  return "PolarXRPC.ExecPlan.GetExpr";
}


// ===================================================================

class GetPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<GetPlan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const GetPlan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const GetPlan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::TableInfo&
GetPlan::_Internal::table_info(const GetPlan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
GetPlan::_Internal::index_info(const GetPlan* msg) {
  return *msg->index_info_;
}
GetPlan::GetPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  keys_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.GetPlan)
}
GetPlan::GetPlan(const GetPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      keys_(from.keys_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.GetPlan)
}

inline void GetPlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_info_) -
    reinterpret_cast<char*>(&table_info_)) + sizeof(index_info_));
}

GetPlan::~GetPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.GetPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void GetPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
}

void GetPlan::ArenaDtor(void* object) {
  GetPlan* _this = reinterpret_cast< GetPlan* >(object);
  (void)_this;
}
void GetPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.GetPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keys_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.GetPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::index_info(this), target, stream);
  }

  // repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_keys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_keys(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.GetPlan)
  return target;
}

size_t GetPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.GetPlan)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (_internal_has_table_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *table_info_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.ExecPlan.GetExpr keys = 3;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *index_info_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetPlan::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const GetPlan*>(
      &from));
}

void GetPlan::MergeFrom(const GetPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.GetPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  keys_.MergeFrom(from.keys_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetPlan::CopyFrom(const GetPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.GetPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPlan::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(keys_))
    return false;
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  return true;
}

void GetPlan::InternalSwap(GetPlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  keys_.InternalSwap(&other->keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetPlan, index_info_)
      + sizeof(GetPlan::index_info_)
      - PROTOBUF_FIELD_OFFSET(GetPlan, table_info_)>(
          reinterpret_cast<char*>(&table_info_),
          reinterpret_cast<char*>(&other->table_info_));
}

std::string GetPlan::GetTypeName() const {
  return "PolarXRPC.ExecPlan.GetPlan";
}


// ===================================================================

class TableScanPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<TableScanPlan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const TableScanPlan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const TableScanPlan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::TableInfo&
TableScanPlan::_Internal::table_info(const TableScanPlan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
TableScanPlan::_Internal::index_info(const TableScanPlan* msg) {
  return *msg->index_info_;
}
TableScanPlan::TableScanPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.TableScanPlan)
}
TableScanPlan::TableScanPlan(const TableScanPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  reverse_ = from.reverse_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.TableScanPlan)
}

inline void TableScanPlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reverse_) -
    reinterpret_cast<char*>(&table_info_)) + sizeof(reverse_));
}

TableScanPlan::~TableScanPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.TableScanPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TableScanPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
}

void TableScanPlan::ArenaDtor(void* object) {
  TableScanPlan* _this = reinterpret_cast< TableScanPlan* >(object);
  (void)_this;
}
void TableScanPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TableScanPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TableScanPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.TableScanPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
  }
  reverse_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TableScanPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reverse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableScanPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.TableScanPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::index_info(this), target, stream);
  }

  // optional bool reverse = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reverse(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.TableScanPlan)
  return target;
}

size_t TableScanPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.TableScanPlan)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.TableInfo table_info = 1;
  if (_internal_has_table_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *table_info_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_info_);
    }

    // optional bool reverse = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TableScanPlan::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TableScanPlan*>(
      &from));
}

void TableScanPlan::MergeFrom(const TableScanPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.TableScanPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
    if (cached_has_bits & 0x00000004u) {
      reverse_ = from.reverse_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TableScanPlan::CopyFrom(const TableScanPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.TableScanPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableScanPlan::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  return true;
}

void TableScanPlan::InternalSwap(TableScanPlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableScanPlan, reverse_)
      + sizeof(TableScanPlan::reverse_)
      - PROTOBUF_FIELD_OFFSET(TableScanPlan, table_info_)>(
          reinterpret_cast<char*>(&table_info_),
          reinterpret_cast<char*>(&other->table_info_));
}

std::string TableScanPlan::GetTypeName() const {
  return "PolarXRPC.ExecPlan.TableScanPlan";
}


// ===================================================================

class KeyOnlyRangeScan::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyOnlyRangeScan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::Transaction& snapshot(const KeyOnlyRangeScan* msg);
  static void set_has_snapshot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const KeyOnlyRangeScan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const KeyOnlyRangeScan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& key(const KeyOnlyRangeScan* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& end_key(const KeyOnlyRangeScan* msg);
  static void set_has_end_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::PolarXRPC::ExecPlan::Transaction&
KeyOnlyRangeScan::_Internal::snapshot(const KeyOnlyRangeScan* msg) {
  return *msg->snapshot_;
}
const ::PolarXRPC::ExecPlan::TableInfo&
KeyOnlyRangeScan::_Internal::table_info(const KeyOnlyRangeScan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
KeyOnlyRangeScan::_Internal::index_info(const KeyOnlyRangeScan* msg) {
  return *msg->index_info_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
KeyOnlyRangeScan::_Internal::key(const KeyOnlyRangeScan* msg) {
  return *msg->key_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
KeyOnlyRangeScan::_Internal::end_key(const KeyOnlyRangeScan* msg) {
  return *msg->end_key_;
}
KeyOnlyRangeScan::KeyOnlyRangeScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
}
KeyOnlyRangeScan::KeyOnlyRangeScan(const KeyOnlyRangeScan& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_snapshot()) {
    snapshot_ = new ::PolarXRPC::ExecPlan::Transaction(*from.snapshot_);
  } else {
    snapshot_ = nullptr;
  }
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  if (from._internal_has_key()) {
    key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.key_);
  } else {
    key_ = nullptr;
  }
  if (from._internal_has_end_key()) {
    end_key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.end_key_);
  } else {
    end_key_ = nullptr;
  }
  ::memcpy(&reverse_, &from.reverse_,
    static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
}

inline void KeyOnlyRangeScan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&snapshot_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&snapshot_)) + sizeof(flag_));
}

KeyOnlyRangeScan::~KeyOnlyRangeScan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KeyOnlyRangeScan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete snapshot_;
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
  if (this != internal_default_instance()) delete key_;
  if (this != internal_default_instance()) delete end_key_;
}

void KeyOnlyRangeScan::ArenaDtor(void* object) {
  KeyOnlyRangeScan* _this = reinterpret_cast< KeyOnlyRangeScan* >(object);
  (void)_this;
}
void KeyOnlyRangeScan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyOnlyRangeScan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyOnlyRangeScan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(snapshot_ != nullptr);
      snapshot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(key_ != nullptr);
      key_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(end_key_ != nullptr);
      end_key_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&reverse_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flag_) -
        reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyOnlyRangeScan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reverse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 flag = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_flag(&has_bits);
          flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyOnlyRangeScan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::snapshot(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::index_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::key(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::end_key(this), target, stream);
  }

  // optional bool reverse = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_reverse(), target);
  }

  // optional int64 flag = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  return target;
}

size_t KeyOnlyRangeScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *snapshot_);
    }

    // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_info_);
    }

    // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_info_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *key_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_key_);
    }

    // optional bool reverse = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional int64 flag = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_flag());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyOnlyRangeScan::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KeyOnlyRangeScan*>(
      &from));
}

void KeyOnlyRangeScan::MergeFrom(const KeyOnlyRangeScan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_snapshot()->::PolarXRPC::ExecPlan::Transaction::MergeFrom(from._internal_snapshot());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_end_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_end_key());
    }
    if (cached_has_bits & 0x00000020u) {
      reverse_ = from.reverse_;
    }
    if (cached_has_bits & 0x00000040u) {
      flag_ = from.flag_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyOnlyRangeScan::CopyFrom(const KeyOnlyRangeScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.KeyOnlyRangeScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyOnlyRangeScan::IsInitialized() const {
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  if (_internal_has_key()) {
    if (!key_->IsInitialized()) return false;
  }
  if (_internal_has_end_key()) {
    if (!end_key_->IsInitialized()) return false;
  }
  return true;
}

void KeyOnlyRangeScan::InternalSwap(KeyOnlyRangeScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyOnlyRangeScan, flag_)
      + sizeof(KeyOnlyRangeScan::flag_)
      - PROTOBUF_FIELD_OFFSET(KeyOnlyRangeScan, snapshot_)>(
          reinterpret_cast<char*>(&snapshot_),
          reinterpret_cast<char*>(&other->snapshot_));
}

std::string KeyOnlyRangeScan::GetTypeName() const {
  return "PolarXRPC.ExecPlan.KeyOnlyRangeScan";
}


// ===================================================================

class RangeScan::_Internal {
 public:
  using HasBits = decltype(std::declval<RangeScan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::Transaction& snapshot(const RangeScan* msg);
  static void set_has_snapshot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::TableInfo& table_info(const RangeScan* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::ExecPlan::IndexInfo& index_info(const RangeScan* msg);
  static void set_has_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& key(const RangeScan* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::GetExpr& end_key(const RangeScan* msg);
  static void set_has_end_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::PolarXRPC::ExecPlan::Transaction&
RangeScan::_Internal::snapshot(const RangeScan* msg) {
  return *msg->snapshot_;
}
const ::PolarXRPC::ExecPlan::TableInfo&
RangeScan::_Internal::table_info(const RangeScan* msg) {
  return *msg->table_info_;
}
const ::PolarXRPC::ExecPlan::IndexInfo&
RangeScan::_Internal::index_info(const RangeScan* msg) {
  return *msg->index_info_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
RangeScan::_Internal::key(const RangeScan* msg) {
  return *msg->key_;
}
const ::PolarXRPC::ExecPlan::GetExpr&
RangeScan::_Internal::end_key(const RangeScan* msg) {
  return *msg->end_key_;
}
RangeScan::RangeScan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.RangeScan)
}
RangeScan::RangeScan(const RangeScan& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_snapshot()) {
    snapshot_ = new ::PolarXRPC::ExecPlan::Transaction(*from.snapshot_);
  } else {
    snapshot_ = nullptr;
  }
  if (from._internal_has_table_info()) {
    table_info_ = new ::PolarXRPC::ExecPlan::TableInfo(*from.table_info_);
  } else {
    table_info_ = nullptr;
  }
  if (from._internal_has_index_info()) {
    index_info_ = new ::PolarXRPC::ExecPlan::IndexInfo(*from.index_info_);
  } else {
    index_info_ = nullptr;
  }
  if (from._internal_has_key()) {
    key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.key_);
  } else {
    key_ = nullptr;
  }
  if (from._internal_has_end_key()) {
    end_key_ = new ::PolarXRPC::ExecPlan::GetExpr(*from.end_key_);
  } else {
    end_key_ = nullptr;
  }
  ::memcpy(&reverse_, &from.reverse_,
    static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.RangeScan)
}

inline void RangeScan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&snapshot_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flag_) -
    reinterpret_cast<char*>(&snapshot_)) + sizeof(flag_));
}

RangeScan::~RangeScan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.RangeScan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void RangeScan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete snapshot_;
  if (this != internal_default_instance()) delete table_info_;
  if (this != internal_default_instance()) delete index_info_;
  if (this != internal_default_instance()) delete key_;
  if (this != internal_default_instance()) delete end_key_;
}

void RangeScan::ArenaDtor(void* object) {
  RangeScan* _this = reinterpret_cast< RangeScan* >(object);
  (void)_this;
}
void RangeScan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RangeScan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RangeScan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.RangeScan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(snapshot_ != nullptr);
      snapshot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(table_info_ != nullptr);
      table_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(index_info_ != nullptr);
      index_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(key_ != nullptr);
      key_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(end_key_ != nullptr);
      end_key_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&reverse_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flag_) -
        reinterpret_cast<char*>(&reverse_)) + sizeof(flag_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RangeScan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reverse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 flag = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_flag(&has_bits);
          flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeScan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.RangeScan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::snapshot(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::table_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::index_info(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::key(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::end_key(this), target, stream);
  }

  // optional bool reverse = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_reverse(), target);
  }

  // optional int64 flag = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.RangeScan)
  return target;
}

size_t RangeScan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.RangeScan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .PolarXRPC.ExecPlan.Transaction snapshot = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *snapshot_);
    }

    // optional .PolarXRPC.ExecPlan.TableInfo table_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_info_);
    }

    // optional .PolarXRPC.ExecPlan.IndexInfo index_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *index_info_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr key = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *key_);
    }

    // optional .PolarXRPC.ExecPlan.GetExpr end_key = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_key_);
    }

    // optional bool reverse = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional int64 flag = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_flag());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RangeScan::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RangeScan*>(
      &from));
}

void RangeScan::MergeFrom(const RangeScan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.RangeScan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_snapshot()->::PolarXRPC::ExecPlan::Transaction::MergeFrom(from._internal_snapshot());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_table_info()->::PolarXRPC::ExecPlan::TableInfo::MergeFrom(from._internal_table_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_index_info()->::PolarXRPC::ExecPlan::IndexInfo::MergeFrom(from._internal_index_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_end_key()->::PolarXRPC::ExecPlan::GetExpr::MergeFrom(from._internal_end_key());
    }
    if (cached_has_bits & 0x00000020u) {
      reverse_ = from.reverse_;
    }
    if (cached_has_bits & 0x00000040u) {
      flag_ = from.flag_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RangeScan::CopyFrom(const RangeScan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.RangeScan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeScan::IsInitialized() const {
  if (_internal_has_table_info()) {
    if (!table_info_->IsInitialized()) return false;
  }
  if (_internal_has_index_info()) {
    if (!index_info_->IsInitialized()) return false;
  }
  if (_internal_has_key()) {
    if (!key_->IsInitialized()) return false;
  }
  if (_internal_has_end_key()) {
    if (!end_key_->IsInitialized()) return false;
  }
  return true;
}

void RangeScan::InternalSwap(RangeScan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeScan, flag_)
      + sizeof(RangeScan::flag_)
      - PROTOBUF_FIELD_OFFSET(RangeScan, snapshot_)>(
          reinterpret_cast<char*>(&snapshot_),
          reinterpret_cast<char*>(&other->snapshot_));
}

std::string RangeScan::GetTypeName() const {
  return "PolarXRPC.ExecPlan.RangeScan";
}


// ===================================================================

class TableProject::_Internal {
 public:
  using HasBits = decltype(std::declval<TableProject>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const TableProject* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
TableProject::_Internal::sub_read_plan(const TableProject* msg) {
  return *msg->sub_read_plan_;
}
void TableProject::clear_fields() {
  fields_.Clear();
}
TableProject::TableProject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  fields_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.TableProject)
}
TableProject::TableProject(const TableProject& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      fields_(from.fields_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.TableProject)
}

inline void TableProject::SharedCtor() {
sub_read_plan_ = nullptr;
}

TableProject::~TableProject() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.TableProject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TableProject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
}

void TableProject::ArenaDtor(void* object) {
  TableProject* _this = reinterpret_cast< TableProject* >(object);
  (void)_this;
}
void TableProject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TableProject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TableProject::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.TableProject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fields_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(sub_read_plan_ != nullptr);
    sub_read_plan_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TableProject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableProject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.TableProject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fields_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_fields(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.TableProject)
  return target;
}

size_t TableProject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.TableProject)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (_internal_has_sub_read_plan()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TableProject::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TableProject*>(
      &from));
}

void TableProject::MergeFrom(const TableProject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.TableProject)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fields_.MergeFrom(from.fields_);
  if (from._internal_has_sub_read_plan()) {
    _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TableProject::CopyFrom(const TableProject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.TableProject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableProject::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(fields_))
    return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  return true;
}

void TableProject::InternalSwap(TableProject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fields_.InternalSwap(&other->fields_);
  swap(sub_read_plan_, other->sub_read_plan_);
}

std::string TableProject::GetTypeName() const {
  return "PolarXRPC.ExecPlan.TableProject";
}


// ===================================================================

class Project::_Internal {
 public:
  using HasBits = decltype(std::declval<Project>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const Project* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
Project::_Internal::sub_read_plan(const Project* msg) {
  return *msg->sub_read_plan_;
}
void Project::clear_fields() {
  fields_.Clear();
}
void Project::clear_exprs() {
  exprs_.Clear();
}
Project::Project(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  fields_(arena),
  exprs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Project)
}
Project::Project(const Project& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      fields_(from.fields_),
      exprs_(from.exprs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Project)
}

inline void Project::SharedCtor() {
sub_read_plan_ = nullptr;
}

Project::~Project() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.Project)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Project::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
}

void Project::ArenaDtor(void* object) {
  Project* _this = reinterpret_cast< Project* >(object);
  (void)_this;
}
void Project::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Project::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Project::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.Project)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fields_.Clear();
  exprs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(sub_read_plan_ != nullptr);
    sub_read_plan_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Project::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Expr.Expr exprs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Project::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.Project)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fields_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_fields(i), target, stream);
  }

  // repeated .PolarXRPC.Expr.Expr exprs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_exprs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.Project)
  return target;
}

size_t Project::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.Project)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (_internal_has_sub_read_plan()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.Datatypes.Scalar fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PolarXRPC.Expr.Expr exprs = 3;
  total_size += 1UL * this->_internal_exprs_size();
  for (const auto& msg : this->exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Project::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Project*>(
      &from));
}

void Project::MergeFrom(const Project& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.Project)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fields_.MergeFrom(from.fields_);
  exprs_.MergeFrom(from.exprs_);
  if (from._internal_has_sub_read_plan()) {
    _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Project::CopyFrom(const Project& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.Project)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Project::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(fields_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(exprs_))
    return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  return true;
}

void Project::InternalSwap(Project* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fields_.InternalSwap(&other->fields_);
  exprs_.InternalSwap(&other->exprs_);
  swap(sub_read_plan_, other->sub_read_plan_);
}

std::string Project::GetTypeName() const {
  return "PolarXRPC.ExecPlan.Project";
}


// ===================================================================

class Filter::_Internal {
 public:
  using HasBits = decltype(std::declval<Filter>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const Filter* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::Expr::Expr& expr(const Filter* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
Filter::_Internal::sub_read_plan(const Filter* msg) {
  return *msg->sub_read_plan_;
}
const ::PolarXRPC::Expr::Expr&
Filter::_Internal::expr(const Filter* msg) {
  return *msg->expr_;
}
void Filter::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
Filter::Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Filter)
}
Filter::Filter(const Filter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  if (from._internal_has_expr()) {
    expr_ = new ::PolarXRPC::Expr::Expr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Filter)
}

inline void Filter::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sub_read_plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&expr_) -
    reinterpret_cast<char*>(&sub_read_plan_)) + sizeof(expr_));
}

Filter::~Filter() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.Filter)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Filter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
  if (this != internal_default_instance()) delete expr_;
}

void Filter::ArenaDtor(void* object) {
  Filter* _this = reinterpret_cast< Filter* >(object);
  (void)_this;
}
void Filter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Filter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Filter::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.Filter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sub_read_plan_ != nullptr);
      sub_read_plan_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Filter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Expr.Expr expr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Filter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.Filter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // required .PolarXRPC.Expr.Expr expr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.Filter)
  return target;
}

size_t Filter::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.Filter)
  size_t total_size = 0;

  if (_internal_has_sub_read_plan()) {
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }

  if (_internal_has_expr()) {
    // required .PolarXRPC.Expr.Expr expr = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);
  }

  return total_size;
}
size_t Filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.Filter)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);

    // required .PolarXRPC.Expr.Expr expr = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Filter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Filter*>(
      &from));
}

void Filter::MergeFrom(const Filter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.Filter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_expr()->::PolarXRPC::Expr::Expr::MergeFrom(from._internal_expr());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Filter::CopyFrom(const Filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.Filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  if (_internal_has_expr()) {
    if (!expr_->IsInitialized()) return false;
  }
  return true;
}

void Filter::InternalSwap(Filter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Filter, expr_)
      + sizeof(Filter::expr_)
      - PROTOBUF_FIELD_OFFSET(Filter, sub_read_plan_)>(
          reinterpret_cast<char*>(&sub_read_plan_),
          reinterpret_cast<char*>(&other->sub_read_plan_));
}

std::string Filter::GetTypeName() const {
  return "PolarXRPC.ExecPlan.Filter";
}


// ===================================================================

class Aggr::_Internal {
 public:
  using HasBits = decltype(std::declval<Aggr>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::AnyPlan& sub_read_plan(const Aggr* msg);
  static void set_has_sub_read_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::Datatypes::Scalar& field(const Aggr* msg);
  static void set_has_field(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::Expr::Expr& expr(const Aggr* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::PolarXRPC::ExecPlan::AnyPlan&
Aggr::_Internal::sub_read_plan(const Aggr* msg) {
  return *msg->sub_read_plan_;
}
const ::PolarXRPC::Datatypes::Scalar&
Aggr::_Internal::field(const Aggr* msg) {
  return *msg->field_;
}
const ::PolarXRPC::Expr::Expr&
Aggr::_Internal::expr(const Aggr* msg) {
  return *msg->expr_;
}
void Aggr::clear_field() {
  if (field_ != nullptr) field_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Aggr::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
Aggr::Aggr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.Aggr)
}
Aggr::Aggr(const Aggr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sub_read_plan()) {
    sub_read_plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.sub_read_plan_);
  } else {
    sub_read_plan_ = nullptr;
  }
  if (from._internal_has_field()) {
    field_ = new ::PolarXRPC::Datatypes::Scalar(*from.field_);
  } else {
    field_ = nullptr;
  }
  if (from._internal_has_expr()) {
    expr_ = new ::PolarXRPC::Expr::Expr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.Aggr)
}

inline void Aggr::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sub_read_plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&expr_) -
    reinterpret_cast<char*>(&sub_read_plan_)) + sizeof(expr_));
type_ = 1;
}

Aggr::~Aggr() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.Aggr)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Aggr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_read_plan_;
  if (this != internal_default_instance()) delete field_;
  if (this != internal_default_instance()) delete expr_;
}

void Aggr::ArenaDtor(void* object) {
  Aggr* _this = reinterpret_cast< Aggr* >(object);
  (void)_this;
}
void Aggr::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Aggr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Aggr::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.Aggr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sub_read_plan_ != nullptr);
      sub_read_plan_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(field_ != nullptr);
      field_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Aggr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_read_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::ExecPlan::Aggr_AggrType_IsValid(val))) {
            _internal_set_type(static_cast<::PolarXRPC::ExecPlan::Aggr_AggrType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Datatypes.Scalar field = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Expr.Expr expr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Aggr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.Aggr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_read_plan(this), target, stream);
  }

  // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // required .PolarXRPC.Datatypes.Scalar field = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::field(this), target, stream);
  }

  // required .PolarXRPC.Expr.Expr expr = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.Aggr)
  return target;
}

size_t Aggr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.ExecPlan.Aggr)
  size_t total_size = 0;

  if (_internal_has_sub_read_plan()) {
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);
  }

  if (_internal_has_field()) {
    // required .PolarXRPC.Datatypes.Scalar field = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);
  }

  if (_internal_has_expr()) {
    // required .PolarXRPC.Expr.Expr expr = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);
  }

  if (_internal_has_type()) {
    // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t Aggr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.Aggr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .PolarXRPC.ExecPlan.AnyPlan sub_read_plan = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sub_read_plan_);

    // required .PolarXRPC.Datatypes.Scalar field = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *field_);

    // required .PolarXRPC.Expr.Expr expr = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);

    // required .PolarXRPC.ExecPlan.Aggr.AggrType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Aggr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Aggr*>(
      &from));
}

void Aggr::MergeFrom(const Aggr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.Aggr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sub_read_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_sub_read_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_field()->::PolarXRPC::Datatypes::Scalar::MergeFrom(from._internal_field());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_expr()->::PolarXRPC::Expr::Expr::MergeFrom(from._internal_expr());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Aggr::CopyFrom(const Aggr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.Aggr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Aggr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_sub_read_plan()) {
    if (!sub_read_plan_->IsInitialized()) return false;
  }
  if (_internal_has_field()) {
    if (!field_->IsInitialized()) return false;
  }
  if (_internal_has_expr()) {
    if (!expr_->IsInitialized()) return false;
  }
  return true;
}

void Aggr::InternalSwap(Aggr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Aggr, expr_)
      + sizeof(Aggr::expr_)
      - PROTOBUF_FIELD_OFFSET(Aggr, sub_read_plan_)>(
          reinterpret_cast<char*>(&sub_read_plan_),
          reinterpret_cast<char*>(&other->sub_read_plan_));
  swap(type_, other->type_);
}

std::string Aggr::GetTypeName() const {
  return "PolarXRPC.ExecPlan.Aggr";
}


// ===================================================================

class AnyPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<AnyPlan>()._has_bits_);
  static void set_has_plan_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::PolarXRPC::ExecPlan::GetPlan& get_plan(const AnyPlan* msg);
  static void set_has_get_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::ExecPlan::TableScanPlan& table_scan_plan(const AnyPlan* msg);
  static void set_has_table_scan_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::ExecPlan::TableProject& table_project(const AnyPlan* msg);
  static void set_has_table_project(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PolarXRPC::ExecPlan::Project& project(const AnyPlan* msg);
  static void set_has_project(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::Filter& filter(const AnyPlan* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::PolarXRPC::ExecPlan::RangeScan& range_scan(const AnyPlan* msg);
  static void set_has_range_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::PolarXRPC::ExecPlan::Aggr& aggr(const AnyPlan* msg);
  static void set_has_aggr(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000080) ^ 0x00000080) != 0;
  }
};

const ::PolarXRPC::ExecPlan::GetPlan&
AnyPlan::_Internal::get_plan(const AnyPlan* msg) {
  return *msg->get_plan_;
}
const ::PolarXRPC::ExecPlan::TableScanPlan&
AnyPlan::_Internal::table_scan_plan(const AnyPlan* msg) {
  return *msg->table_scan_plan_;
}
const ::PolarXRPC::ExecPlan::TableProject&
AnyPlan::_Internal::table_project(const AnyPlan* msg) {
  return *msg->table_project_;
}
const ::PolarXRPC::ExecPlan::Project&
AnyPlan::_Internal::project(const AnyPlan* msg) {
  return *msg->project_;
}
const ::PolarXRPC::ExecPlan::Filter&
AnyPlan::_Internal::filter(const AnyPlan* msg) {
  return *msg->filter_;
}
const ::PolarXRPC::ExecPlan::RangeScan&
AnyPlan::_Internal::range_scan(const AnyPlan* msg) {
  return *msg->range_scan_;
}
const ::PolarXRPC::ExecPlan::Aggr&
AnyPlan::_Internal::aggr(const AnyPlan* msg) {
  return *msg->aggr_;
}
AnyPlan::AnyPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.AnyPlan)
}
AnyPlan::AnyPlan(const AnyPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_get_plan()) {
    get_plan_ = new ::PolarXRPC::ExecPlan::GetPlan(*from.get_plan_);
  } else {
    get_plan_ = nullptr;
  }
  if (from._internal_has_table_scan_plan()) {
    table_scan_plan_ = new ::PolarXRPC::ExecPlan::TableScanPlan(*from.table_scan_plan_);
  } else {
    table_scan_plan_ = nullptr;
  }
  if (from._internal_has_table_project()) {
    table_project_ = new ::PolarXRPC::ExecPlan::TableProject(*from.table_project_);
  } else {
    table_project_ = nullptr;
  }
  if (from._internal_has_project()) {
    project_ = new ::PolarXRPC::ExecPlan::Project(*from.project_);
  } else {
    project_ = nullptr;
  }
  if (from._internal_has_filter()) {
    filter_ = new ::PolarXRPC::ExecPlan::Filter(*from.filter_);
  } else {
    filter_ = nullptr;
  }
  if (from._internal_has_range_scan()) {
    range_scan_ = new ::PolarXRPC::ExecPlan::RangeScan(*from.range_scan_);
  } else {
    range_scan_ = nullptr;
  }
  if (from._internal_has_aggr()) {
    aggr_ = new ::PolarXRPC::ExecPlan::Aggr(*from.aggr_);
  } else {
    aggr_ = nullptr;
  }
  plan_type_ = from.plan_type_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.AnyPlan)
}

inline void AnyPlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&get_plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&aggr_) -
    reinterpret_cast<char*>(&get_plan_)) + sizeof(aggr_));
plan_type_ = 1;
}

AnyPlan::~AnyPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.AnyPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AnyPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete get_plan_;
  if (this != internal_default_instance()) delete table_scan_plan_;
  if (this != internal_default_instance()) delete table_project_;
  if (this != internal_default_instance()) delete project_;
  if (this != internal_default_instance()) delete filter_;
  if (this != internal_default_instance()) delete range_scan_;
  if (this != internal_default_instance()) delete aggr_;
}

void AnyPlan::ArenaDtor(void* object) {
  AnyPlan* _this = reinterpret_cast< AnyPlan* >(object);
  (void)_this;
}
void AnyPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnyPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AnyPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.AnyPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(get_plan_ != nullptr);
      get_plan_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(table_scan_plan_ != nullptr);
      table_scan_plan_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(table_project_ != nullptr);
      table_project_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(project_ != nullptr);
      project_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(filter_ != nullptr);
      filter_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(range_scan_ != nullptr);
      range_scan_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(aggr_ != nullptr);
      aggr_->Clear();
    }
    plan_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AnyPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::ExecPlan::AnyPlan_PlanType_IsValid(val))) {
            _internal_set_plan_type(static_cast<::PolarXRPC::ExecPlan::AnyPlan_PlanType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_scan_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_project(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.Project project = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_project(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.Filter filter = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_range_scan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_aggr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnyPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.AnyPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_plan_type(), target);
  }

  // optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::get_plan(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::table_scan_plan(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::table_project(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.Project project = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::project(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.Filter filter = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::filter(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::range_scan(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::aggr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.AnyPlan)
  return target;
}

size_t AnyPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.AnyPlan)
  size_t total_size = 0;

  // required .PolarXRPC.ExecPlan.AnyPlan.PlanType plan_type = 1;
  if (_internal_has_plan_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_plan_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .PolarXRPC.ExecPlan.GetPlan get_plan = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *get_plan_);
    }

    // optional .PolarXRPC.ExecPlan.TableScanPlan table_scan_plan = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_scan_plan_);
    }

    // optional .PolarXRPC.ExecPlan.TableProject table_project = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_project_);
    }

    // optional .PolarXRPC.ExecPlan.Project project = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *project_);
    }

    // optional .PolarXRPC.ExecPlan.Filter filter = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_);
    }

    // optional .PolarXRPC.ExecPlan.RangeScan range_scan = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *range_scan_);
    }

    // optional .PolarXRPC.ExecPlan.Aggr aggr = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *aggr_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AnyPlan::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AnyPlan*>(
      &from));
}

void AnyPlan::MergeFrom(const AnyPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.AnyPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_get_plan()->::PolarXRPC::ExecPlan::GetPlan::MergeFrom(from._internal_get_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_table_scan_plan()->::PolarXRPC::ExecPlan::TableScanPlan::MergeFrom(from._internal_table_scan_plan());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_table_project()->::PolarXRPC::ExecPlan::TableProject::MergeFrom(from._internal_table_project());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_project()->::PolarXRPC::ExecPlan::Project::MergeFrom(from._internal_project());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_filter()->::PolarXRPC::ExecPlan::Filter::MergeFrom(from._internal_filter());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_range_scan()->::PolarXRPC::ExecPlan::RangeScan::MergeFrom(from._internal_range_scan());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_aggr()->::PolarXRPC::ExecPlan::Aggr::MergeFrom(from._internal_aggr());
    }
    if (cached_has_bits & 0x00000080u) {
      plan_type_ = from.plan_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AnyPlan::CopyFrom(const AnyPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.AnyPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnyPlan::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_get_plan()) {
    if (!get_plan_->IsInitialized()) return false;
  }
  if (_internal_has_table_scan_plan()) {
    if (!table_scan_plan_->IsInitialized()) return false;
  }
  if (_internal_has_table_project()) {
    if (!table_project_->IsInitialized()) return false;
  }
  if (_internal_has_project()) {
    if (!project_->IsInitialized()) return false;
  }
  if (_internal_has_filter()) {
    if (!filter_->IsInitialized()) return false;
  }
  if (_internal_has_range_scan()) {
    if (!range_scan_->IsInitialized()) return false;
  }
  if (_internal_has_aggr()) {
    if (!aggr_->IsInitialized()) return false;
  }
  return true;
}

void AnyPlan::InternalSwap(AnyPlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnyPlan, aggr_)
      + sizeof(AnyPlan::aggr_)
      - PROTOBUF_FIELD_OFFSET(AnyPlan, get_plan_)>(
          reinterpret_cast<char*>(&get_plan_),
          reinterpret_cast<char*>(&other->get_plan_));
  swap(plan_type_, other->plan_type_);
}

std::string AnyPlan::GetTypeName() const {
  return "PolarXRPC.ExecPlan.AnyPlan";
}


// ===================================================================

class ExecPlan::_Internal {
 public:
  using HasBits = decltype(std::declval<ExecPlan>()._has_bits_);
  static const ::PolarXRPC::ExecPlan::Transaction& transaction(const ExecPlan* msg);
  static void set_has_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PolarXRPC::ExecPlan::AnyPlan& plan(const ExecPlan* msg);
  static void set_has_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_plan_digest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reset_error(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_compact_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_snapshot_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_commit_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_use_cts_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_chunk_result(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_feed_back(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_trace_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_audit_str(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_capabilities(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_mark_distributed(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_query_via_flashback_area(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::PolarXRPC::ExecPlan::Transaction&
ExecPlan::_Internal::transaction(const ExecPlan* msg) {
  return *msg->transaction_;
}
const ::PolarXRPC::ExecPlan::AnyPlan&
ExecPlan::_Internal::plan(const ExecPlan* msg) {
  return *msg->plan_;
}
void ExecPlan::clear_parameters() {
  parameters_.Clear();
}
void ExecPlan::clear_session_variables() {
  session_variables_.Clear();
}
ExecPlan::ExecPlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  parameters_(arena),
  session_variables_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.ExecPlan.ExecPlan)
}
ExecPlan::ExecPlan(const ExecPlan& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      parameters_(from.parameters_),
      session_variables_(from.session_variables_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  plan_digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    plan_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_plan_digest()) {
    plan_digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_plan_digest(), 
      GetArenaForAllocation());
  }
  trace_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trace_id()) {
    trace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_trace_id(), 
      GetArenaForAllocation());
  }
  audit_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    audit_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audit_str()) {
    audit_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_audit_str(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_transaction()) {
    transaction_ = new ::PolarXRPC::ExecPlan::Transaction(*from.transaction_);
  } else {
    transaction_ = nullptr;
  }
  if (from._internal_has_plan()) {
    plan_ = new ::PolarXRPC::ExecPlan::AnyPlan(*from.plan_);
  } else {
    plan_ = nullptr;
  }
  ::memcpy(&token_, &from.token_,
    static_cast<size_t>(reinterpret_cast<char*>(&query_via_flashback_area_) -
    reinterpret_cast<char*>(&token_)) + sizeof(query_via_flashback_area_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.ExecPlan.ExecPlan)
}

inline void ExecPlan::SharedCtor() {
plan_digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  plan_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trace_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
audit_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  audit_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&transaction_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&query_via_flashback_area_) -
    reinterpret_cast<char*>(&transaction_)) + sizeof(query_via_flashback_area_));
}

ExecPlan::~ExecPlan() {
  // @@protoc_insertion_point(destructor:PolarXRPC.ExecPlan.ExecPlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ExecPlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  plan_digest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  trace_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  audit_str_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete transaction_;
  if (this != internal_default_instance()) delete plan_;
}

void ExecPlan::ArenaDtor(void* object) {
  ExecPlan* _this = reinterpret_cast< ExecPlan* >(object);
  (void)_this;
}
void ExecPlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExecPlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExecPlan::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.ExecPlan.ExecPlan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parameters_.Clear();
  session_variables_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      plan_digest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      trace_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      audit_str_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(transaction_ != nullptr);
      transaction_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(plan_ != nullptr);
      plan_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&token_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&compact_metadata_) -
        reinterpret_cast<char*>(&token_)) + sizeof(compact_metadata_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&use_cts_transaction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&query_via_flashback_area_) -
        reinterpret_cast<char*>(&use_cts_transaction_)) + sizeof(query_via_flashback_area_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExecPlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes plan_digest = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_plan_digest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_session_variables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 token = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_token(&has_bits);
          token_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reset_error = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_reset_error(&has_bits);
          reset_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool compact_metadata = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_compact_metadata(&has_bits);
          compact_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 snapshot_seq = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_snapshot_seq(&has_bits);
          snapshot_seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 commit_seq = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_commit_seq(&has_bits);
          commit_seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool chunk_result = 11 [default = false];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_chunk_result(&has_bits);
          chunk_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_cts_transaction = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_use_cts_transaction(&has_bits);
          use_cts_transaction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool feed_back = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_feed_back(&has_bits);
          feed_back_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes trace_id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_trace_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes audit_str = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_audit_str();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 capabilities = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_capabilities(&has_bits);
          capabilities_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mark_distributed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_mark_distributed(&has_bits);
          mark_distributed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool query_via_flashback_area = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_query_via_flashback_area(&has_bits);
          query_via_flashback_area_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExecPlan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.ExecPlan.ExecPlan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::transaction(this), target, stream);
  }

  // optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::plan(this), target, stream);
  }

  // optional bytes plan_digest = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_plan_digest(), target);
  }

  // repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_parameters_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_parameters(i), target, stream);
  }

  // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_session_variables_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_session_variables(i), target, stream);
  }

  // optional int32 token = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_token(), target);
  }

  // optional bool reset_error = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_reset_error(), target);
  }

  // optional bool compact_metadata = 8 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_compact_metadata(), target);
  }

  // optional uint64 snapshot_seq = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_snapshot_seq(), target);
  }

  // optional uint64 commit_seq = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_commit_seq(), target);
  }

  // optional bool chunk_result = 11 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_chunk_result(), target);
  }

  // optional bool use_cts_transaction = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_use_cts_transaction(), target);
  }

  // optional bool feed_back = 13 [default = false];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_feed_back(), target);
  }

  // optional bytes trace_id = 14;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_trace_id(), target);
  }

  // optional bytes audit_str = 15;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_audit_str(), target);
  }

  // optional uint64 capabilities = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(16, this->_internal_capabilities(), target);
  }

  // optional bool mark_distributed = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_mark_distributed(), target);
  }

  // optional bool query_via_flashback_area = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_query_via_flashback_area(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.ExecPlan.ExecPlan)
  return target;
}

size_t ExecPlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.ExecPlan.ExecPlan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.Datatypes.Scalar parameters = 4;
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 5;
  total_size += 1UL * this->_internal_session_variables_size();
  for (const auto& msg : this->session_variables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes plan_digest = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_plan_digest());
    }

    // optional bytes trace_id = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_trace_id());
    }

    // optional bytes audit_str = 15;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_audit_str());
    }

    // optional .PolarXRPC.ExecPlan.Transaction transaction = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transaction_);
    }

    // optional .PolarXRPC.ExecPlan.AnyPlan plan = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *plan_);
    }

    // optional int32 token = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_token());
    }

    // optional bool reset_error = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool compact_metadata = 8 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool use_cts_transaction = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool chunk_result = 11 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional uint64 snapshot_seq = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_snapshot_seq());
    }

    // optional uint64 commit_seq = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_commit_seq());
    }

    // optional uint64 capabilities = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_capabilities());
    }

    // optional bool feed_back = 13 [default = false];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool mark_distributed = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool query_via_flashback_area = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExecPlan::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ExecPlan*>(
      &from));
}

void ExecPlan::MergeFrom(const ExecPlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.ExecPlan.ExecPlan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  parameters_.MergeFrom(from.parameters_);
  session_variables_.MergeFrom(from.session_variables_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_plan_digest(from._internal_plan_digest());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_trace_id(from._internal_trace_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_audit_str(from._internal_audit_str());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_transaction()->::PolarXRPC::ExecPlan::Transaction::MergeFrom(from._internal_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_plan()->::PolarXRPC::ExecPlan::AnyPlan::MergeFrom(from._internal_plan());
    }
    if (cached_has_bits & 0x00000020u) {
      token_ = from.token_;
    }
    if (cached_has_bits & 0x00000040u) {
      reset_error_ = from.reset_error_;
    }
    if (cached_has_bits & 0x00000080u) {
      compact_metadata_ = from.compact_metadata_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      use_cts_transaction_ = from.use_cts_transaction_;
    }
    if (cached_has_bits & 0x00000200u) {
      chunk_result_ = from.chunk_result_;
    }
    if (cached_has_bits & 0x00000400u) {
      snapshot_seq_ = from.snapshot_seq_;
    }
    if (cached_has_bits & 0x00000800u) {
      commit_seq_ = from.commit_seq_;
    }
    if (cached_has_bits & 0x00001000u) {
      capabilities_ = from.capabilities_;
    }
    if (cached_has_bits & 0x00002000u) {
      feed_back_ = from.feed_back_;
    }
    if (cached_has_bits & 0x00004000u) {
      mark_distributed_ = from.mark_distributed_;
    }
    if (cached_has_bits & 0x00008000u) {
      query_via_flashback_area_ = from.query_via_flashback_area_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExecPlan::CopyFrom(const ExecPlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.ExecPlan.ExecPlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecPlan::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(parameters_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(session_variables_))
    return false;
  if (_internal_has_plan()) {
    if (!plan_->IsInitialized()) return false;
  }
  return true;
}

void ExecPlan::InternalSwap(ExecPlan* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  parameters_.InternalSwap(&other->parameters_);
  session_variables_.InternalSwap(&other->session_variables_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &plan_digest_, lhs_arena,
      &other->plan_digest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &trace_id_, lhs_arena,
      &other->trace_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &audit_str_, lhs_arena,
      &other->audit_str_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExecPlan, query_via_flashback_area_)
      + sizeof(ExecPlan::query_via_flashback_area_)
      - PROTOBUF_FIELD_OFFSET(ExecPlan, transaction_)>(
          reinterpret_cast<char*>(&transaction_),
          reinterpret_cast<char*>(&other->transaction_));
}

std::string ExecPlan::GetTypeName() const {
  return "PolarXRPC.ExecPlan.ExecPlan";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace ExecPlan
}  // namespace PolarXRPC
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::NewSession* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::NewSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::NewSession >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::CloseSession* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::CloseSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::CloseSession >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::EnumSession* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::EnumSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::EnumSession >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::SessionInfo* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::SessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::SessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::SessionInfos* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::SessionInfos >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::SessionInfos >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::TableInfo* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::TableInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::TableInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::IndexInfo* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::IndexInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::IndexInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Transaction* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Transaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Transaction >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::BloomFilter* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::BloomFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::BloomFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::GetTSO* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::GetTSO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::GetTSO >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::ResultTSO* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::ResultTSO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::ResultTSO >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::AutoSp* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::AutoSp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::AutoSp >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::KeyExpr* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::KeyExpr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::KeyExpr >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::GetExpr* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::GetExpr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::GetExpr >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::GetPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::GetPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::GetPlan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::TableScanPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::TableScanPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::TableScanPlan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::KeyOnlyRangeScan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::KeyOnlyRangeScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::KeyOnlyRangeScan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::RangeScan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::RangeScan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::RangeScan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::TableProject* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::TableProject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::TableProject >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Project* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Project >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Project >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Filter* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Filter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Filter >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::Aggr* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::Aggr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::Aggr >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::AnyPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::AnyPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::AnyPlan >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::ExecPlan::ExecPlan* Arena::CreateMaybeMessage< ::PolarXRPC::ExecPlan::ExecPlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::ExecPlan::ExecPlan >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
