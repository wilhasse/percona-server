// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polarx_expr.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_polarx_5fexpr_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_polarx_5fexpr_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "polarx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_polarx_5fexpr_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_polarx_5fexpr_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace PolarXRPC {
namespace Expr {
class Array;
struct ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class ColumnIdentifier;
struct ColumnIdentifierDefaultTypeInternal;
extern ColumnIdentifierDefaultTypeInternal _ColumnIdentifier_default_instance_;
class DocumentPathItem;
struct DocumentPathItemDefaultTypeInternal;
extern DocumentPathItemDefaultTypeInternal _DocumentPathItem_default_instance_;
class Expr;
struct ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class FunctionCall;
struct FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class Identifier;
struct IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_ObjectField;
struct Object_ObjectFieldDefaultTypeInternal;
extern Object_ObjectFieldDefaultTypeInternal _Object_ObjectField_default_instance_;
class Operator;
struct OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
}  // namespace Expr
}  // namespace PolarXRPC
PROTOBUF_NAMESPACE_OPEN
template<> ::PolarXRPC::Expr::Array* Arena::CreateMaybeMessage<::PolarXRPC::Expr::Array>(Arena*);
template<> ::PolarXRPC::Expr::ColumnIdentifier* Arena::CreateMaybeMessage<::PolarXRPC::Expr::ColumnIdentifier>(Arena*);
template<> ::PolarXRPC::Expr::DocumentPathItem* Arena::CreateMaybeMessage<::PolarXRPC::Expr::DocumentPathItem>(Arena*);
template<> ::PolarXRPC::Expr::Expr* Arena::CreateMaybeMessage<::PolarXRPC::Expr::Expr>(Arena*);
template<> ::PolarXRPC::Expr::FunctionCall* Arena::CreateMaybeMessage<::PolarXRPC::Expr::FunctionCall>(Arena*);
template<> ::PolarXRPC::Expr::Identifier* Arena::CreateMaybeMessage<::PolarXRPC::Expr::Identifier>(Arena*);
template<> ::PolarXRPC::Expr::Object* Arena::CreateMaybeMessage<::PolarXRPC::Expr::Object>(Arena*);
template<> ::PolarXRPC::Expr::Object_ObjectField* Arena::CreateMaybeMessage<::PolarXRPC::Expr::Object_ObjectField>(Arena*);
template<> ::PolarXRPC::Expr::Operator* Arena::CreateMaybeMessage<::PolarXRPC::Expr::Operator>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PolarXRPC {
namespace Expr {

enum Expr_Type : int {
  Expr_Type_IDENT = 1,
  Expr_Type_LITERAL = 2,
  Expr_Type_VARIABLE = 3,
  Expr_Type_FUNC_CALL = 4,
  Expr_Type_OPERATOR = 5,
  Expr_Type_PLACEHOLDER = 6,
  Expr_Type_OBJECT = 7,
  Expr_Type_ARRAY = 8,
  Expr_Type_REF = 9
};
bool Expr_Type_IsValid(int value);
constexpr Expr_Type Expr_Type_Type_MIN = Expr_Type_IDENT;
constexpr Expr_Type Expr_Type_Type_MAX = Expr_Type_REF;
constexpr int Expr_Type_Type_ARRAYSIZE = Expr_Type_Type_MAX + 1;

const std::string& Expr_Type_Name(Expr_Type value);
template<typename T>
inline const std::string& Expr_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Expr_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Expr_Type_Name.");
  return Expr_Type_Name(static_cast<Expr_Type>(enum_t_value));
}
bool Expr_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Expr_Type* value);
enum DocumentPathItem_Type : int {
  DocumentPathItem_Type_MEMBER = 1,
  DocumentPathItem_Type_MEMBER_ASTERISK = 2,
  DocumentPathItem_Type_ARRAY_INDEX = 3,
  DocumentPathItem_Type_ARRAY_INDEX_ASTERISK = 4,
  DocumentPathItem_Type_DOUBLE_ASTERISK = 5
};
bool DocumentPathItem_Type_IsValid(int value);
constexpr DocumentPathItem_Type DocumentPathItem_Type_Type_MIN = DocumentPathItem_Type_MEMBER;
constexpr DocumentPathItem_Type DocumentPathItem_Type_Type_MAX = DocumentPathItem_Type_DOUBLE_ASTERISK;
constexpr int DocumentPathItem_Type_Type_ARRAYSIZE = DocumentPathItem_Type_Type_MAX + 1;

const std::string& DocumentPathItem_Type_Name(DocumentPathItem_Type value);
template<typename T>
inline const std::string& DocumentPathItem_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DocumentPathItem_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DocumentPathItem_Type_Name.");
  return DocumentPathItem_Type_Name(static_cast<DocumentPathItem_Type>(enum_t_value));
}
bool DocumentPathItem_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DocumentPathItem_Type* value);
// ===================================================================

class Expr final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.Expr) */ {
 public:
  inline Expr() : Expr(nullptr) {}
  ~Expr() override;
  explicit constexpr Expr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Expr(const Expr& from);
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr& operator=(Expr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Expr& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }
  inline void Swap(Expr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expr>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Expr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.Expr";
  }
  protected:
  explicit Expr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Expr_Type Type;
  static constexpr Type IDENT =
    Expr_Type_IDENT;
  static constexpr Type LITERAL =
    Expr_Type_LITERAL;
  static constexpr Type VARIABLE =
    Expr_Type_VARIABLE;
  static constexpr Type FUNC_CALL =
    Expr_Type_FUNC_CALL;
  static constexpr Type OPERATOR =
    Expr_Type_OPERATOR;
  static constexpr Type PLACEHOLDER =
    Expr_Type_PLACEHOLDER;
  static constexpr Type OBJECT =
    Expr_Type_OBJECT;
  static constexpr Type ARRAY =
    Expr_Type_ARRAY;
  static constexpr Type REF =
    Expr_Type_REF;
  static inline bool Type_IsValid(int value) {
    return Expr_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Expr_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Expr_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Expr_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Expr_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Expr_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVariableFieldNumber = 3,
    kIdentifierFieldNumber = 2,
    kLiteralFieldNumber = 4,
    kFunctionCallFieldNumber = 5,
    kOperatorFieldNumber = 6,
    kObjectFieldNumber = 8,
    kArrayFieldNumber = 9,
    kPositionFieldNumber = 7,
    kRefIdFieldNumber = 10,
    kTypeFieldNumber = 1,
  };
  // optional string variable = 3;
  bool has_variable() const;
  private:
  bool _internal_has_variable() const;
  public:
  void clear_variable();
  const std::string& variable() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variable(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variable();
  PROTOBUF_NODISCARD std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  private:
  const std::string& _internal_variable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // optional .PolarXRPC.Expr.ColumnIdentifier identifier = 2;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const ::PolarXRPC::Expr::ColumnIdentifier& identifier() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::ColumnIdentifier* release_identifier();
  ::PolarXRPC::Expr::ColumnIdentifier* mutable_identifier();
  void set_allocated_identifier(::PolarXRPC::Expr::ColumnIdentifier* identifier);
  private:
  const ::PolarXRPC::Expr::ColumnIdentifier& _internal_identifier() const;
  ::PolarXRPC::Expr::ColumnIdentifier* _internal_mutable_identifier();
  public:
  void unsafe_arena_set_allocated_identifier(
      ::PolarXRPC::Expr::ColumnIdentifier* identifier);
  ::PolarXRPC::Expr::ColumnIdentifier* unsafe_arena_release_identifier();

  // optional .PolarXRPC.Datatypes.Scalar literal = 4;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::PolarXRPC::Datatypes::Scalar& literal() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Datatypes::Scalar* release_literal();
  ::PolarXRPC::Datatypes::Scalar* mutable_literal();
  void set_allocated_literal(::PolarXRPC::Datatypes::Scalar* literal);
  private:
  const ::PolarXRPC::Datatypes::Scalar& _internal_literal() const;
  ::PolarXRPC::Datatypes::Scalar* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::PolarXRPC::Datatypes::Scalar* literal);
  ::PolarXRPC::Datatypes::Scalar* unsafe_arena_release_literal();

  // optional .PolarXRPC.Expr.FunctionCall function_call = 5;
  bool has_function_call() const;
  private:
  bool _internal_has_function_call() const;
  public:
  void clear_function_call();
  const ::PolarXRPC::Expr::FunctionCall& function_call() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::FunctionCall* release_function_call();
  ::PolarXRPC::Expr::FunctionCall* mutable_function_call();
  void set_allocated_function_call(::PolarXRPC::Expr::FunctionCall* function_call);
  private:
  const ::PolarXRPC::Expr::FunctionCall& _internal_function_call() const;
  ::PolarXRPC::Expr::FunctionCall* _internal_mutable_function_call();
  public:
  void unsafe_arena_set_allocated_function_call(
      ::PolarXRPC::Expr::FunctionCall* function_call);
  ::PolarXRPC::Expr::FunctionCall* unsafe_arena_release_function_call();

  // optional .PolarXRPC.Expr.Operator operator = 6;
  bool has_operator_() const;
  private:
  bool _internal_has_operator_() const;
  public:
  void clear_operator_();
  const ::PolarXRPC::Expr::Operator& operator_() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::Operator* release_operator_();
  ::PolarXRPC::Expr::Operator* mutable_operator_();
  void set_allocated_operator_(::PolarXRPC::Expr::Operator* operator_);
  private:
  const ::PolarXRPC::Expr::Operator& _internal_operator_() const;
  ::PolarXRPC::Expr::Operator* _internal_mutable_operator_();
  public:
  void unsafe_arena_set_allocated_operator_(
      ::PolarXRPC::Expr::Operator* operator_);
  ::PolarXRPC::Expr::Operator* unsafe_arena_release_operator_();

  // optional .PolarXRPC.Expr.Object object = 8;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::PolarXRPC::Expr::Object& object() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::Object* release_object();
  ::PolarXRPC::Expr::Object* mutable_object();
  void set_allocated_object(::PolarXRPC::Expr::Object* object);
  private:
  const ::PolarXRPC::Expr::Object& _internal_object() const;
  ::PolarXRPC::Expr::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::PolarXRPC::Expr::Object* object);
  ::PolarXRPC::Expr::Object* unsafe_arena_release_object();

  // optional .PolarXRPC.Expr.Array array = 9;
  bool has_array() const;
  private:
  bool _internal_has_array() const;
  public:
  void clear_array();
  const ::PolarXRPC::Expr::Array& array() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::Array* release_array();
  ::PolarXRPC::Expr::Array* mutable_array();
  void set_allocated_array(::PolarXRPC::Expr::Array* array);
  private:
  const ::PolarXRPC::Expr::Array& _internal_array() const;
  ::PolarXRPC::Expr::Array* _internal_mutable_array();
  public:
  void unsafe_arena_set_allocated_array(
      ::PolarXRPC::Expr::Array* array);
  ::PolarXRPC::Expr::Array* unsafe_arena_release_array();

  // optional uint32 position = 7;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  uint32_t position() const;
  void set_position(uint32_t value);
  private:
  uint32_t _internal_position() const;
  void _internal_set_position(uint32_t value);
  public:

  // optional uint32 ref_id = 10;
  bool has_ref_id() const;
  private:
  bool _internal_has_ref_id() const;
  public:
  void clear_ref_id();
  uint32_t ref_id() const;
  void set_ref_id(uint32_t value);
  private:
  uint32_t _internal_ref_id() const;
  void _internal_set_ref_id(uint32_t value);
  public:

  // required .PolarXRPC.Expr.Expr.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PolarXRPC::Expr::Expr_Type type() const;
  void set_type(::PolarXRPC::Expr::Expr_Type value);
  private:
  ::PolarXRPC::Expr::Expr_Type _internal_type() const;
  void _internal_set_type(::PolarXRPC::Expr::Expr_Type value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.Expr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::PolarXRPC::Expr::ColumnIdentifier* identifier_;
  ::PolarXRPC::Datatypes::Scalar* literal_;
  ::PolarXRPC::Expr::FunctionCall* function_call_;
  ::PolarXRPC::Expr::Operator* operator__;
  ::PolarXRPC::Expr::Object* object_;
  ::PolarXRPC::Expr::Array* array_;
  uint32_t position_;
  uint32_t ref_id_;
  int type_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Identifier final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.Identifier) */ {
 public:
  inline Identifier() : Identifier(nullptr) {}
  ~Identifier() override;
  explicit constexpr Identifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Identifier(const Identifier& from);
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identifier& operator=(Identifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Identifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }
  inline void Swap(Identifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Identifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Identifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.Identifier";
  }
  protected:
  explicit Identifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string schema_name = 2;
  bool has_schema_name() const;
  private:
  bool _internal_has_schema_name() const;
  public:
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.Identifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class DocumentPathItem final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.DocumentPathItem) */ {
 public:
  inline DocumentPathItem() : DocumentPathItem(nullptr) {}
  ~DocumentPathItem() override;
  explicit constexpr DocumentPathItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentPathItem(const DocumentPathItem& from);
  DocumentPathItem(DocumentPathItem&& from) noexcept
    : DocumentPathItem() {
    *this = ::std::move(from);
  }

  inline DocumentPathItem& operator=(const DocumentPathItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentPathItem& operator=(DocumentPathItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DocumentPathItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentPathItem* internal_default_instance() {
    return reinterpret_cast<const DocumentPathItem*>(
               &_DocumentPathItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DocumentPathItem& a, DocumentPathItem& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentPathItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentPathItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentPathItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentPathItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DocumentPathItem& from);
  void MergeFrom(const DocumentPathItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DocumentPathItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.DocumentPathItem";
  }
  protected:
  explicit DocumentPathItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DocumentPathItem_Type Type;
  static constexpr Type MEMBER =
    DocumentPathItem_Type_MEMBER;
  static constexpr Type MEMBER_ASTERISK =
    DocumentPathItem_Type_MEMBER_ASTERISK;
  static constexpr Type ARRAY_INDEX =
    DocumentPathItem_Type_ARRAY_INDEX;
  static constexpr Type ARRAY_INDEX_ASTERISK =
    DocumentPathItem_Type_ARRAY_INDEX_ASTERISK;
  static constexpr Type DOUBLE_ASTERISK =
    DocumentPathItem_Type_DOUBLE_ASTERISK;
  static inline bool Type_IsValid(int value) {
    return DocumentPathItem_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DocumentPathItem_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DocumentPathItem_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DocumentPathItem_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DocumentPathItem_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DocumentPathItem_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kIndexFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional uint32 index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // required .PolarXRPC.Expr.DocumentPathItem.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PolarXRPC::Expr::DocumentPathItem_Type type() const;
  void set_type(::PolarXRPC::Expr::DocumentPathItem_Type value);
  private:
  ::PolarXRPC::Expr::DocumentPathItem_Type _internal_type() const;
  void _internal_set_type(::PolarXRPC::Expr::DocumentPathItem_Type value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.DocumentPathItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  uint32_t index_;
  int type_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class ColumnIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.ColumnIdentifier) */ {
 public:
  inline ColumnIdentifier() : ColumnIdentifier(nullptr) {}
  ~ColumnIdentifier() override;
  explicit constexpr ColumnIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnIdentifier(const ColumnIdentifier& from);
  ColumnIdentifier(ColumnIdentifier&& from) noexcept
    : ColumnIdentifier() {
    *this = ::std::move(from);
  }

  inline ColumnIdentifier& operator=(const ColumnIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnIdentifier& operator=(ColumnIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ColumnIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnIdentifier* internal_default_instance() {
    return reinterpret_cast<const ColumnIdentifier*>(
               &_ColumnIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ColumnIdentifier& a, ColumnIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnIdentifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ColumnIdentifier& from);
  void MergeFrom(const ColumnIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ColumnIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.ColumnIdentifier";
  }
  protected:
  explicit ColumnIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentPathFieldNumber = 1,
    kNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kSchemaNameFieldNumber = 4,
  };
  // repeated .PolarXRPC.Expr.DocumentPathItem document_path = 1;
  int document_path_size() const;
  private:
  int _internal_document_path_size() const;
  public:
  void clear_document_path();
  ::PolarXRPC::Expr::DocumentPathItem* mutable_document_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::DocumentPathItem >*
      mutable_document_path();
  private:
  const ::PolarXRPC::Expr::DocumentPathItem& _internal_document_path(int index) const;
  ::PolarXRPC::Expr::DocumentPathItem* _internal_add_document_path();
  public:
  const ::PolarXRPC::Expr::DocumentPathItem& document_path(int index) const;
  ::PolarXRPC::Expr::DocumentPathItem* add_document_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::DocumentPathItem >&
      document_path() const;

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string table_name = 3;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string schema_name = 4;
  bool has_schema_name() const;
  private:
  bool _internal_has_schema_name() const;
  public:
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.ColumnIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::DocumentPathItem > document_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class FunctionCall final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.FunctionCall) */ {
 public:
  inline FunctionCall() : FunctionCall(nullptr) {}
  ~FunctionCall() override;
  explicit constexpr FunctionCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionCall(const FunctionCall& from);
  FunctionCall(FunctionCall&& from) noexcept
    : FunctionCall() {
    *this = ::std::move(from);
  }

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionCall& operator=(FunctionCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FunctionCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionCall* internal_default_instance() {
    return reinterpret_cast<const FunctionCall*>(
               &_FunctionCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FunctionCall& a, FunctionCall& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionCall>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FunctionCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.FunctionCall";
  }
  protected:
  explicit FunctionCall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .PolarXRPC.Expr.Expr param = 2;
  int param_size() const;
  private:
  int _internal_param_size() const;
  public:
  void clear_param();
  ::PolarXRPC::Expr::Expr* mutable_param(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
      mutable_param();
  private:
  const ::PolarXRPC::Expr::Expr& _internal_param(int index) const;
  ::PolarXRPC::Expr::Expr* _internal_add_param();
  public:
  const ::PolarXRPC::Expr::Expr& param(int index) const;
  ::PolarXRPC::Expr::Expr* add_param();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
      param() const;

  // required .PolarXRPC.Expr.Identifier name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::PolarXRPC::Expr::Identifier& name() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::Identifier* release_name();
  ::PolarXRPC::Expr::Identifier* mutable_name();
  void set_allocated_name(::PolarXRPC::Expr::Identifier* name);
  private:
  const ::PolarXRPC::Expr::Identifier& _internal_name() const;
  ::PolarXRPC::Expr::Identifier* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::PolarXRPC::Expr::Identifier* name);
  ::PolarXRPC::Expr::Identifier* unsafe_arena_release_name();

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.FunctionCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr > param_;
  ::PolarXRPC::Expr::Identifier* name_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Operator final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.Operator) */ {
 public:
  inline Operator() : Operator(nullptr) {}
  ~Operator() override;
  explicit constexpr Operator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operator(const Operator& from);
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operator& operator=(Operator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Operator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }
  inline void Swap(Operator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.Operator";
  }
  protected:
  explicit Operator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .PolarXRPC.Expr.Expr param = 2;
  int param_size() const;
  private:
  int _internal_param_size() const;
  public:
  void clear_param();
  ::PolarXRPC::Expr::Expr* mutable_param(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
      mutable_param();
  private:
  const ::PolarXRPC::Expr::Expr& _internal_param(int index) const;
  ::PolarXRPC::Expr::Expr* _internal_add_param();
  public:
  const ::PolarXRPC::Expr::Expr& param(int index) const;
  ::PolarXRPC::Expr::Expr* add_param();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
      param() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.Operator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr > param_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Object_ObjectField final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.Object.ObjectField) */ {
 public:
  inline Object_ObjectField() : Object_ObjectField(nullptr) {}
  ~Object_ObjectField() override;
  explicit constexpr Object_ObjectField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object_ObjectField(const Object_ObjectField& from);
  Object_ObjectField(Object_ObjectField&& from) noexcept
    : Object_ObjectField() {
    *this = ::std::move(from);
  }

  inline Object_ObjectField& operator=(const Object_ObjectField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object_ObjectField& operator=(Object_ObjectField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Object_ObjectField& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object_ObjectField* internal_default_instance() {
    return reinterpret_cast<const Object_ObjectField*>(
               &_Object_ObjectField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Object_ObjectField& a, Object_ObjectField& b) {
    a.Swap(&b);
  }
  inline void Swap(Object_ObjectField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object_ObjectField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object_ObjectField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object_ObjectField>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Object_ObjectField& from);
  void MergeFrom(const Object_ObjectField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object_ObjectField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.Object.ObjectField";
  }
  protected:
  explicit Object_ObjectField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required .PolarXRPC.Expr.Expr value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PolarXRPC::Expr::Expr& value() const;
  PROTOBUF_NODISCARD ::PolarXRPC::Expr::Expr* release_value();
  ::PolarXRPC::Expr::Expr* mutable_value();
  void set_allocated_value(::PolarXRPC::Expr::Expr* value);
  private:
  const ::PolarXRPC::Expr::Expr& _internal_value() const;
  ::PolarXRPC::Expr::Expr* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PolarXRPC::Expr::Expr* value);
  ::PolarXRPC::Expr::Expr* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.Object.ObjectField)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PolarXRPC::Expr::Expr* value_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  explicit constexpr Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Object_ObjectField ObjectField;

  // accessors -------------------------------------------------------

  enum : int {
    kFldFieldNumber = 1,
  };
  // repeated .PolarXRPC.Expr.Object.ObjectField fld = 1;
  int fld_size() const;
  private:
  int _internal_fld_size() const;
  public:
  void clear_fld();
  ::PolarXRPC::Expr::Object_ObjectField* mutable_fld(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Object_ObjectField >*
      mutable_fld();
  private:
  const ::PolarXRPC::Expr::Object_ObjectField& _internal_fld(int index) const;
  ::PolarXRPC::Expr::Object_ObjectField* _internal_add_fld();
  public:
  const ::PolarXRPC::Expr::Object_ObjectField& fld(int index) const;
  ::PolarXRPC::Expr::Object_ObjectField* add_fld();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Object_ObjectField >&
      fld() const;

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Object_ObjectField > fld_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Array final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Expr.Array) */ {
 public:
  inline Array() : Array(nullptr) {}
  ~Array() override;
  explicit constexpr Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Array(const Array& from);
  Array(Array&& from) noexcept
    : Array() {
    *this = ::std::move(from);
  }

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array& operator=(Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
               &_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Array& a, Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Array>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Array& from);
  void MergeFrom(const Array& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Expr.Array";
  }
  protected:
  explicit Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .PolarXRPC.Expr.Expr value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::PolarXRPC::Expr::Expr* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
      mutable_value();
  private:
  const ::PolarXRPC::Expr::Expr& _internal_value(int index) const;
  ::PolarXRPC::Expr::Expr* _internal_add_value();
  public:
  const ::PolarXRPC::Expr::Expr& value(int index) const;
  ::PolarXRPC::Expr::Expr* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
      value() const;

  // @@protoc_insertion_point(class_scope:PolarXRPC.Expr.Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fexpr_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Expr

// required .PolarXRPC.Expr.Expr.Type type = 1;
inline bool Expr::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Expr::has_type() const {
  return _internal_has_type();
}
inline void Expr::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PolarXRPC::Expr::Expr_Type Expr::_internal_type() const {
  return static_cast< ::PolarXRPC::Expr::Expr_Type >(type_);
}
inline ::PolarXRPC::Expr::Expr_Type Expr::type() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.type)
  return _internal_type();
}
inline void Expr::_internal_set_type(::PolarXRPC::Expr::Expr_Type value) {
  assert(::PolarXRPC::Expr::Expr_Type_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  type_ = value;
}
inline void Expr::set_type(::PolarXRPC::Expr::Expr_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Expr.type)
}

// optional .PolarXRPC.Expr.ColumnIdentifier identifier = 2;
inline bool Expr::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || identifier_ != nullptr);
  return value;
}
inline bool Expr::has_identifier() const {
  return _internal_has_identifier();
}
inline void Expr::clear_identifier() {
  if (identifier_ != nullptr) identifier_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::Expr::ColumnIdentifier& Expr::_internal_identifier() const {
  const ::PolarXRPC::Expr::ColumnIdentifier* p = identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::ColumnIdentifier&>(
      ::PolarXRPC::Expr::_ColumnIdentifier_default_instance_);
}
inline const ::PolarXRPC::Expr::ColumnIdentifier& Expr::identifier() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.identifier)
  return _internal_identifier();
}
inline void Expr::unsafe_arena_set_allocated_identifier(
    ::PolarXRPC::Expr::ColumnIdentifier* identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifier_);
  }
  identifier_ = identifier;
  if (identifier) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.Expr.identifier)
}
inline ::PolarXRPC::Expr::ColumnIdentifier* Expr::release_identifier() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Expr::ColumnIdentifier* temp = identifier_;
  identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::ColumnIdentifier* Expr::unsafe_arena_release_identifier() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Expr.identifier)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Expr::ColumnIdentifier* temp = identifier_;
  identifier_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::ColumnIdentifier* Expr::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000002u;
  if (identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::ColumnIdentifier>(GetArenaForAllocation());
    identifier_ = p;
  }
  return identifier_;
}
inline ::PolarXRPC::Expr::ColumnIdentifier* Expr::mutable_identifier() {
  ::PolarXRPC::Expr::ColumnIdentifier* _msg = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Expr.identifier)
  return _msg;
}
inline void Expr::set_allocated_identifier(::PolarXRPC::Expr::ColumnIdentifier* identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete identifier_;
  }
  if (identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::Expr::ColumnIdentifier>::GetOwningArena(identifier);
    if (message_arena != submessage_arena) {
      identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Expr.identifier)
}

// optional string variable = 3;
inline bool Expr::_internal_has_variable() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Expr::has_variable() const {
  return _internal_has_variable();
}
inline void Expr::clear_variable() {
  variable_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expr::variable() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.variable)
  return _internal_variable();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Expr::set_variable(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Expr.variable)
}
inline std::string* Expr::mutable_variable() {
  std::string* _s = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Expr.variable)
  return _s;
}
inline const std::string& Expr::_internal_variable() const {
  return variable_.Get();
}
inline void Expr::_internal_set_variable(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  variable_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Expr::_internal_mutable_variable() {
  _has_bits_[0] |= 0x00000001u;
  return variable_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Expr::release_variable() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Expr.variable)
  if (!_internal_has_variable()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = variable_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (variable_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Expr::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  variable_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (variable_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    variable_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Expr.variable)
}

// optional .PolarXRPC.Datatypes.Scalar literal = 4;
inline bool Expr::_internal_has_literal() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || literal_ != nullptr);
  return value;
}
inline bool Expr::has_literal() const {
  return _internal_has_literal();
}
inline const ::PolarXRPC::Datatypes::Scalar& Expr::_internal_literal() const {
  const ::PolarXRPC::Datatypes::Scalar* p = literal_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Datatypes::Scalar&>(
      ::PolarXRPC::Datatypes::_Scalar_default_instance_);
}
inline const ::PolarXRPC::Datatypes::Scalar& Expr::literal() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.literal)
  return _internal_literal();
}
inline void Expr::unsafe_arena_set_allocated_literal(
    ::PolarXRPC::Datatypes::Scalar* literal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(literal_);
  }
  literal_ = literal;
  if (literal) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.Expr.literal)
}
inline ::PolarXRPC::Datatypes::Scalar* Expr::release_literal() {
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::Datatypes::Scalar* temp = literal_;
  literal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* Expr::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Expr.literal)
  _has_bits_[0] &= ~0x00000004u;
  ::PolarXRPC::Datatypes::Scalar* temp = literal_;
  literal_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Datatypes::Scalar* Expr::_internal_mutable_literal() {
  _has_bits_[0] |= 0x00000004u;
  if (literal_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Datatypes::Scalar>(GetArenaForAllocation());
    literal_ = p;
  }
  return literal_;
}
inline ::PolarXRPC::Datatypes::Scalar* Expr::mutable_literal() {
  ::PolarXRPC::Datatypes::Scalar* _msg = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Expr.literal)
  return _msg;
}
inline void Expr::set_allocated_literal(::PolarXRPC::Datatypes::Scalar* literal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(literal_);
  }
  if (literal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(literal));
    if (message_arena != submessage_arena) {
      literal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, literal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  literal_ = literal;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Expr.literal)
}

// optional .PolarXRPC.Expr.FunctionCall function_call = 5;
inline bool Expr::_internal_has_function_call() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || function_call_ != nullptr);
  return value;
}
inline bool Expr::has_function_call() const {
  return _internal_has_function_call();
}
inline void Expr::clear_function_call() {
  if (function_call_ != nullptr) function_call_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::PolarXRPC::Expr::FunctionCall& Expr::_internal_function_call() const {
  const ::PolarXRPC::Expr::FunctionCall* p = function_call_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::FunctionCall&>(
      ::PolarXRPC::Expr::_FunctionCall_default_instance_);
}
inline const ::PolarXRPC::Expr::FunctionCall& Expr::function_call() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.function_call)
  return _internal_function_call();
}
inline void Expr::unsafe_arena_set_allocated_function_call(
    ::PolarXRPC::Expr::FunctionCall* function_call) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_call_);
  }
  function_call_ = function_call;
  if (function_call) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.Expr.function_call)
}
inline ::PolarXRPC::Expr::FunctionCall* Expr::release_function_call() {
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::Expr::FunctionCall* temp = function_call_;
  function_call_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::FunctionCall* Expr::unsafe_arena_release_function_call() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Expr.function_call)
  _has_bits_[0] &= ~0x00000008u;
  ::PolarXRPC::Expr::FunctionCall* temp = function_call_;
  function_call_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::FunctionCall* Expr::_internal_mutable_function_call() {
  _has_bits_[0] |= 0x00000008u;
  if (function_call_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::FunctionCall>(GetArenaForAllocation());
    function_call_ = p;
  }
  return function_call_;
}
inline ::PolarXRPC::Expr::FunctionCall* Expr::mutable_function_call() {
  ::PolarXRPC::Expr::FunctionCall* _msg = _internal_mutable_function_call();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Expr.function_call)
  return _msg;
}
inline void Expr::set_allocated_function_call(::PolarXRPC::Expr::FunctionCall* function_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete function_call_;
  }
  if (function_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::Expr::FunctionCall>::GetOwningArena(function_call);
    if (message_arena != submessage_arena) {
      function_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function_call, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  function_call_ = function_call;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Expr.function_call)
}

// optional .PolarXRPC.Expr.Operator operator = 6;
inline bool Expr::_internal_has_operator_() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || operator__ != nullptr);
  return value;
}
inline bool Expr::has_operator_() const {
  return _internal_has_operator_();
}
inline void Expr::clear_operator_() {
  if (operator__ != nullptr) operator__->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::PolarXRPC::Expr::Operator& Expr::_internal_operator_() const {
  const ::PolarXRPC::Expr::Operator* p = operator__;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::Operator&>(
      ::PolarXRPC::Expr::_Operator_default_instance_);
}
inline const ::PolarXRPC::Expr::Operator& Expr::operator_() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.operator)
  return _internal_operator_();
}
inline void Expr::unsafe_arena_set_allocated_operator_(
    ::PolarXRPC::Expr::Operator* operator_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(operator__);
  }
  operator__ = operator_;
  if (operator_) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.Expr.operator)
}
inline ::PolarXRPC::Expr::Operator* Expr::release_operator_() {
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::Expr::Operator* temp = operator__;
  operator__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::Operator* Expr::unsafe_arena_release_operator_() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Expr.operator)
  _has_bits_[0] &= ~0x00000010u;
  ::PolarXRPC::Expr::Operator* temp = operator__;
  operator__ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::Operator* Expr::_internal_mutable_operator_() {
  _has_bits_[0] |= 0x00000010u;
  if (operator__ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::Operator>(GetArenaForAllocation());
    operator__ = p;
  }
  return operator__;
}
inline ::PolarXRPC::Expr::Operator* Expr::mutable_operator_() {
  ::PolarXRPC::Expr::Operator* _msg = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Expr.operator)
  return _msg;
}
inline void Expr::set_allocated_operator_(::PolarXRPC::Expr::Operator* operator_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete operator__;
  }
  if (operator_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::Expr::Operator>::GetOwningArena(operator_);
    if (message_arena != submessage_arena) {
      operator_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operator_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  operator__ = operator_;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Expr.operator)
}

// optional uint32 position = 7;
inline bool Expr::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Expr::has_position() const {
  return _internal_has_position();
}
inline void Expr::clear_position() {
  position_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t Expr::_internal_position() const {
  return position_;
}
inline uint32_t Expr::position() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.position)
  return _internal_position();
}
inline void Expr::_internal_set_position(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  position_ = value;
}
inline void Expr::set_position(uint32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Expr.position)
}

// optional .PolarXRPC.Expr.Object object = 8;
inline bool Expr::_internal_has_object() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || object_ != nullptr);
  return value;
}
inline bool Expr::has_object() const {
  return _internal_has_object();
}
inline void Expr::clear_object() {
  if (object_ != nullptr) object_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::PolarXRPC::Expr::Object& Expr::_internal_object() const {
  const ::PolarXRPC::Expr::Object* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::Object&>(
      ::PolarXRPC::Expr::_Object_default_instance_);
}
inline const ::PolarXRPC::Expr::Object& Expr::object() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.object)
  return _internal_object();
}
inline void Expr::unsafe_arena_set_allocated_object(
    ::PolarXRPC::Expr::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.Expr.object)
}
inline ::PolarXRPC::Expr::Object* Expr::release_object() {
  _has_bits_[0] &= ~0x00000020u;
  ::PolarXRPC::Expr::Object* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::Object* Expr::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Expr.object)
  _has_bits_[0] &= ~0x00000020u;
  ::PolarXRPC::Expr::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::Object* Expr::_internal_mutable_object() {
  _has_bits_[0] |= 0x00000020u;
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::Object>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::PolarXRPC::Expr::Object* Expr::mutable_object() {
  ::PolarXRPC::Expr::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Expr.object)
  return _msg;
}
inline void Expr::set_allocated_object(::PolarXRPC::Expr::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::Expr::Object>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Expr.object)
}

// optional .PolarXRPC.Expr.Array array = 9;
inline bool Expr::_internal_has_array() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || array_ != nullptr);
  return value;
}
inline bool Expr::has_array() const {
  return _internal_has_array();
}
inline void Expr::clear_array() {
  if (array_ != nullptr) array_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::PolarXRPC::Expr::Array& Expr::_internal_array() const {
  const ::PolarXRPC::Expr::Array* p = array_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::Array&>(
      ::PolarXRPC::Expr::_Array_default_instance_);
}
inline const ::PolarXRPC::Expr::Array& Expr::array() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.array)
  return _internal_array();
}
inline void Expr::unsafe_arena_set_allocated_array(
    ::PolarXRPC::Expr::Array* array) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(array_);
  }
  array_ = array;
  if (array) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.Expr.array)
}
inline ::PolarXRPC::Expr::Array* Expr::release_array() {
  _has_bits_[0] &= ~0x00000040u;
  ::PolarXRPC::Expr::Array* temp = array_;
  array_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::Array* Expr::unsafe_arena_release_array() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Expr.array)
  _has_bits_[0] &= ~0x00000040u;
  ::PolarXRPC::Expr::Array* temp = array_;
  array_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::Array* Expr::_internal_mutable_array() {
  _has_bits_[0] |= 0x00000040u;
  if (array_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::Array>(GetArenaForAllocation());
    array_ = p;
  }
  return array_;
}
inline ::PolarXRPC::Expr::Array* Expr::mutable_array() {
  ::PolarXRPC::Expr::Array* _msg = _internal_mutable_array();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Expr.array)
  return _msg;
}
inline void Expr::set_allocated_array(::PolarXRPC::Expr::Array* array) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete array_;
  }
  if (array) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::Expr::Array>::GetOwningArena(array);
    if (message_arena != submessage_arena) {
      array = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, array, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  array_ = array;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Expr.array)
}

// optional uint32 ref_id = 10;
inline bool Expr::_internal_has_ref_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Expr::has_ref_id() const {
  return _internal_has_ref_id();
}
inline void Expr::clear_ref_id() {
  ref_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t Expr::_internal_ref_id() const {
  return ref_id_;
}
inline uint32_t Expr::ref_id() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Expr.ref_id)
  return _internal_ref_id();
}
inline void Expr::_internal_set_ref_id(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  ref_id_ = value;
}
inline void Expr::set_ref_id(uint32_t value) {
  _internal_set_ref_id(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Expr.ref_id)
}

// -------------------------------------------------------------------

// Identifier

// required string name = 1;
inline bool Identifier::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Identifier::has_name() const {
  return _internal_has_name();
}
inline void Identifier::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Identifier.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Identifier::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Identifier.name)
}
inline std::string* Identifier::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Identifier.name)
  return _s;
}
inline const std::string& Identifier::_internal_name() const {
  return name_.Get();
}
inline void Identifier::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Identifier::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Identifier.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Identifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Identifier.name)
}

// optional string schema_name = 2;
inline bool Identifier::_internal_has_schema_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Identifier::has_schema_name() const {
  return _internal_has_schema_name();
}
inline void Identifier::clear_schema_name() {
  schema_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Identifier::schema_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Identifier.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Identifier::set_schema_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 schema_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Identifier.schema_name)
}
inline std::string* Identifier::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Identifier.schema_name)
  return _s;
}
inline const std::string& Identifier::_internal_schema_name() const {
  return schema_name_.Get();
}
inline void Identifier::_internal_set_schema_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Identifier::_internal_mutable_schema_name() {
  _has_bits_[0] |= 0x00000002u;
  return schema_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Identifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Identifier.schema_name)
  if (!_internal_has_schema_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = schema_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Identifier::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Identifier.schema_name)
}

// -------------------------------------------------------------------

// DocumentPathItem

// required .PolarXRPC.Expr.DocumentPathItem.Type type = 1;
inline bool DocumentPathItem::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DocumentPathItem::has_type() const {
  return _internal_has_type();
}
inline void DocumentPathItem::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PolarXRPC::Expr::DocumentPathItem_Type DocumentPathItem::_internal_type() const {
  return static_cast< ::PolarXRPC::Expr::DocumentPathItem_Type >(type_);
}
inline ::PolarXRPC::Expr::DocumentPathItem_Type DocumentPathItem::type() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.DocumentPathItem.type)
  return _internal_type();
}
inline void DocumentPathItem::_internal_set_type(::PolarXRPC::Expr::DocumentPathItem_Type value) {
  assert(::PolarXRPC::Expr::DocumentPathItem_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void DocumentPathItem::set_type(::PolarXRPC::Expr::DocumentPathItem_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.DocumentPathItem.type)
}

// optional string value = 2;
inline bool DocumentPathItem::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentPathItem::has_value() const {
  return _internal_has_value();
}
inline void DocumentPathItem::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentPathItem::value() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.DocumentPathItem.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentPathItem::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.DocumentPathItem.value)
}
inline std::string* DocumentPathItem::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.DocumentPathItem.value)
  return _s;
}
inline const std::string& DocumentPathItem::_internal_value() const {
  return value_.Get();
}
inline void DocumentPathItem::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DocumentPathItem::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DocumentPathItem::release_value() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.DocumentPathItem.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentPathItem::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.DocumentPathItem.value)
}

// optional uint32 index = 3;
inline bool DocumentPathItem::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentPathItem::has_index() const {
  return _internal_has_index();
}
inline void DocumentPathItem::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DocumentPathItem::_internal_index() const {
  return index_;
}
inline uint32_t DocumentPathItem::index() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.DocumentPathItem.index)
  return _internal_index();
}
inline void DocumentPathItem::_internal_set_index(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  index_ = value;
}
inline void DocumentPathItem::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.DocumentPathItem.index)
}

// -------------------------------------------------------------------

// ColumnIdentifier

// repeated .PolarXRPC.Expr.DocumentPathItem document_path = 1;
inline int ColumnIdentifier::_internal_document_path_size() const {
  return document_path_.size();
}
inline int ColumnIdentifier::document_path_size() const {
  return _internal_document_path_size();
}
inline void ColumnIdentifier::clear_document_path() {
  document_path_.Clear();
}
inline ::PolarXRPC::Expr::DocumentPathItem* ColumnIdentifier::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.ColumnIdentifier.document_path)
  return document_path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::DocumentPathItem >*
ColumnIdentifier::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.Expr.ColumnIdentifier.document_path)
  return &document_path_;
}
inline const ::PolarXRPC::Expr::DocumentPathItem& ColumnIdentifier::_internal_document_path(int index) const {
  return document_path_.Get(index);
}
inline const ::PolarXRPC::Expr::DocumentPathItem& ColumnIdentifier::document_path(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.ColumnIdentifier.document_path)
  return _internal_document_path(index);
}
inline ::PolarXRPC::Expr::DocumentPathItem* ColumnIdentifier::_internal_add_document_path() {
  return document_path_.Add();
}
inline ::PolarXRPC::Expr::DocumentPathItem* ColumnIdentifier::add_document_path() {
  ::PolarXRPC::Expr::DocumentPathItem* _add = _internal_add_document_path();
  // @@protoc_insertion_point(field_add:PolarXRPC.Expr.ColumnIdentifier.document_path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::DocumentPathItem >&
ColumnIdentifier::document_path() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.Expr.ColumnIdentifier.document_path)
  return document_path_;
}

// optional string name = 2;
inline bool ColumnIdentifier::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ColumnIdentifier::has_name() const {
  return _internal_has_name();
}
inline void ColumnIdentifier::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnIdentifier::name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.ColumnIdentifier.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnIdentifier::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.ColumnIdentifier.name)
}
inline std::string* ColumnIdentifier::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.ColumnIdentifier.name)
  return _s;
}
inline const std::string& ColumnIdentifier::_internal_name() const {
  return name_.Get();
}
inline void ColumnIdentifier::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnIdentifier::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.ColumnIdentifier.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ColumnIdentifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.ColumnIdentifier.name)
}

// optional string table_name = 3;
inline bool ColumnIdentifier::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ColumnIdentifier::has_table_name() const {
  return _internal_has_table_name();
}
inline void ColumnIdentifier::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ColumnIdentifier::table_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.ColumnIdentifier.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnIdentifier::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.ColumnIdentifier.table_name)
}
inline std::string* ColumnIdentifier::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.ColumnIdentifier.table_name)
  return _s;
}
inline const std::string& ColumnIdentifier::_internal_table_name() const {
  return table_name_.Get();
}
inline void ColumnIdentifier::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnIdentifier::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnIdentifier::release_table_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.ColumnIdentifier.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ColumnIdentifier::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (table_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    table_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.ColumnIdentifier.table_name)
}

// optional string schema_name = 4;
inline bool ColumnIdentifier::_internal_has_schema_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ColumnIdentifier::has_schema_name() const {
  return _internal_has_schema_name();
}
inline void ColumnIdentifier::clear_schema_name() {
  schema_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ColumnIdentifier::schema_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.ColumnIdentifier.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnIdentifier::set_schema_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 schema_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.ColumnIdentifier.schema_name)
}
inline std::string* ColumnIdentifier::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.ColumnIdentifier.schema_name)
  return _s;
}
inline const std::string& ColumnIdentifier::_internal_schema_name() const {
  return schema_name_.Get();
}
inline void ColumnIdentifier::_internal_set_schema_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  schema_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnIdentifier::_internal_mutable_schema_name() {
  _has_bits_[0] |= 0x00000004u;
  return schema_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnIdentifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.ColumnIdentifier.schema_name)
  if (!_internal_has_schema_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = schema_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ColumnIdentifier::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  schema_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.ColumnIdentifier.schema_name)
}

// -------------------------------------------------------------------

// FunctionCall

// required .PolarXRPC.Expr.Identifier name = 1;
inline bool FunctionCall::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || name_ != nullptr);
  return value;
}
inline bool FunctionCall::has_name() const {
  return _internal_has_name();
}
inline void FunctionCall::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PolarXRPC::Expr::Identifier& FunctionCall::_internal_name() const {
  const ::PolarXRPC::Expr::Identifier* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::Identifier&>(
      ::PolarXRPC::Expr::_Identifier_default_instance_);
}
inline const ::PolarXRPC::Expr::Identifier& FunctionCall::name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.FunctionCall.name)
  return _internal_name();
}
inline void FunctionCall::unsafe_arena_set_allocated_name(
    ::PolarXRPC::Expr::Identifier* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.FunctionCall.name)
}
inline ::PolarXRPC::Expr::Identifier* FunctionCall::release_name() {
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Expr::Identifier* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::Identifier* FunctionCall::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.FunctionCall.name)
  _has_bits_[0] &= ~0x00000001u;
  ::PolarXRPC::Expr::Identifier* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::Identifier* FunctionCall::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::Identifier>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::PolarXRPC::Expr::Identifier* FunctionCall::mutable_name() {
  ::PolarXRPC::Expr::Identifier* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.FunctionCall.name)
  return _msg;
}
inline void FunctionCall::set_allocated_name(::PolarXRPC::Expr::Identifier* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::Expr::Identifier>::GetOwningArena(name);
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.FunctionCall.name)
}

// repeated .PolarXRPC.Expr.Expr param = 2;
inline int FunctionCall::_internal_param_size() const {
  return param_.size();
}
inline int FunctionCall::param_size() const {
  return _internal_param_size();
}
inline void FunctionCall::clear_param() {
  param_.Clear();
}
inline ::PolarXRPC::Expr::Expr* FunctionCall::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.FunctionCall.param)
  return param_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
FunctionCall::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.Expr.FunctionCall.param)
  return &param_;
}
inline const ::PolarXRPC::Expr::Expr& FunctionCall::_internal_param(int index) const {
  return param_.Get(index);
}
inline const ::PolarXRPC::Expr::Expr& FunctionCall::param(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.FunctionCall.param)
  return _internal_param(index);
}
inline ::PolarXRPC::Expr::Expr* FunctionCall::_internal_add_param() {
  return param_.Add();
}
inline ::PolarXRPC::Expr::Expr* FunctionCall::add_param() {
  ::PolarXRPC::Expr::Expr* _add = _internal_add_param();
  // @@protoc_insertion_point(field_add:PolarXRPC.Expr.FunctionCall.param)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
FunctionCall::param() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.Expr.FunctionCall.param)
  return param_;
}

// -------------------------------------------------------------------

// Operator

// required string name = 1;
inline bool Operator::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Operator::has_name() const {
  return _internal_has_name();
}
inline void Operator::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Operator::name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Operator.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operator::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Operator.name)
}
inline std::string* Operator::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Operator.name)
  return _s;
}
inline const std::string& Operator::_internal_name() const {
  return name_.Get();
}
inline void Operator::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Operator::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Operator::release_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Operator.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Operator::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Operator.name)
}

// repeated .PolarXRPC.Expr.Expr param = 2;
inline int Operator::_internal_param_size() const {
  return param_.size();
}
inline int Operator::param_size() const {
  return _internal_param_size();
}
inline void Operator::clear_param() {
  param_.Clear();
}
inline ::PolarXRPC::Expr::Expr* Operator::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Operator.param)
  return param_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
Operator::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.Expr.Operator.param)
  return &param_;
}
inline const ::PolarXRPC::Expr::Expr& Operator::_internal_param(int index) const {
  return param_.Get(index);
}
inline const ::PolarXRPC::Expr::Expr& Operator::param(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Operator.param)
  return _internal_param(index);
}
inline ::PolarXRPC::Expr::Expr* Operator::_internal_add_param() {
  return param_.Add();
}
inline ::PolarXRPC::Expr::Expr* Operator::add_param() {
  ::PolarXRPC::Expr::Expr* _add = _internal_add_param();
  // @@protoc_insertion_point(field_add:PolarXRPC.Expr.Operator.param)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
Operator::param() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.Expr.Operator.param)
  return param_;
}

// -------------------------------------------------------------------

// Object_ObjectField

// required string key = 1;
inline bool Object_ObjectField::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Object_ObjectField::has_key() const {
  return _internal_has_key();
}
inline void Object_ObjectField::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Object_ObjectField::key() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Object.ObjectField.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object_ObjectField::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Expr.Object.ObjectField.key)
}
inline std::string* Object_ObjectField::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Object.ObjectField.key)
  return _s;
}
inline const std::string& Object_ObjectField::_internal_key() const {
  return key_.Get();
}
inline void Object_ObjectField::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Object_ObjectField::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Object_ObjectField::release_key() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Object.ObjectField.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Object_ObjectField::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Object.ObjectField.key)
}

// required .PolarXRPC.Expr.Expr value = 2;
inline bool Object_ObjectField::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool Object_ObjectField::has_value() const {
  return _internal_has_value();
}
inline void Object_ObjectField::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::PolarXRPC::Expr::Expr& Object_ObjectField::_internal_value() const {
  const ::PolarXRPC::Expr::Expr* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PolarXRPC::Expr::Expr&>(
      ::PolarXRPC::Expr::_Expr_default_instance_);
}
inline const ::PolarXRPC::Expr::Expr& Object_ObjectField::value() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Object.ObjectField.value)
  return _internal_value();
}
inline void Object_ObjectField::unsafe_arena_set_allocated_value(
    ::PolarXRPC::Expr::Expr* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PolarXRPC.Expr.Object.ObjectField.value)
}
inline ::PolarXRPC::Expr::Expr* Object_ObjectField::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Expr::Expr* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PolarXRPC::Expr::Expr* Object_ObjectField::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Expr.Object.ObjectField.value)
  _has_bits_[0] &= ~0x00000002u;
  ::PolarXRPC::Expr::Expr* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::PolarXRPC::Expr::Expr* Object_ObjectField::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PolarXRPC::Expr::Expr>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::PolarXRPC::Expr::Expr* Object_ObjectField::mutable_value() {
  ::PolarXRPC::Expr::Expr* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Object.ObjectField.value)
  return _msg;
}
inline void Object_ObjectField::set_allocated_value(::PolarXRPC::Expr::Expr* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PolarXRPC::Expr::Expr>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Expr.Object.ObjectField.value)
}

// -------------------------------------------------------------------

// Object

// repeated .PolarXRPC.Expr.Object.ObjectField fld = 1;
inline int Object::_internal_fld_size() const {
  return fld_.size();
}
inline int Object::fld_size() const {
  return _internal_fld_size();
}
inline void Object::clear_fld() {
  fld_.Clear();
}
inline ::PolarXRPC::Expr::Object_ObjectField* Object::mutable_fld(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Object.fld)
  return fld_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Object_ObjectField >*
Object::mutable_fld() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.Expr.Object.fld)
  return &fld_;
}
inline const ::PolarXRPC::Expr::Object_ObjectField& Object::_internal_fld(int index) const {
  return fld_.Get(index);
}
inline const ::PolarXRPC::Expr::Object_ObjectField& Object::fld(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Object.fld)
  return _internal_fld(index);
}
inline ::PolarXRPC::Expr::Object_ObjectField* Object::_internal_add_fld() {
  return fld_.Add();
}
inline ::PolarXRPC::Expr::Object_ObjectField* Object::add_fld() {
  ::PolarXRPC::Expr::Object_ObjectField* _add = _internal_add_fld();
  // @@protoc_insertion_point(field_add:PolarXRPC.Expr.Object.fld)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Object_ObjectField >&
Object::fld() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.Expr.Object.fld)
  return fld_;
}

// -------------------------------------------------------------------

// Array

// repeated .PolarXRPC.Expr.Expr value = 1;
inline int Array::_internal_value_size() const {
  return value_.size();
}
inline int Array::value_size() const {
  return _internal_value_size();
}
inline void Array::clear_value() {
  value_.Clear();
}
inline ::PolarXRPC::Expr::Expr* Array::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Expr.Array.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >*
Array::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.Expr.Array.value)
  return &value_;
}
inline const ::PolarXRPC::Expr::Expr& Array::_internal_value(int index) const {
  return value_.Get(index);
}
inline const ::PolarXRPC::Expr::Expr& Array::value(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Expr.Array.value)
  return _internal_value(index);
}
inline ::PolarXRPC::Expr::Expr* Array::_internal_add_value() {
  return value_.Add();
}
inline ::PolarXRPC::Expr::Expr* Array::add_value() {
  ::PolarXRPC::Expr::Expr* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:PolarXRPC.Expr.Array.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Expr::Expr >&
Array::value() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.Expr.Array.value)
  return value_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Expr
}  // namespace PolarXRPC

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PolarXRPC::Expr::Expr_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::PolarXRPC::Expr::DocumentPathItem_Type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_polarx_5fexpr_2eproto
