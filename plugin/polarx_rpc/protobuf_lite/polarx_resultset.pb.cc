// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polarx_resultset.proto

#include "polarx_resultset.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace PolarXRPC {
namespace Resultset {
constexpr FetchDoneMoreOutParams::FetchDoneMoreOutParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct FetchDoneMoreOutParamsDefaultTypeInternal {
  constexpr FetchDoneMoreOutParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FetchDoneMoreOutParamsDefaultTypeInternal() {}
  union {
    FetchDoneMoreOutParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FetchDoneMoreOutParamsDefaultTypeInternal _FetchDoneMoreOutParams_default_instance_;
constexpr FetchDoneMoreResultsets::FetchDoneMoreResultsets(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct FetchDoneMoreResultsetsDefaultTypeInternal {
  constexpr FetchDoneMoreResultsetsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FetchDoneMoreResultsetsDefaultTypeInternal() {}
  union {
    FetchDoneMoreResultsets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FetchDoneMoreResultsetsDefaultTypeInternal _FetchDoneMoreResultsets_default_instance_;
constexpr FetchDone::FetchDone(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : chosen_index_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , examined_row_count_(uint64_t{0u}){}
struct FetchDoneDefaultTypeInternal {
  constexpr FetchDoneDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FetchDoneDefaultTypeInternal() {}
  union {
    FetchDone _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FetchDoneDefaultTypeInternal _FetchDone_default_instance_;
constexpr ColumnMetaData::ColumnMetaData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , table_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_table_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , catalog_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_type_(0)

  , fractional_digits_(0u)
  , collation_(uint64_t{0u})
  , length_(0u)
  , flags_(0u)
  , content_type_(0u)
  , original_flags_(0u)
  , type_(1)
{}
struct ColumnMetaDataDefaultTypeInternal {
  constexpr ColumnMetaDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ColumnMetaDataDefaultTypeInternal() {}
  union {
    ColumnMetaData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ColumnMetaDataDefaultTypeInternal _ColumnMetaData_default_instance_;
constexpr Row::Row(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : field_(){}
struct RowDefaultTypeInternal {
  constexpr RowDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RowDefaultTypeInternal() {}
  union {
    Row _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RowDefaultTypeInternal _Row_default_instance_;
constexpr TokenDone::TokenDone(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_left_(0){}
struct TokenDoneDefaultTypeInternal {
  constexpr TokenDoneDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TokenDoneDefaultTypeInternal() {}
  union {
    TokenDone _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TokenDoneDefaultTypeInternal _TokenDone_default_instance_;
constexpr Chunk::Chunk(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : columns_()
  , row_count_(0u){}
struct ChunkDefaultTypeInternal {
  constexpr ChunkDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ChunkDefaultTypeInternal() {}
  union {
    Chunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ChunkDefaultTypeInternal _Chunk_default_instance_;
constexpr Column::Column(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : null_bitmap_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fixed_size_column_(nullptr)
  , variable_size_column_(nullptr){}
struct ColumnDefaultTypeInternal {
  constexpr ColumnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ColumnDefaultTypeInternal() {}
  union {
    Column _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ColumnDefaultTypeInternal _Column_default_instance_;
constexpr FixedSizeColumn::FixedSizeColumn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct FixedSizeColumnDefaultTypeInternal {
  constexpr FixedSizeColumnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FixedSizeColumnDefaultTypeInternal() {}
  union {
    FixedSizeColumn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FixedSizeColumnDefaultTypeInternal _FixedSizeColumn_default_instance_;
constexpr VariableSizeColumn::VariableSizeColumn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct VariableSizeColumnDefaultTypeInternal {
  constexpr VariableSizeColumnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VariableSizeColumnDefaultTypeInternal() {}
  union {
    VariableSizeColumn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VariableSizeColumnDefaultTypeInternal _VariableSizeColumn_default_instance_;
}  // namespace Resultset
}  // namespace PolarXRPC
namespace PolarXRPC {
namespace Resultset {
bool ColumnMetaData_FieldType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 5:
    case 6:
    case 7:
    case 10:
    case 12:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ColumnMetaData_FieldType_strings[11] = {};

static const char ColumnMetaData_FieldType_names[] =
  "BIT"
  "BYTES"
  "DATETIME"
  "DECIMAL"
  "DOUBLE"
  "ENUM"
  "FLOAT"
  "SET"
  "SINT"
  "TIME"
  "UINT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ColumnMetaData_FieldType_entries[] = {
  { {ColumnMetaData_FieldType_names + 0, 3}, 17 },
  { {ColumnMetaData_FieldType_names + 3, 5}, 7 },
  { {ColumnMetaData_FieldType_names + 8, 8}, 12 },
  { {ColumnMetaData_FieldType_names + 16, 7}, 18 },
  { {ColumnMetaData_FieldType_names + 23, 6}, 5 },
  { {ColumnMetaData_FieldType_names + 29, 4}, 16 },
  { {ColumnMetaData_FieldType_names + 33, 5}, 6 },
  { {ColumnMetaData_FieldType_names + 38, 3}, 15 },
  { {ColumnMetaData_FieldType_names + 41, 4}, 1 },
  { {ColumnMetaData_FieldType_names + 45, 4}, 10 },
  { {ColumnMetaData_FieldType_names + 49, 4}, 2 },
};

static const int ColumnMetaData_FieldType_entries_by_number[] = {
  8, // 1 -> SINT
  10, // 2 -> UINT
  4, // 5 -> DOUBLE
  6, // 6 -> FLOAT
  1, // 7 -> BYTES
  9, // 10 -> TIME
  2, // 12 -> DATETIME
  7, // 15 -> SET
  5, // 16 -> ENUM
  0, // 17 -> BIT
  3, // 18 -> DECIMAL
};

const std::string& ColumnMetaData_FieldType_Name(
    ColumnMetaData_FieldType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ColumnMetaData_FieldType_entries,
          ColumnMetaData_FieldType_entries_by_number,
          11, ColumnMetaData_FieldType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ColumnMetaData_FieldType_entries,
      ColumnMetaData_FieldType_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ColumnMetaData_FieldType_strings[idx].get();
}
bool ColumnMetaData_FieldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnMetaData_FieldType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ColumnMetaData_FieldType_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<ColumnMetaData_FieldType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ColumnMetaData_FieldType ColumnMetaData::SINT;
constexpr ColumnMetaData_FieldType ColumnMetaData::UINT;
constexpr ColumnMetaData_FieldType ColumnMetaData::DOUBLE;
constexpr ColumnMetaData_FieldType ColumnMetaData::FLOAT;
constexpr ColumnMetaData_FieldType ColumnMetaData::BYTES;
constexpr ColumnMetaData_FieldType ColumnMetaData::TIME;
constexpr ColumnMetaData_FieldType ColumnMetaData::DATETIME;
constexpr ColumnMetaData_FieldType ColumnMetaData::SET;
constexpr ColumnMetaData_FieldType ColumnMetaData::ENUM;
constexpr ColumnMetaData_FieldType ColumnMetaData::BIT;
constexpr ColumnMetaData_FieldType ColumnMetaData::DECIMAL;
constexpr ColumnMetaData_FieldType ColumnMetaData::FieldType_MIN;
constexpr ColumnMetaData_FieldType ColumnMetaData::FieldType_MAX;
constexpr int ColumnMetaData::FieldType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ColumnMetaData_OriginalType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 255:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ColumnMetaData_OriginalType_strings[31] = {};

static const char ColumnMetaData_OriginalType_names[] =
  "MYSQL_TYPE_BIT"
  "MYSQL_TYPE_BLOB"
  "MYSQL_TYPE_DATE"
  "MYSQL_TYPE_DATETIME"
  "MYSQL_TYPE_DATETIME2"
  "MYSQL_TYPE_DECIMAL"
  "MYSQL_TYPE_DOUBLE"
  "MYSQL_TYPE_ENUM"
  "MYSQL_TYPE_FLOAT"
  "MYSQL_TYPE_GEOMETRY"
  "MYSQL_TYPE_INT24"
  "MYSQL_TYPE_JSON"
  "MYSQL_TYPE_LONG"
  "MYSQL_TYPE_LONGLONG"
  "MYSQL_TYPE_LONG_BLOB"
  "MYSQL_TYPE_MEDIUM_BLOB"
  "MYSQL_TYPE_NEWDATE"
  "MYSQL_TYPE_NEWDECIMAL"
  "MYSQL_TYPE_NULL"
  "MYSQL_TYPE_SET"
  "MYSQL_TYPE_SHORT"
  "MYSQL_TYPE_STRING"
  "MYSQL_TYPE_TIME"
  "MYSQL_TYPE_TIME2"
  "MYSQL_TYPE_TIMESTAMP"
  "MYSQL_TYPE_TIMESTAMP2"
  "MYSQL_TYPE_TINY"
  "MYSQL_TYPE_TINY_BLOB"
  "MYSQL_TYPE_VARCHAR"
  "MYSQL_TYPE_VAR_STRING"
  "MYSQL_TYPE_YEAR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ColumnMetaData_OriginalType_entries[] = {
  { {ColumnMetaData_OriginalType_names + 0, 14}, 16 },
  { {ColumnMetaData_OriginalType_names + 14, 15}, 252 },
  { {ColumnMetaData_OriginalType_names + 29, 15}, 10 },
  { {ColumnMetaData_OriginalType_names + 44, 19}, 12 },
  { {ColumnMetaData_OriginalType_names + 63, 20}, 18 },
  { {ColumnMetaData_OriginalType_names + 83, 18}, 0 },
  { {ColumnMetaData_OriginalType_names + 101, 17}, 5 },
  { {ColumnMetaData_OriginalType_names + 118, 15}, 247 },
  { {ColumnMetaData_OriginalType_names + 133, 16}, 4 },
  { {ColumnMetaData_OriginalType_names + 149, 19}, 255 },
  { {ColumnMetaData_OriginalType_names + 168, 16}, 9 },
  { {ColumnMetaData_OriginalType_names + 184, 15}, 245 },
  { {ColumnMetaData_OriginalType_names + 199, 15}, 3 },
  { {ColumnMetaData_OriginalType_names + 214, 19}, 8 },
  { {ColumnMetaData_OriginalType_names + 233, 20}, 251 },
  { {ColumnMetaData_OriginalType_names + 253, 22}, 250 },
  { {ColumnMetaData_OriginalType_names + 275, 18}, 14 },
  { {ColumnMetaData_OriginalType_names + 293, 21}, 246 },
  { {ColumnMetaData_OriginalType_names + 314, 15}, 6 },
  { {ColumnMetaData_OriginalType_names + 329, 14}, 248 },
  { {ColumnMetaData_OriginalType_names + 343, 16}, 2 },
  { {ColumnMetaData_OriginalType_names + 359, 17}, 254 },
  { {ColumnMetaData_OriginalType_names + 376, 15}, 11 },
  { {ColumnMetaData_OriginalType_names + 391, 16}, 19 },
  { {ColumnMetaData_OriginalType_names + 407, 20}, 7 },
  { {ColumnMetaData_OriginalType_names + 427, 21}, 17 },
  { {ColumnMetaData_OriginalType_names + 448, 15}, 1 },
  { {ColumnMetaData_OriginalType_names + 463, 20}, 249 },
  { {ColumnMetaData_OriginalType_names + 483, 18}, 15 },
  { {ColumnMetaData_OriginalType_names + 501, 21}, 253 },
  { {ColumnMetaData_OriginalType_names + 522, 15}, 13 },
};

static const int ColumnMetaData_OriginalType_entries_by_number[] = {
  5, // 0 -> MYSQL_TYPE_DECIMAL
  26, // 1 -> MYSQL_TYPE_TINY
  20, // 2 -> MYSQL_TYPE_SHORT
  12, // 3 -> MYSQL_TYPE_LONG
  8, // 4 -> MYSQL_TYPE_FLOAT
  6, // 5 -> MYSQL_TYPE_DOUBLE
  18, // 6 -> MYSQL_TYPE_NULL
  24, // 7 -> MYSQL_TYPE_TIMESTAMP
  13, // 8 -> MYSQL_TYPE_LONGLONG
  10, // 9 -> MYSQL_TYPE_INT24
  2, // 10 -> MYSQL_TYPE_DATE
  22, // 11 -> MYSQL_TYPE_TIME
  3, // 12 -> MYSQL_TYPE_DATETIME
  30, // 13 -> MYSQL_TYPE_YEAR
  16, // 14 -> MYSQL_TYPE_NEWDATE
  28, // 15 -> MYSQL_TYPE_VARCHAR
  0, // 16 -> MYSQL_TYPE_BIT
  25, // 17 -> MYSQL_TYPE_TIMESTAMP2
  4, // 18 -> MYSQL_TYPE_DATETIME2
  23, // 19 -> MYSQL_TYPE_TIME2
  11, // 245 -> MYSQL_TYPE_JSON
  17, // 246 -> MYSQL_TYPE_NEWDECIMAL
  7, // 247 -> MYSQL_TYPE_ENUM
  19, // 248 -> MYSQL_TYPE_SET
  27, // 249 -> MYSQL_TYPE_TINY_BLOB
  15, // 250 -> MYSQL_TYPE_MEDIUM_BLOB
  14, // 251 -> MYSQL_TYPE_LONG_BLOB
  1, // 252 -> MYSQL_TYPE_BLOB
  29, // 253 -> MYSQL_TYPE_VAR_STRING
  21, // 254 -> MYSQL_TYPE_STRING
  9, // 255 -> MYSQL_TYPE_GEOMETRY
};

const std::string& ColumnMetaData_OriginalType_Name(
    ColumnMetaData_OriginalType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ColumnMetaData_OriginalType_entries,
          ColumnMetaData_OriginalType_entries_by_number,
          31, ColumnMetaData_OriginalType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ColumnMetaData_OriginalType_entries,
      ColumnMetaData_OriginalType_entries_by_number,
      31, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ColumnMetaData_OriginalType_strings[idx].get();
}
bool ColumnMetaData_OriginalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnMetaData_OriginalType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ColumnMetaData_OriginalType_entries, 31, name, &int_value);
  if (success) {
    *value = static_cast<ColumnMetaData_OriginalType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_DECIMAL;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_TINY;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_SHORT;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_LONG;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_FLOAT;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_DOUBLE;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_NULL;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_TIMESTAMP;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_LONGLONG;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_INT24;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_DATE;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_TIME;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_DATETIME;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_YEAR;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_NEWDATE;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_VARCHAR;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_BIT;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_TIMESTAMP2;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_DATETIME2;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_TIME2;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_JSON;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_NEWDECIMAL;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_ENUM;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_SET;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_TINY_BLOB;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_MEDIUM_BLOB;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_LONG_BLOB;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_BLOB;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_VAR_STRING;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_STRING;
constexpr ColumnMetaData_OriginalType ColumnMetaData::MYSQL_TYPE_GEOMETRY;
constexpr ColumnMetaData_OriginalType ColumnMetaData::OriginalType_MIN;
constexpr ColumnMetaData_OriginalType ColumnMetaData::OriginalType_MAX;
constexpr int ColumnMetaData::OriginalType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class FetchDoneMoreOutParams::_Internal {
 public:
};

FetchDoneMoreOutParams::FetchDoneMoreOutParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.FetchDoneMoreOutParams)
}
FetchDoneMoreOutParams::FetchDoneMoreOutParams(const FetchDoneMoreOutParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.FetchDoneMoreOutParams)
}

inline void FetchDoneMoreOutParams::SharedCtor() {
}

FetchDoneMoreOutParams::~FetchDoneMoreOutParams() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.FetchDoneMoreOutParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FetchDoneMoreOutParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FetchDoneMoreOutParams::ArenaDtor(void* object) {
  FetchDoneMoreOutParams* _this = reinterpret_cast< FetchDoneMoreOutParams* >(object);
  (void)_this;
}
void FetchDoneMoreOutParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FetchDoneMoreOutParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchDoneMoreOutParams::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.FetchDoneMoreOutParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* FetchDoneMoreOutParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchDoneMoreOutParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.FetchDoneMoreOutParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.FetchDoneMoreOutParams)
  return target;
}

size_t FetchDoneMoreOutParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.FetchDoneMoreOutParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchDoneMoreOutParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchDoneMoreOutParams*>(
      &from));
}

void FetchDoneMoreOutParams::MergeFrom(const FetchDoneMoreOutParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.FetchDoneMoreOutParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchDoneMoreOutParams::CopyFrom(const FetchDoneMoreOutParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.FetchDoneMoreOutParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchDoneMoreOutParams::IsInitialized() const {
  return true;
}

void FetchDoneMoreOutParams::InternalSwap(FetchDoneMoreOutParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string FetchDoneMoreOutParams::GetTypeName() const {
  return "PolarXRPC.Resultset.FetchDoneMoreOutParams";
}


// ===================================================================

class FetchDoneMoreResultsets::_Internal {
 public:
};

FetchDoneMoreResultsets::FetchDoneMoreResultsets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.FetchDoneMoreResultsets)
}
FetchDoneMoreResultsets::FetchDoneMoreResultsets(const FetchDoneMoreResultsets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.FetchDoneMoreResultsets)
}

inline void FetchDoneMoreResultsets::SharedCtor() {
}

FetchDoneMoreResultsets::~FetchDoneMoreResultsets() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.FetchDoneMoreResultsets)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FetchDoneMoreResultsets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FetchDoneMoreResultsets::ArenaDtor(void* object) {
  FetchDoneMoreResultsets* _this = reinterpret_cast< FetchDoneMoreResultsets* >(object);
  (void)_this;
}
void FetchDoneMoreResultsets::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FetchDoneMoreResultsets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchDoneMoreResultsets::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.FetchDoneMoreResultsets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* FetchDoneMoreResultsets::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchDoneMoreResultsets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.FetchDoneMoreResultsets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.FetchDoneMoreResultsets)
  return target;
}

size_t FetchDoneMoreResultsets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.FetchDoneMoreResultsets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchDoneMoreResultsets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchDoneMoreResultsets*>(
      &from));
}

void FetchDoneMoreResultsets::MergeFrom(const FetchDoneMoreResultsets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.FetchDoneMoreResultsets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchDoneMoreResultsets::CopyFrom(const FetchDoneMoreResultsets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.FetchDoneMoreResultsets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchDoneMoreResultsets::IsInitialized() const {
  return true;
}

void FetchDoneMoreResultsets::InternalSwap(FetchDoneMoreResultsets* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string FetchDoneMoreResultsets::GetTypeName() const {
  return "PolarXRPC.Resultset.FetchDoneMoreResultsets";
}


// ===================================================================

class FetchDone::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchDone>()._has_bits_);
  static void set_has_examined_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chosen_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FetchDone::FetchDone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.FetchDone)
}
FetchDone::FetchDone(const FetchDone& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  chosen_index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chosen_index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chosen_index()) {
    chosen_index_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_chosen_index(), 
      GetArenaForAllocation());
  }
  examined_row_count_ = from.examined_row_count_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.FetchDone)
}

inline void FetchDone::SharedCtor() {
chosen_index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chosen_index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
examined_row_count_ = uint64_t{0u};
}

FetchDone::~FetchDone() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.FetchDone)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FetchDone::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chosen_index_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FetchDone::ArenaDtor(void* object) {
  FetchDone* _this = reinterpret_cast< FetchDone* >(object);
  (void)_this;
}
void FetchDone::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FetchDone::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchDone::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.FetchDone)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    chosen_index_.ClearNonDefaultToEmpty();
  }
  examined_row_count_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchDone::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 examined_row_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_examined_row_count(&has_bits);
          examined_row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes chosen_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chosen_index();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchDone::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.FetchDone)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 examined_row_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_examined_row_count(), target);
  }

  // optional bytes chosen_index = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_chosen_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.FetchDone)
  return target;
}

size_t FetchDone::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.FetchDone)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes chosen_index = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_chosen_index());
    }

    // optional uint64 examined_row_count = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_examined_row_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchDone::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchDone*>(
      &from));
}

void FetchDone::MergeFrom(const FetchDone& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.FetchDone)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_chosen_index(from._internal_chosen_index());
    }
    if (cached_has_bits & 0x00000002u) {
      examined_row_count_ = from.examined_row_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchDone::CopyFrom(const FetchDone& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.FetchDone)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchDone::IsInitialized() const {
  return true;
}

void FetchDone::InternalSwap(FetchDone* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &chosen_index_, lhs_arena,
      &other->chosen_index_, rhs_arena
  );
  swap(examined_row_count_, other->examined_row_count_);
}

std::string FetchDone::GetTypeName() const {
  return "PolarXRPC.Resultset.FetchDone";
}


// ===================================================================

class ColumnMetaData::_Internal {
 public:
  using HasBits = decltype(std::declval<ColumnMetaData>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_original_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_original_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_table(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_table(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_catalog(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_collation(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_fractional_digits(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_content_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_original_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00002040) ^ 0x00002040) != 0;
  }
};

ColumnMetaData::ColumnMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.ColumnMetaData)
}
ColumnMetaData::ColumnMetaData(const ColumnMetaData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  original_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    original_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_name()) {
    original_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_name(), 
      GetArenaForAllocation());
  }
  table_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_table()) {
    table_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_table(), 
      GetArenaForAllocation());
  }
  original_table_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    original_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_table()) {
    original_table_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_table(), 
      GetArenaForAllocation());
  }
  schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    schema_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_schema()) {
    schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema(), 
      GetArenaForAllocation());
  }
  catalog_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    catalog_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_catalog()) {
    catalog_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_catalog(), 
      GetArenaForAllocation());
  }
  ::memcpy(&original_type_, &from.original_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&original_type_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.ColumnMetaData)
}

inline void ColumnMetaData::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
original_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  original_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
table_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
original_table_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  original_table_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  schema_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
catalog_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  catalog_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&original_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&original_flags_) -
    reinterpret_cast<char*>(&original_type_)) + sizeof(original_flags_));
type_ = 1;
}

ColumnMetaData::~ColumnMetaData() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.ColumnMetaData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void ColumnMetaData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  table_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_table_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  catalog_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ColumnMetaData::ArenaDtor(void* object) {
  ColumnMetaData* _this = reinterpret_cast< ColumnMetaData* >(object);
  (void)_this;
}
void ColumnMetaData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ColumnMetaData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ColumnMetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.ColumnMetaData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      original_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      table_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      original_table_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      schema_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      catalog_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&original_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fractional_digits_) -
        reinterpret_cast<char*>(&original_type_)) + sizeof(fractional_digits_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&collation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&original_flags_) -
        reinterpret_cast<char*>(&collation_)) + sizeof(original_flags_));
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ColumnMetaData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PolarXRPC.Resultset.ColumnMetaData.FieldType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::Resultset::ColumnMetaData_FieldType_IsValid(val))) {
            _internal_set_type(static_cast<::PolarXRPC::Resultset::ColumnMetaData_FieldType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .PolarXRPC.Resultset.ColumnMetaData.OriginalType original_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PolarXRPC::Resultset::ColumnMetaData_OriginalType_IsValid(val))) {
            _internal_set_original_type(static_cast<::PolarXRPC::Resultset::ColumnMetaData_OriginalType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes original_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_original_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes table = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_table();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes original_table = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_original_table();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes schema = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_schema();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes catalog = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_catalog();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 collation = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_collation(&has_bits);
          collation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fractional_digits = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_fractional_digits(&has_bits);
          fractional_digits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 length = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 content_type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_content_type(&has_bits);
          content_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 original_flags = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_original_flags(&has_bits);
          original_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColumnMetaData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.ColumnMetaData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .PolarXRPC.Resultset.ColumnMetaData.FieldType type = 1;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required .PolarXRPC.Resultset.ColumnMetaData.OriginalType original_type = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_original_type(), target);
  }

  // optional bytes name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional bytes original_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_original_name(), target);
  }

  // optional bytes table = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_table(), target);
  }

  // optional bytes original_table = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_original_table(), target);
  }

  // optional bytes schema = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_schema(), target);
  }

  // optional bytes catalog = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_catalog(), target);
  }

  // optional uint64 collation = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_collation(), target);
  }

  // optional uint32 fractional_digits = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_fractional_digits(), target);
  }

  // optional uint32 length = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_length(), target);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_flags(), target);
  }

  // optional uint32 content_type = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_content_type(), target);
  }

  // optional uint32 original_flags = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->_internal_original_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.ColumnMetaData)
  return target;
}

size_t ColumnMetaData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PolarXRPC.Resultset.ColumnMetaData)
  size_t total_size = 0;

  if (_internal_has_original_type()) {
    // required .PolarXRPC.Resultset.ColumnMetaData.OriginalType original_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_original_type());
  }

  if (_internal_has_type()) {
    // required .PolarXRPC.Resultset.ColumnMetaData.FieldType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t ColumnMetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.ColumnMetaData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00002040) ^ 0x00002040) == 0) {  // All required fields are present.
    // required .PolarXRPC.Resultset.ColumnMetaData.OriginalType original_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_original_type());

    // required .PolarXRPC.Resultset.ColumnMetaData.FieldType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes original_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_original_name());
    }

    // optional bytes table = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_table());
    }

    // optional bytes original_table = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_original_table());
    }

    // optional bytes schema = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schema());
    }

    // optional bytes catalog = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_catalog());
    }

  }
  // optional uint32 fractional_digits = 10;
  if (cached_has_bits & 0x00000080u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_fractional_digits());
  }

  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 collation = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_collation());
    }

    // optional uint32 length = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
    }

    // optional uint32 flags = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 content_type = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_content_type());
    }

    // optional uint32 original_flags = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_original_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ColumnMetaData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ColumnMetaData*>(
      &from));
}

void ColumnMetaData::MergeFrom(const ColumnMetaData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.ColumnMetaData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_original_name(from._internal_original_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_table(from._internal_table());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_original_table(from._internal_original_table());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_schema(from._internal_schema());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_catalog(from._internal_catalog());
    }
    if (cached_has_bits & 0x00000040u) {
      original_type_ = from.original_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      fractional_digits_ = from.fractional_digits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      collation_ = from.collation_;
    }
    if (cached_has_bits & 0x00000200u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000400u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000800u) {
      content_type_ = from.content_type_;
    }
    if (cached_has_bits & 0x00001000u) {
      original_flags_ = from.original_flags_;
    }
    if (cached_has_bits & 0x00002000u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ColumnMetaData::CopyFrom(const ColumnMetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.ColumnMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnMetaData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ColumnMetaData::InternalSwap(ColumnMetaData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_name_, lhs_arena,
      &other->original_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &table_, lhs_arena,
      &other->table_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_table_, lhs_arena,
      &other->original_table_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_, lhs_arena,
      &other->schema_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &catalog_, lhs_arena,
      &other->catalog_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColumnMetaData, original_flags_)
      + sizeof(ColumnMetaData::original_flags_)
      - PROTOBUF_FIELD_OFFSET(ColumnMetaData, original_type_)>(
          reinterpret_cast<char*>(&original_type_),
          reinterpret_cast<char*>(&other->original_type_));
  swap(type_, other->type_);
}

std::string ColumnMetaData::GetTypeName() const {
  return "PolarXRPC.Resultset.ColumnMetaData";
}


// ===================================================================

class Row::_Internal {
 public:
};

Row::Row(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  field_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.Row)
}
Row::Row(const Row& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      field_(from.field_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.Row)
}

inline void Row::SharedCtor() {
}

Row::~Row() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.Row)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Row::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Row::ArenaDtor(void* object) {
  Row* _this = reinterpret_cast< Row* >(object);
  (void)_this;
}
void Row::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Row::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Row::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.Row)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  field_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Row::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes field = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_field();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Row::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.Row)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes field = 1;
  for (int i = 0, n = this->_internal_field_size(); i < n; i++) {
    const auto& s = this->_internal_field(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.Row)
  return target;
}

size_t Row::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.Row)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes field = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(field_.size());
  for (int i = 0, n = field_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      field_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Row::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Row*>(
      &from));
}

void Row::MergeFrom(const Row& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.Row)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  field_.MergeFrom(from.field_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Row::CopyFrom(const Row& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.Row)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Row::IsInitialized() const {
  return true;
}

void Row::InternalSwap(Row* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  field_.InternalSwap(&other->field_);
}

std::string Row::GetTypeName() const {
  return "PolarXRPC.Resultset.Row";
}


// ===================================================================

class TokenDone::_Internal {
 public:
  using HasBits = decltype(std::declval<TokenDone>()._has_bits_);
  static void set_has_token_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TokenDone::TokenDone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.TokenDone)
}
TokenDone::TokenDone(const TokenDone& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  token_left_ = from.token_left_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.TokenDone)
}

inline void TokenDone::SharedCtor() {
token_left_ = 0;
}

TokenDone::~TokenDone() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.TokenDone)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TokenDone::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TokenDone::ArenaDtor(void* object) {
  TokenDone* _this = reinterpret_cast< TokenDone* >(object);
  (void)_this;
}
void TokenDone::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TokenDone::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TokenDone::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.TokenDone)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  token_left_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TokenDone::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 token_left = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_token_left(&has_bits);
          token_left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenDone::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.TokenDone)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 token_left = 1 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_token_left(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.TokenDone)
  return target;
}

size_t TokenDone::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.TokenDone)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 token_left = 1 [default = 0];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_token_left());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TokenDone::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TokenDone*>(
      &from));
}

void TokenDone::MergeFrom(const TokenDone& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.TokenDone)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_token_left()) {
    _internal_set_token_left(from._internal_token_left());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TokenDone::CopyFrom(const TokenDone& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.TokenDone)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenDone::IsInitialized() const {
  return true;
}

void TokenDone::InternalSwap(TokenDone* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(token_left_, other->token_left_);
}

std::string TokenDone::GetTypeName() const {
  return "PolarXRPC.Resultset.TokenDone";
}


// ===================================================================

class Chunk::_Internal {
 public:
  using HasBits = decltype(std::declval<Chunk>()._has_bits_);
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Chunk::Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  columns_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.Chunk)
}
Chunk::Chunk(const Chunk& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      columns_(from.columns_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  row_count_ = from.row_count_;
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.Chunk)
}

inline void Chunk::SharedCtor() {
row_count_ = 0u;
}

Chunk::~Chunk() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.Chunk)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Chunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Chunk::ArenaDtor(void* object) {
  Chunk* _this = reinterpret_cast< Chunk* >(object);
  (void)_this;
}
void Chunk::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Chunk::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Chunk::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.Chunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  columns_.Clear();
  row_count_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Chunk::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 row_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_row_count(&has_bits);
          row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PolarXRPC.Resultset.Column columns = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_columns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Chunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.Chunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_row_count(), target);
  }

  // repeated .PolarXRPC.Resultset.Column columns = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_columns_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_columns(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.Chunk)
  return target;
}

size_t Chunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.Chunk)
  size_t total_size = 0;

  // required uint32 row_count = 1;
  if (_internal_has_row_count()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_row_count());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PolarXRPC.Resultset.Column columns = 2;
  total_size += 1UL * this->_internal_columns_size();
  for (const auto& msg : this->columns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Chunk::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Chunk*>(
      &from));
}

void Chunk::MergeFrom(const Chunk& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.Chunk)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  columns_.MergeFrom(from.columns_);
  if (from._internal_has_row_count()) {
    _internal_set_row_count(from._internal_row_count());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Chunk::CopyFrom(const Chunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.Chunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chunk::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(columns_))
    return false;
  return true;
}

void Chunk::InternalSwap(Chunk* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  columns_.InternalSwap(&other->columns_);
  swap(row_count_, other->row_count_);
}

std::string Chunk::GetTypeName() const {
  return "PolarXRPC.Resultset.Chunk";
}


// ===================================================================

class Column::_Internal {
 public:
  using HasBits = decltype(std::declval<Column>()._has_bits_);
  static void set_has_null_bitmap(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PolarXRPC::Resultset::FixedSizeColumn& fixed_size_column(const Column* msg);
  static void set_has_fixed_size_column(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::PolarXRPC::Resultset::VariableSizeColumn& variable_size_column(const Column* msg);
  static void set_has_variable_size_column(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::PolarXRPC::Resultset::FixedSizeColumn&
Column::_Internal::fixed_size_column(const Column* msg) {
  return *msg->fixed_size_column_;
}
const ::PolarXRPC::Resultset::VariableSizeColumn&
Column::_Internal::variable_size_column(const Column* msg) {
  return *msg->variable_size_column_;
}
Column::Column(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.Column)
}
Column::Column(const Column& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  null_bitmap_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    null_bitmap_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_null_bitmap()) {
    null_bitmap_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_null_bitmap(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_fixed_size_column()) {
    fixed_size_column_ = new ::PolarXRPC::Resultset::FixedSizeColumn(*from.fixed_size_column_);
  } else {
    fixed_size_column_ = nullptr;
  }
  if (from._internal_has_variable_size_column()) {
    variable_size_column_ = new ::PolarXRPC::Resultset::VariableSizeColumn(*from.variable_size_column_);
  } else {
    variable_size_column_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.Column)
}

inline void Column::SharedCtor() {
null_bitmap_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  null_bitmap_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fixed_size_column_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&variable_size_column_) -
    reinterpret_cast<char*>(&fixed_size_column_)) + sizeof(variable_size_column_));
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.Column)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Column::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  null_bitmap_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete fixed_size_column_;
  if (this != internal_default_instance()) delete variable_size_column_;
}

void Column::ArenaDtor(void* object) {
  Column* _this = reinterpret_cast< Column* >(object);
  (void)_this;
}
void Column::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Column::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Column::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.Column)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      null_bitmap_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(fixed_size_column_ != nullptr);
      fixed_size_column_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(variable_size_column_ != nullptr);
      variable_size_column_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Column::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes null_bitmap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_null_bitmap();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.Resultset.FixedSizeColumn fixed_size_column = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed_size_column(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PolarXRPC.Resultset.VariableSizeColumn variable_size_column = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_variable_size_column(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Column::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.Column)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes null_bitmap = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_null_bitmap(), target);
  }

  // optional .PolarXRPC.Resultset.FixedSizeColumn fixed_size_column = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::fixed_size_column(this), target, stream);
  }

  // optional .PolarXRPC.Resultset.VariableSizeColumn variable_size_column = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::variable_size_column(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.Column)
  return target;
}

size_t Column::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.Column)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes null_bitmap = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_null_bitmap());
    }

    // optional .PolarXRPC.Resultset.FixedSizeColumn fixed_size_column = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fixed_size_column_);
    }

    // optional .PolarXRPC.Resultset.VariableSizeColumn variable_size_column = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *variable_size_column_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Column::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Column*>(
      &from));
}

void Column::MergeFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.Column)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_null_bitmap(from._internal_null_bitmap());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_fixed_size_column()->::PolarXRPC::Resultset::FixedSizeColumn::MergeFrom(from._internal_fixed_size_column());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_variable_size_column()->::PolarXRPC::Resultset::VariableSizeColumn::MergeFrom(from._internal_variable_size_column());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Column::CopyFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.Column)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {
  if (_internal_has_fixed_size_column()) {
    if (!fixed_size_column_->IsInitialized()) return false;
  }
  if (_internal_has_variable_size_column()) {
    if (!variable_size_column_->IsInitialized()) return false;
  }
  return true;
}

void Column::InternalSwap(Column* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &null_bitmap_, lhs_arena,
      &other->null_bitmap_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Column, variable_size_column_)
      + sizeof(Column::variable_size_column_)
      - PROTOBUF_FIELD_OFFSET(Column, fixed_size_column_)>(
          reinterpret_cast<char*>(&fixed_size_column_),
          reinterpret_cast<char*>(&other->fixed_size_column_));
}

std::string Column::GetTypeName() const {
  return "PolarXRPC.Resultset.Column";
}


// ===================================================================

class FixedSizeColumn::_Internal {
 public:
  using HasBits = decltype(std::declval<FixedSizeColumn>()._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FixedSizeColumn::FixedSizeColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.FixedSizeColumn)
}
FixedSizeColumn::FixedSizeColumn(const FixedSizeColumn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.FixedSizeColumn)
}

inline void FixedSizeColumn::SharedCtor() {
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FixedSizeColumn::~FixedSizeColumn() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.FixedSizeColumn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FixedSizeColumn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FixedSizeColumn::ArenaDtor(void* object) {
  FixedSizeColumn* _this = reinterpret_cast< FixedSizeColumn* >(object);
  (void)_this;
}
void FixedSizeColumn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FixedSizeColumn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FixedSizeColumn::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.FixedSizeColumn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    value_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FixedSizeColumn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FixedSizeColumn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.FixedSizeColumn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.FixedSizeColumn)
  return target;
}

size_t FixedSizeColumn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.FixedSizeColumn)
  size_t total_size = 0;

  // required bytes value = 1;
  if (_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FixedSizeColumn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FixedSizeColumn*>(
      &from));
}

void FixedSizeColumn::MergeFrom(const FixedSizeColumn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.FixedSizeColumn)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FixedSizeColumn::CopyFrom(const FixedSizeColumn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.FixedSizeColumn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FixedSizeColumn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void FixedSizeColumn::InternalSwap(FixedSizeColumn* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

std::string FixedSizeColumn::GetTypeName() const {
  return "PolarXRPC.Resultset.FixedSizeColumn";
}


// ===================================================================

class VariableSizeColumn::_Internal {
 public:
  using HasBits = decltype(std::declval<VariableSizeColumn>()._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VariableSizeColumn::VariableSizeColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PolarXRPC.Resultset.VariableSizeColumn)
}
VariableSizeColumn::VariableSizeColumn(const VariableSizeColumn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:PolarXRPC.Resultset.VariableSizeColumn)
}

inline void VariableSizeColumn::SharedCtor() {
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VariableSizeColumn::~VariableSizeColumn() {
  // @@protoc_insertion_point(destructor:PolarXRPC.Resultset.VariableSizeColumn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void VariableSizeColumn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void VariableSizeColumn::ArenaDtor(void* object) {
  VariableSizeColumn* _this = reinterpret_cast< VariableSizeColumn* >(object);
  (void)_this;
}
void VariableSizeColumn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VariableSizeColumn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VariableSizeColumn::Clear() {
// @@protoc_insertion_point(message_clear_start:PolarXRPC.Resultset.VariableSizeColumn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    value_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VariableSizeColumn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VariableSizeColumn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PolarXRPC.Resultset.VariableSizeColumn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PolarXRPC.Resultset.VariableSizeColumn)
  return target;
}

size_t VariableSizeColumn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PolarXRPC.Resultset.VariableSizeColumn)
  size_t total_size = 0;

  // required bytes value = 1;
  if (_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VariableSizeColumn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VariableSizeColumn*>(
      &from));
}

void VariableSizeColumn::MergeFrom(const VariableSizeColumn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PolarXRPC.Resultset.VariableSizeColumn)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VariableSizeColumn::CopyFrom(const VariableSizeColumn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PolarXRPC.Resultset.VariableSizeColumn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VariableSizeColumn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void VariableSizeColumn::InternalSwap(VariableSizeColumn* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

std::string VariableSizeColumn::GetTypeName() const {
  return "PolarXRPC.Resultset.VariableSizeColumn";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Resultset
}  // namespace PolarXRPC
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::FetchDoneMoreOutParams* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::FetchDoneMoreOutParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::FetchDoneMoreOutParams >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::FetchDoneMoreResultsets* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::FetchDoneMoreResultsets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::FetchDoneMoreResultsets >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::FetchDone* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::FetchDone >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::FetchDone >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::ColumnMetaData* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::ColumnMetaData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::ColumnMetaData >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::Row* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::Row >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::Row >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::TokenDone* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::TokenDone >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::TokenDone >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::Chunk* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::Chunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::Chunk >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::Column* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::Column >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::Column >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::FixedSizeColumn* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::FixedSizeColumn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::FixedSizeColumn >(arena);
}
template<> PROTOBUF_NOINLINE ::PolarXRPC::Resultset::VariableSizeColumn* Arena::CreateMaybeMessage< ::PolarXRPC::Resultset::VariableSizeColumn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PolarXRPC::Resultset::VariableSizeColumn >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
