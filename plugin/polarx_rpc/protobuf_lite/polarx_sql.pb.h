// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polarx_sql.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_polarx_5fsql_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_polarx_5fsql_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "polarx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_polarx_5fsql_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_polarx_5fsql_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace PolarXRPC {
namespace Sql {
class StmtExecute;
struct StmtExecuteDefaultTypeInternal;
extern StmtExecuteDefaultTypeInternal _StmtExecute_default_instance_;
class StmtExecuteOk;
struct StmtExecuteOkDefaultTypeInternal;
extern StmtExecuteOkDefaultTypeInternal _StmtExecuteOk_default_instance_;
class TokenOffer;
struct TokenOfferDefaultTypeInternal;
extern TokenOfferDefaultTypeInternal _TokenOffer_default_instance_;
}  // namespace Sql
}  // namespace PolarXRPC
PROTOBUF_NAMESPACE_OPEN
template<> ::PolarXRPC::Sql::StmtExecute* Arena::CreateMaybeMessage<::PolarXRPC::Sql::StmtExecute>(Arena*);
template<> ::PolarXRPC::Sql::StmtExecuteOk* Arena::CreateMaybeMessage<::PolarXRPC::Sql::StmtExecuteOk>(Arena*);
template<> ::PolarXRPC::Sql::TokenOffer* Arena::CreateMaybeMessage<::PolarXRPC::Sql::TokenOffer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PolarXRPC {
namespace Sql {

// ===================================================================

class StmtExecute final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Sql.StmtExecute) */ {
 public:
  inline StmtExecute() : StmtExecute(nullptr) {}
  ~StmtExecute() override;
  explicit constexpr StmtExecute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StmtExecute(const StmtExecute& from);
  StmtExecute(StmtExecute&& from) noexcept
    : StmtExecute() {
    *this = ::std::move(from);
  }

  inline StmtExecute& operator=(const StmtExecute& from) {
    CopyFrom(from);
    return *this;
  }
  inline StmtExecute& operator=(StmtExecute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StmtExecute& default_instance() {
    return *internal_default_instance();
  }
  static inline const StmtExecute* internal_default_instance() {
    return reinterpret_cast<const StmtExecute*>(
               &_StmtExecute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StmtExecute& a, StmtExecute& b) {
    a.Swap(&b);
  }
  inline void Swap(StmtExecute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StmtExecute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StmtExecute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StmtExecute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StmtExecute& from);
  void MergeFrom(const StmtExecute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StmtExecute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Sql.StmtExecute";
  }
  protected:
  explicit StmtExecute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kSessionVariablesFieldNumber = 6,
    kStmtFieldNumber = 1,
    kNamespaceFieldNumber = 3,
    kSchemaNameFieldNumber = 5,
    kEncodingFieldNumber = 7,
    kStmtDigestFieldNumber = 12,
    kHintFieldNumber = 13,
    kSnapshotSeqFieldNumber = 10,
    kTokenFieldNumber = 8,
    kChunkResultFieldNumber = 14,
    kFeedBackFieldNumber = 16,
    kCompactMetadataFieldNumber = 4,
    kResetErrorFieldNumber = 9,
    kCommitSeqFieldNumber = 11,
    kCapabilitiesFieldNumber = 17,
    kUseCtsTransactionFieldNumber = 15,
    kMarkDistributedFieldNumber = 18,
    kQueryViaFlashbackAreaFieldNumber = 19,
  };
  // repeated .PolarXRPC.Datatypes.Any args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::PolarXRPC::Datatypes::Any* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Any >*
      mutable_args();
  private:
  const ::PolarXRPC::Datatypes::Any& _internal_args(int index) const;
  ::PolarXRPC::Datatypes::Any* _internal_add_args();
  public:
  const ::PolarXRPC::Datatypes::Any& args(int index) const;
  ::PolarXRPC::Datatypes::Any* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Any >&
      args() const;

  // repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 6;
  int session_variables_size() const;
  private:
  int _internal_session_variables_size() const;
  public:
  void clear_session_variables();
  ::PolarXRPC::Datatypes::SessionVariable* mutable_session_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >*
      mutable_session_variables();
  private:
  const ::PolarXRPC::Datatypes::SessionVariable& _internal_session_variables(int index) const;
  ::PolarXRPC::Datatypes::SessionVariable* _internal_add_session_variables();
  public:
  const ::PolarXRPC::Datatypes::SessionVariable& session_variables(int index) const;
  ::PolarXRPC::Datatypes::SessionVariable* add_session_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >&
      session_variables() const;

  // optional bytes stmt = 1;
  bool has_stmt() const;
  private:
  bool _internal_has_stmt() const;
  public:
  void clear_stmt();
  const std::string& stmt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stmt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stmt();
  PROTOBUF_NODISCARD std::string* release_stmt();
  void set_allocated_stmt(std::string* stmt);
  private:
  const std::string& _internal_stmt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stmt(const std::string& value);
  std::string* _internal_mutable_stmt();
  public:

  // optional string namespace = 3 [default = "sql"];
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // optional string schema_name = 5;
  bool has_schema_name() const;
  private:
  bool _internal_has_schema_name() const;
  public:
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // optional string encoding = 7;
  bool has_encoding() const;
  private:
  bool _internal_has_encoding() const;
  public:
  void clear_encoding();
  const std::string& encoding() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoding(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoding();
  PROTOBUF_NODISCARD std::string* release_encoding();
  void set_allocated_encoding(std::string* encoding);
  private:
  const std::string& _internal_encoding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoding(const std::string& value);
  std::string* _internal_mutable_encoding();
  public:

  // optional bytes stmt_digest = 12;
  bool has_stmt_digest() const;
  private:
  bool _internal_has_stmt_digest() const;
  public:
  void clear_stmt_digest();
  const std::string& stmt_digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stmt_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stmt_digest();
  PROTOBUF_NODISCARD std::string* release_stmt_digest();
  void set_allocated_stmt_digest(std::string* stmt_digest);
  private:
  const std::string& _internal_stmt_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stmt_digest(const std::string& value);
  std::string* _internal_mutable_stmt_digest();
  public:

  // optional bytes hint = 13;
  bool has_hint() const;
  private:
  bool _internal_has_hint() const;
  public:
  void clear_hint();
  const std::string& hint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hint();
  PROTOBUF_NODISCARD std::string* release_hint();
  void set_allocated_hint(std::string* hint);
  private:
  const std::string& _internal_hint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hint(const std::string& value);
  std::string* _internal_mutable_hint();
  public:

  // optional uint64 snapshot_seq = 10;
  bool has_snapshot_seq() const;
  private:
  bool _internal_has_snapshot_seq() const;
  public:
  void clear_snapshot_seq();
  uint64_t snapshot_seq() const;
  void set_snapshot_seq(uint64_t value);
  private:
  uint64_t _internal_snapshot_seq() const;
  void _internal_set_snapshot_seq(uint64_t value);
  public:

  // optional int32 token = 8;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  int32_t token() const;
  void set_token(int32_t value);
  private:
  int32_t _internal_token() const;
  void _internal_set_token(int32_t value);
  public:

  // optional bool chunk_result = 14 [default = false];
  bool has_chunk_result() const;
  private:
  bool _internal_has_chunk_result() const;
  public:
  void clear_chunk_result();
  bool chunk_result() const;
  void set_chunk_result(bool value);
  private:
  bool _internal_chunk_result() const;
  void _internal_set_chunk_result(bool value);
  public:

  // optional bool feed_back = 16 [default = false];
  bool has_feed_back() const;
  private:
  bool _internal_has_feed_back() const;
  public:
  void clear_feed_back();
  bool feed_back() const;
  void set_feed_back(bool value);
  private:
  bool _internal_feed_back() const;
  void _internal_set_feed_back(bool value);
  public:

  // optional bool compact_metadata = 4 [default = false];
  bool has_compact_metadata() const;
  private:
  bool _internal_has_compact_metadata() const;
  public:
  void clear_compact_metadata();
  bool compact_metadata() const;
  void set_compact_metadata(bool value);
  private:
  bool _internal_compact_metadata() const;
  void _internal_set_compact_metadata(bool value);
  public:

  // optional bool reset_error = 9;
  bool has_reset_error() const;
  private:
  bool _internal_has_reset_error() const;
  public:
  void clear_reset_error();
  bool reset_error() const;
  void set_reset_error(bool value);
  private:
  bool _internal_reset_error() const;
  void _internal_set_reset_error(bool value);
  public:

  // optional uint64 commit_seq = 11;
  bool has_commit_seq() const;
  private:
  bool _internal_has_commit_seq() const;
  public:
  void clear_commit_seq();
  uint64_t commit_seq() const;
  void set_commit_seq(uint64_t value);
  private:
  uint64_t _internal_commit_seq() const;
  void _internal_set_commit_seq(uint64_t value);
  public:

  // optional uint64 capabilities = 17;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  uint64_t capabilities() const;
  void set_capabilities(uint64_t value);
  private:
  uint64_t _internal_capabilities() const;
  void _internal_set_capabilities(uint64_t value);
  public:

  // optional bool use_cts_transaction = 15;
  bool has_use_cts_transaction() const;
  private:
  bool _internal_has_use_cts_transaction() const;
  public:
  void clear_use_cts_transaction();
  bool use_cts_transaction() const;
  void set_use_cts_transaction(bool value);
  private:
  bool _internal_use_cts_transaction() const;
  void _internal_set_use_cts_transaction(bool value);
  public:

  // optional bool mark_distributed = 18;
  bool has_mark_distributed() const;
  private:
  bool _internal_has_mark_distributed() const;
  public:
  void clear_mark_distributed();
  bool mark_distributed() const;
  void set_mark_distributed(bool value);
  private:
  bool _internal_mark_distributed() const;
  void _internal_set_mark_distributed(bool value);
  public:

  // optional bool query_via_flashback_area = 19;
  bool has_query_via_flashback_area() const;
  private:
  bool _internal_has_query_via_flashback_area() const;
  public:
  void clear_query_via_flashback_area();
  bool query_via_flashback_area() const;
  void set_query_via_flashback_area(bool value);
  private:
  bool _internal_query_via_flashback_area() const;
  void _internal_set_query_via_flashback_area(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.Sql.StmtExecute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Any > args_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable > session_variables_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stmt_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoding_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stmt_digest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hint_;
  uint64_t snapshot_seq_;
  int32_t token_;
  bool chunk_result_;
  bool feed_back_;
  bool compact_metadata_;
  bool reset_error_;
  uint64_t commit_seq_;
  uint64_t capabilities_;
  bool use_cts_transaction_;
  bool mark_distributed_;
  bool query_via_flashback_area_;
  friend struct ::TableStruct_polarx_5fsql_2eproto;
};
// -------------------------------------------------------------------

class StmtExecuteOk final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Sql.StmtExecuteOk) */ {
 public:
  inline StmtExecuteOk() : StmtExecuteOk(nullptr) {}
  ~StmtExecuteOk() override;
  explicit constexpr StmtExecuteOk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StmtExecuteOk(const StmtExecuteOk& from);
  StmtExecuteOk(StmtExecuteOk&& from) noexcept
    : StmtExecuteOk() {
    *this = ::std::move(from);
  }

  inline StmtExecuteOk& operator=(const StmtExecuteOk& from) {
    CopyFrom(from);
    return *this;
  }
  inline StmtExecuteOk& operator=(StmtExecuteOk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StmtExecuteOk& default_instance() {
    return *internal_default_instance();
  }
  static inline const StmtExecuteOk* internal_default_instance() {
    return reinterpret_cast<const StmtExecuteOk*>(
               &_StmtExecuteOk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StmtExecuteOk& a, StmtExecuteOk& b) {
    a.Swap(&b);
  }
  inline void Swap(StmtExecuteOk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StmtExecuteOk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StmtExecuteOk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StmtExecuteOk>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StmtExecuteOk& from);
  void MergeFrom(const StmtExecuteOk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StmtExecuteOk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Sql.StmtExecuteOk";
  }
  protected:
  explicit StmtExecuteOk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PolarXRPC.Sql.StmtExecuteOk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polarx_5fsql_2eproto;
};
// -------------------------------------------------------------------

class TokenOffer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PolarXRPC.Sql.TokenOffer) */ {
 public:
  inline TokenOffer() : TokenOffer(nullptr) {}
  ~TokenOffer() override;
  explicit constexpr TokenOffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenOffer(const TokenOffer& from);
  TokenOffer(TokenOffer&& from) noexcept
    : TokenOffer() {
    *this = ::std::move(from);
  }

  inline TokenOffer& operator=(const TokenOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenOffer& operator=(TokenOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TokenOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenOffer* internal_default_instance() {
    return reinterpret_cast<const TokenOffer*>(
               &_TokenOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TokenOffer& a, TokenOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenOffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenOffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenOffer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TokenOffer& from);
  void MergeFrom(const TokenOffer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TokenOffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PolarXRPC.Sql.TokenOffer";
  }
  protected:
  explicit TokenOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // optional int32 token = 1 [default = -1];
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  int32_t token() const;
  void set_token(int32_t value);
  private:
  int32_t _internal_token() const;
  void _internal_set_token(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PolarXRPC.Sql.TokenOffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t token_;
  friend struct ::TableStruct_polarx_5fsql_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StmtExecute

// optional string namespace = 3 [default = "sql"];
inline bool StmtExecute::_internal_has_namespace_() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StmtExecute::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void StmtExecute::clear_namespace_() {
  namespace__.ClearToDefault(::PolarXRPC::Sql::StmtExecute::_i_give_permission_to_break_this_code_default_namespace__, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StmtExecute::namespace_() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.namespace)
  if (namespace__.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_namespace__.get();
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StmtExecute::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.namespace)
}
inline std::string* StmtExecute::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.namespace)
  return _s;
}
inline const std::string& StmtExecute::_internal_namespace_() const {
  return namespace__.Get();
}
inline void StmtExecute::_internal_set_namespace_(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StmtExecute::_internal_mutable_namespace_() {
  _has_bits_[0] |= 0x00000002u;
  return namespace__.Mutable(::PolarXRPC::Sql::StmtExecute::_i_give_permission_to_break_this_code_default_namespace__, GetArenaForAllocation());
}
inline std::string* StmtExecute::release_namespace_() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Sql.StmtExecute.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = namespace__.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void StmtExecute::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespace__.SetAllocated(nullptr, namespace_,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Sql.StmtExecute.namespace)
}

// optional bytes stmt = 1;
inline bool StmtExecute::_internal_has_stmt() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StmtExecute::has_stmt() const {
  return _internal_has_stmt();
}
inline void StmtExecute::clear_stmt() {
  stmt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StmtExecute::stmt() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.stmt)
  return _internal_stmt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StmtExecute::set_stmt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 stmt_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.stmt)
}
inline std::string* StmtExecute::mutable_stmt() {
  std::string* _s = _internal_mutable_stmt();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.stmt)
  return _s;
}
inline const std::string& StmtExecute::_internal_stmt() const {
  return stmt_.Get();
}
inline void StmtExecute::_internal_set_stmt(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  stmt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StmtExecute::_internal_mutable_stmt() {
  _has_bits_[0] |= 0x00000001u;
  return stmt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StmtExecute::release_stmt() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Sql.StmtExecute.stmt)
  if (!_internal_has_stmt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = stmt_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stmt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stmt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StmtExecute::set_allocated_stmt(std::string* stmt) {
  if (stmt != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stmt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stmt,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stmt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stmt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Sql.StmtExecute.stmt)
}

// optional bytes stmt_digest = 12;
inline bool StmtExecute::_internal_has_stmt_digest() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StmtExecute::has_stmt_digest() const {
  return _internal_has_stmt_digest();
}
inline void StmtExecute::clear_stmt_digest() {
  stmt_digest_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StmtExecute::stmt_digest() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.stmt_digest)
  return _internal_stmt_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StmtExecute::set_stmt_digest(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 stmt_digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.stmt_digest)
}
inline std::string* StmtExecute::mutable_stmt_digest() {
  std::string* _s = _internal_mutable_stmt_digest();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.stmt_digest)
  return _s;
}
inline const std::string& StmtExecute::_internal_stmt_digest() const {
  return stmt_digest_.Get();
}
inline void StmtExecute::_internal_set_stmt_digest(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  stmt_digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StmtExecute::_internal_mutable_stmt_digest() {
  _has_bits_[0] |= 0x00000010u;
  return stmt_digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StmtExecute::release_stmt_digest() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Sql.StmtExecute.stmt_digest)
  if (!_internal_has_stmt_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = stmt_digest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stmt_digest_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stmt_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StmtExecute::set_allocated_stmt_digest(std::string* stmt_digest) {
  if (stmt_digest != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  stmt_digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stmt_digest,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stmt_digest_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stmt_digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Sql.StmtExecute.stmt_digest)
}

// optional bytes hint = 13;
inline bool StmtExecute::_internal_has_hint() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StmtExecute::has_hint() const {
  return _internal_has_hint();
}
inline void StmtExecute::clear_hint() {
  hint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& StmtExecute::hint() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.hint)
  return _internal_hint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StmtExecute::set_hint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 hint_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.hint)
}
inline std::string* StmtExecute::mutable_hint() {
  std::string* _s = _internal_mutable_hint();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.hint)
  return _s;
}
inline const std::string& StmtExecute::_internal_hint() const {
  return hint_.Get();
}
inline void StmtExecute::_internal_set_hint(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  hint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StmtExecute::_internal_mutable_hint() {
  _has_bits_[0] |= 0x00000020u;
  return hint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StmtExecute::release_hint() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Sql.StmtExecute.hint)
  if (!_internal_has_hint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = hint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StmtExecute::set_allocated_hint(std::string* hint) {
  if (hint != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  hint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Sql.StmtExecute.hint)
}

// optional bool chunk_result = 14 [default = false];
inline bool StmtExecute::_internal_has_chunk_result() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StmtExecute::has_chunk_result() const {
  return _internal_has_chunk_result();
}
inline void StmtExecute::clear_chunk_result() {
  chunk_result_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool StmtExecute::_internal_chunk_result() const {
  return chunk_result_;
}
inline bool StmtExecute::chunk_result() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.chunk_result)
  return _internal_chunk_result();
}
inline void StmtExecute::_internal_set_chunk_result(bool value) {
  _has_bits_[0] |= 0x00000100u;
  chunk_result_ = value;
}
inline void StmtExecute::set_chunk_result(bool value) {
  _internal_set_chunk_result(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.chunk_result)
}

// optional bool feed_back = 16 [default = false];
inline bool StmtExecute::_internal_has_feed_back() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StmtExecute::has_feed_back() const {
  return _internal_has_feed_back();
}
inline void StmtExecute::clear_feed_back() {
  feed_back_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool StmtExecute::_internal_feed_back() const {
  return feed_back_;
}
inline bool StmtExecute::feed_back() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.feed_back)
  return _internal_feed_back();
}
inline void StmtExecute::_internal_set_feed_back(bool value) {
  _has_bits_[0] |= 0x00000200u;
  feed_back_ = value;
}
inline void StmtExecute::set_feed_back(bool value) {
  _internal_set_feed_back(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.feed_back)
}

// repeated .PolarXRPC.Datatypes.Any args = 2;
inline int StmtExecute::_internal_args_size() const {
  return args_.size();
}
inline int StmtExecute::args_size() const {
  return _internal_args_size();
}
inline ::PolarXRPC::Datatypes::Any* StmtExecute::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Any >*
StmtExecute::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.Sql.StmtExecute.args)
  return &args_;
}
inline const ::PolarXRPC::Datatypes::Any& StmtExecute::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::PolarXRPC::Datatypes::Any& StmtExecute::args(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.args)
  return _internal_args(index);
}
inline ::PolarXRPC::Datatypes::Any* StmtExecute::_internal_add_args() {
  return args_.Add();
}
inline ::PolarXRPC::Datatypes::Any* StmtExecute::add_args() {
  ::PolarXRPC::Datatypes::Any* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:PolarXRPC.Sql.StmtExecute.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::Any >&
StmtExecute::args() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.Sql.StmtExecute.args)
  return args_;
}

// optional bool compact_metadata = 4 [default = false];
inline bool StmtExecute::_internal_has_compact_metadata() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StmtExecute::has_compact_metadata() const {
  return _internal_has_compact_metadata();
}
inline void StmtExecute::clear_compact_metadata() {
  compact_metadata_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool StmtExecute::_internal_compact_metadata() const {
  return compact_metadata_;
}
inline bool StmtExecute::compact_metadata() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.compact_metadata)
  return _internal_compact_metadata();
}
inline void StmtExecute::_internal_set_compact_metadata(bool value) {
  _has_bits_[0] |= 0x00000400u;
  compact_metadata_ = value;
}
inline void StmtExecute::set_compact_metadata(bool value) {
  _internal_set_compact_metadata(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.compact_metadata)
}

// optional string schema_name = 5;
inline bool StmtExecute::_internal_has_schema_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StmtExecute::has_schema_name() const {
  return _internal_has_schema_name();
}
inline void StmtExecute::clear_schema_name() {
  schema_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StmtExecute::schema_name() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StmtExecute::set_schema_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 schema_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.schema_name)
}
inline std::string* StmtExecute::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.schema_name)
  return _s;
}
inline const std::string& StmtExecute::_internal_schema_name() const {
  return schema_name_.Get();
}
inline void StmtExecute::_internal_set_schema_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  schema_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StmtExecute::_internal_mutable_schema_name() {
  _has_bits_[0] |= 0x00000004u;
  return schema_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StmtExecute::release_schema_name() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Sql.StmtExecute.schema_name)
  if (!_internal_has_schema_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = schema_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StmtExecute::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  schema_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Sql.StmtExecute.schema_name)
}

// repeated .PolarXRPC.Datatypes.SessionVariable session_variables = 6;
inline int StmtExecute::_internal_session_variables_size() const {
  return session_variables_.size();
}
inline int StmtExecute::session_variables_size() const {
  return _internal_session_variables_size();
}
inline ::PolarXRPC::Datatypes::SessionVariable* StmtExecute::mutable_session_variables(int index) {
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.session_variables)
  return session_variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >*
StmtExecute::mutable_session_variables() {
  // @@protoc_insertion_point(field_mutable_list:PolarXRPC.Sql.StmtExecute.session_variables)
  return &session_variables_;
}
inline const ::PolarXRPC::Datatypes::SessionVariable& StmtExecute::_internal_session_variables(int index) const {
  return session_variables_.Get(index);
}
inline const ::PolarXRPC::Datatypes::SessionVariable& StmtExecute::session_variables(int index) const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.session_variables)
  return _internal_session_variables(index);
}
inline ::PolarXRPC::Datatypes::SessionVariable* StmtExecute::_internal_add_session_variables() {
  return session_variables_.Add();
}
inline ::PolarXRPC::Datatypes::SessionVariable* StmtExecute::add_session_variables() {
  ::PolarXRPC::Datatypes::SessionVariable* _add = _internal_add_session_variables();
  // @@protoc_insertion_point(field_add:PolarXRPC.Sql.StmtExecute.session_variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PolarXRPC::Datatypes::SessionVariable >&
StmtExecute::session_variables() const {
  // @@protoc_insertion_point(field_list:PolarXRPC.Sql.StmtExecute.session_variables)
  return session_variables_;
}

// optional string encoding = 7;
inline bool StmtExecute::_internal_has_encoding() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StmtExecute::has_encoding() const {
  return _internal_has_encoding();
}
inline void StmtExecute::clear_encoding() {
  encoding_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StmtExecute::encoding() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.encoding)
  return _internal_encoding();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StmtExecute::set_encoding(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 encoding_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.encoding)
}
inline std::string* StmtExecute::mutable_encoding() {
  std::string* _s = _internal_mutable_encoding();
  // @@protoc_insertion_point(field_mutable:PolarXRPC.Sql.StmtExecute.encoding)
  return _s;
}
inline const std::string& StmtExecute::_internal_encoding() const {
  return encoding_.Get();
}
inline void StmtExecute::_internal_set_encoding(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encoding_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StmtExecute::_internal_mutable_encoding() {
  _has_bits_[0] |= 0x00000008u;
  return encoding_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StmtExecute::release_encoding() {
  // @@protoc_insertion_point(field_release:PolarXRPC.Sql.StmtExecute.encoding)
  if (!_internal_has_encoding()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = encoding_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoding_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoding_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StmtExecute::set_allocated_encoding(std::string* encoding) {
  if (encoding != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encoding_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoding,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoding_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoding_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PolarXRPC.Sql.StmtExecute.encoding)
}

// optional int32 token = 8;
inline bool StmtExecute::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StmtExecute::has_token() const {
  return _internal_has_token();
}
inline void StmtExecute::clear_token() {
  token_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t StmtExecute::_internal_token() const {
  return token_;
}
inline int32_t StmtExecute::token() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.token)
  return _internal_token();
}
inline void StmtExecute::_internal_set_token(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  token_ = value;
}
inline void StmtExecute::set_token(int32_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.token)
}

// optional bool reset_error = 9;
inline bool StmtExecute::_internal_has_reset_error() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StmtExecute::has_reset_error() const {
  return _internal_has_reset_error();
}
inline void StmtExecute::clear_reset_error() {
  reset_error_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool StmtExecute::_internal_reset_error() const {
  return reset_error_;
}
inline bool StmtExecute::reset_error() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.reset_error)
  return _internal_reset_error();
}
inline void StmtExecute::_internal_set_reset_error(bool value) {
  _has_bits_[0] |= 0x00000800u;
  reset_error_ = value;
}
inline void StmtExecute::set_reset_error(bool value) {
  _internal_set_reset_error(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.reset_error)
}

// optional uint64 snapshot_seq = 10;
inline bool StmtExecute::_internal_has_snapshot_seq() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StmtExecute::has_snapshot_seq() const {
  return _internal_has_snapshot_seq();
}
inline void StmtExecute::clear_snapshot_seq() {
  snapshot_seq_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t StmtExecute::_internal_snapshot_seq() const {
  return snapshot_seq_;
}
inline uint64_t StmtExecute::snapshot_seq() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.snapshot_seq)
  return _internal_snapshot_seq();
}
inline void StmtExecute::_internal_set_snapshot_seq(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  snapshot_seq_ = value;
}
inline void StmtExecute::set_snapshot_seq(uint64_t value) {
  _internal_set_snapshot_seq(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.snapshot_seq)
}

// optional uint64 commit_seq = 11;
inline bool StmtExecute::_internal_has_commit_seq() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool StmtExecute::has_commit_seq() const {
  return _internal_has_commit_seq();
}
inline void StmtExecute::clear_commit_seq() {
  commit_seq_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline uint64_t StmtExecute::_internal_commit_seq() const {
  return commit_seq_;
}
inline uint64_t StmtExecute::commit_seq() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.commit_seq)
  return _internal_commit_seq();
}
inline void StmtExecute::_internal_set_commit_seq(uint64_t value) {
  _has_bits_[0] |= 0x00001000u;
  commit_seq_ = value;
}
inline void StmtExecute::set_commit_seq(uint64_t value) {
  _internal_set_commit_seq(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.commit_seq)
}

// optional bool use_cts_transaction = 15;
inline bool StmtExecute::_internal_has_use_cts_transaction() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool StmtExecute::has_use_cts_transaction() const {
  return _internal_has_use_cts_transaction();
}
inline void StmtExecute::clear_use_cts_transaction() {
  use_cts_transaction_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool StmtExecute::_internal_use_cts_transaction() const {
  return use_cts_transaction_;
}
inline bool StmtExecute::use_cts_transaction() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.use_cts_transaction)
  return _internal_use_cts_transaction();
}
inline void StmtExecute::_internal_set_use_cts_transaction(bool value) {
  _has_bits_[0] |= 0x00004000u;
  use_cts_transaction_ = value;
}
inline void StmtExecute::set_use_cts_transaction(bool value) {
  _internal_set_use_cts_transaction(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.use_cts_transaction)
}

// optional uint64 capabilities = 17;
inline bool StmtExecute::_internal_has_capabilities() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool StmtExecute::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void StmtExecute::clear_capabilities() {
  capabilities_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline uint64_t StmtExecute::_internal_capabilities() const {
  return capabilities_;
}
inline uint64_t StmtExecute::capabilities() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.capabilities)
  return _internal_capabilities();
}
inline void StmtExecute::_internal_set_capabilities(uint64_t value) {
  _has_bits_[0] |= 0x00002000u;
  capabilities_ = value;
}
inline void StmtExecute::set_capabilities(uint64_t value) {
  _internal_set_capabilities(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.capabilities)
}

// optional bool mark_distributed = 18;
inline bool StmtExecute::_internal_has_mark_distributed() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool StmtExecute::has_mark_distributed() const {
  return _internal_has_mark_distributed();
}
inline void StmtExecute::clear_mark_distributed() {
  mark_distributed_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool StmtExecute::_internal_mark_distributed() const {
  return mark_distributed_;
}
inline bool StmtExecute::mark_distributed() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.mark_distributed)
  return _internal_mark_distributed();
}
inline void StmtExecute::_internal_set_mark_distributed(bool value) {
  _has_bits_[0] |= 0x00008000u;
  mark_distributed_ = value;
}
inline void StmtExecute::set_mark_distributed(bool value) {
  _internal_set_mark_distributed(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.mark_distributed)
}

// optional bool query_via_flashback_area = 19;
inline bool StmtExecute::_internal_has_query_via_flashback_area() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool StmtExecute::has_query_via_flashback_area() const {
  return _internal_has_query_via_flashback_area();
}
inline void StmtExecute::clear_query_via_flashback_area() {
  query_via_flashback_area_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool StmtExecute::_internal_query_via_flashback_area() const {
  return query_via_flashback_area_;
}
inline bool StmtExecute::query_via_flashback_area() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.StmtExecute.query_via_flashback_area)
  return _internal_query_via_flashback_area();
}
inline void StmtExecute::_internal_set_query_via_flashback_area(bool value) {
  _has_bits_[0] |= 0x00010000u;
  query_via_flashback_area_ = value;
}
inline void StmtExecute::set_query_via_flashback_area(bool value) {
  _internal_set_query_via_flashback_area(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.StmtExecute.query_via_flashback_area)
}

// -------------------------------------------------------------------

// StmtExecuteOk

// -------------------------------------------------------------------

// TokenOffer

// optional int32 token = 1 [default = -1];
inline bool TokenOffer::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TokenOffer::has_token() const {
  return _internal_has_token();
}
inline void TokenOffer::clear_token() {
  token_ = -1;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t TokenOffer::_internal_token() const {
  return token_;
}
inline int32_t TokenOffer::token() const {
  // @@protoc_insertion_point(field_get:PolarXRPC.Sql.TokenOffer.token)
  return _internal_token();
}
inline void TokenOffer::_internal_set_token(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  token_ = value;
}
inline void TokenOffer::set_token(int32_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PolarXRPC.Sql.TokenOffer.token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Sql
}  // namespace PolarXRPC

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_polarx_5fsql_2eproto
